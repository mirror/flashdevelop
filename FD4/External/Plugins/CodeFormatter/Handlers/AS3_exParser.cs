// $ANTLR 3.1.1 AS3_ex.g3 2009-08-01 20:20:28

using System.Collections.Generic;
using System.Text.RegularExpressions;
using CodeFormatter.Handlers;

using System;
using Antlr.Runtime;
using IList = System.Collections.IList;
using ArrayList = System.Collections.ArrayList;
using Stack = Antlr.Runtime.Collections.StackList;
using IDictionary = System.Collections.IDictionary;
using Hashtable = System.Collections.Hashtable;
using Antlr.Runtime.Tree;

public class AS3_exParser : Parser
{
    public static readonly string[] tokenNames = new string[] 
	{
        "<invalid>", 
		"<EOR>", 
		"<DOWN>", 
		"<UP>", 
		"AS", 
		"BREAK", 
		"CASE", 
		"CATCH", 
		"CLASS", 
		"CONST", 
		"CONTINUE", 
		"DEFAULT", 
		"DELETE", 
		"DO", 
		"ELSE", 
		"EXTENDS", 
		"FALSE", 
		"FINALLY", 
		"FOR", 
		"FUNCTION", 
		"IF", 
		"IMPLEMENTS", 
		"IMPORT", 
		"IN", 
		"INSTANCEOF", 
		"INTERFACE", 
		"INTERNAL", 
		"IS", 
		"NATIVE", 
		"NEW", 
		"NULL", 
		"PACKAGE", 
		"PRIVATE", 
		"PROTECTED", 
		"PUBLIC", 
		"RETURN", 
		"SUPER", 
		"SWITCH", 
		"THIS", 
		"THROW", 
		"TO", 
		"TRUE", 
		"TRY", 
		"TYPEOF", 
		"USE", 
		"VAR", 
		"VOID", 
		"WHILE", 
		"WITH", 
		"EACH", 
		"GET", 
		"SET", 
		"NAMESPACE", 
		"INCLUDE", 
		"DYNAMIC", 
		"FINAL", 
		"OVERRIDE", 
		"STATIC", 
		"SEMI", 
		"LCURLY", 
		"RCURLY", 
		"LPAREN", 
		"RPAREN", 
		"LBRACK", 
		"RBRACK", 
		"DOT", 
		"COMMA", 
		"LT", 
		"GT", 
		"LTE", 
		"GTE", 
		"EQ", 
		"NEQ", 
		"SAME", 
		"NSAME", 
		"PLUS", 
		"SUB", 
		"STAR", 
		"DIV", 
		"MOD", 
		"INC", 
		"DEC", 
		"SHL", 
		"SHR", 
		"SHU", 
		"AND", 
		"OR", 
		"XOR", 
		"NOT", 
		"INV", 
		"LAND", 
		"LOR", 
		"QUE", 
		"COLON", 
		"ASSIGN", 
		"UNDERSCORE", 
		"DOLLAR", 
		"DIV_ASSIGN", 
		"MOD_ASSIGN", 
		"ADD_ASSIGN", 
		"SUB_ASSIGN", 
		"SHL_ASSIGN", 
		"SHR_ASSIGN", 
		"SHU_ASSIGN", 
		"LAND_ASSIGN", 
		"LOR_ASSIGN", 
		"AND_ASSIGN", 
		"XOR_ASSIGN", 
		"OR_ASSIGN", 
		"ELLIPSIS", 
		"XML_ELLIPSIS", 
		"XML_TEND", 
		"XML_E_TEND", 
		"XML_NS_OP", 
		"XML_AT", 
		"XML_LS_STD", 
		"XML_LS_END", 
		"ALPHABET", 
		"NUMBER", 
		"HEX_DIGIT", 
		"CR", 
		"LF", 
		"UNICODE_ESCAPE", 
		"ESCAPE_SEQUENCE", 
		"EOL", 
		"WHITESPACE", 
		"COMMENT_MULTILINE", 
		"COMMENT_SINGLELINE", 
		"SINGLE_QUOTE_LITERAL", 
		"DOUBLE_QUOTE_LITERAL", 
		"REGULAR_EXPR_BODY", 
		"REGULAR_EXPR_FLAG", 
		"REGULAR_EXPR_LITERAL", 
		"REGULAR_EXPR_FIRST_CHAR", 
		"REGULAR_EXPR_CHAR", 
		"BACKSLASH_SEQUENCE", 
		"IDENT_PART", 
		"HEX_NUMBER_LITERAL", 
		"DEC_NUMBER", 
		"EXPONENT", 
		"DEC_NUMBER_LITERAL", 
		"IDENT_NAME_ASCII_START", 
		"IDENTIFIER", 
		"IDENT_ASCII_START", 
		"XML_COMMENT", 
		"XML_CDATA", 
		"XML_PI", 
		"XML_TEXT"
    };

    public const int PACKAGE = 31;
    public const int FUNCTION = 19;
    public const int SHR = 83;
    public const int LOR = 91;
    public const int INTERNAL = 26;
    public const int EXPONENT = 139;
    public const int LT = 67;
    public const int STAR = 77;
    public const int BACKSLASH_SEQUENCE = 135;
    public const int WHILE = 47;
    public const int MOD = 79;
    public const int SHL = 82;
    public const int CONST = 9;
    public const int MOD_ASSIGN = 98;
    public const int CASE = 6;
    public const int NEW = 29;
    public const int DO = 13;
    public const int IDENT_ASCII_START = 143;
    public const int NOT = 88;
    public const int HEX_NUMBER_LITERAL = 137;
    public const int EOF = -1;
    public const int DIV_ASSIGN = 97;
    public const int BREAK = 5;
    public const int FINAL = 55;
    public const int RPAREN = 62;
    public const int INC = 80;
    public const int IMPORT = 22;
    public const int EOL = 124;
    public const int XML_AT = 114;
    public const int INCLUDE = 53;
    public const int THIS = 38;
    public const int RETURN = 35;
    public const int XML_PI = 146;
    public const int XML_CDATA = 145;
    public const int REGULAR_EXPR_FIRST_CHAR = 133;
    public const int IDENT_NAME_ASCII_START = 141;
    public const int GET = 50;
    public const int VAR = 45;
    public const int VOID = 46;
    public const int SUPER = 36;
    public const int EACH = 49;
    public const int EQ = 71;
    public const int SHU = 84;
    public const int RBRACK = 64;
    public const int ADD_ASSIGN = 99;
    public const int PRIVATE = 32;
    public const int STATIC = 57;
    public const int INV = 89;
    public const int SWITCH = 37;
    public const int NULL = 30;
    public const int LAND_ASSIGN = 104;
    public const int ELSE = 14;
    public const int NUMBER = 118;
    public const int DOUBLE_QUOTE_LITERAL = 129;
    public const int ELLIPSIS = 109;
    public const int NATIVE = 28;
    public const int WHITESPACE = 125;
    public const int UNDERSCORE = 95;
    public const int LCURLY = 59;
    public const int DELETE = 12;
    public const int TRY = 42;
    public const int NAMESPACE = 52;
    public const int REGULAR_EXPR_CHAR = 134;
    public const int TYPEOF = 43;
    public const int XML_LS_END = 116;
    public const int QUE = 92;
    public const int OR = 86;
    public const int IDENT_PART = 136;
    public const int GT = 68;
    public const int USE = 44;
    public const int DEC_NUMBER = 138;
    public const int CATCH = 7;
    public const int FALSE = 16;
    public const int LAND = 90;
    public const int XML_E_TEND = 112;
    public const int THROW = 39;
    public const int DYNAMIC = 54;
    public const int COMMENT_SINGLELINE = 127;
    public const int DOLLAR = 96;
    public const int PROTECTED = 33;
    public const int DEC = 81;
    public const int CLASS = 8;
    public const int LBRACK = 63;
    public const int REGULAR_EXPR_BODY = 130;
    public const int GTE = 70;
    public const int FOR = 18;
    public const int SHU_ASSIGN = 103;
    public const int SUB = 76;
    public const int AND = 85;
    public const int AND_ASSIGN = 106;
    public const int LTE = 69;
    public const int XML_LS_STD = 115;
    public const int LPAREN = 61;
    public const int SHR_ASSIGN = 102;
    public const int IF = 20;
    public const int ESCAPE_SEQUENCE = 123;
    public const int AS = 4;
    public const int XML_COMMENT = 144;
    public const int UNICODE_ESCAPE = 122;
    public const int SHL_ASSIGN = 101;
    public const int DEC_NUMBER_LITERAL = 140;
    public const int IN = 23;
    public const int IMPLEMENTS = 21;
    public const int CONTINUE = 10;
    public const int COMMA = 66;
    public const int IS = 27;
    public const int IDENTIFIER = 142;
    public const int XML_ELLIPSIS = 110;
    public const int XOR_ASSIGN = 107;
    public const int PLUS = 75;
    public const int DOT = 65;
    public const int WITH = 48;
    public const int XOR = 87;
    public const int TO = 40;
    public const int ALPHABET = 117;
    public const int DEFAULT = 11;
    public const int NSAME = 74;
    public const int REGULAR_EXPR_FLAG = 131;
    public const int HEX_DIGIT = 119;
    public const int SET = 51;
    public const int INSTANCEOF = 24;
    public const int XML_TEXT = 147;
    public const int TRUE = 41;
    public const int SEMI = 58;
    public const int SAME = 73;
    public const int COLON = 93;
    public const int OR_ASSIGN = 108;
    public const int NEQ = 72;
    public const int SINGLE_QUOTE_LITERAL = 128;
    public const int FINALLY = 17;
    public const int OVERRIDE = 56;
    public const int XML_NS_OP = 113;
    public const int RCURLY = 60;
    public const int ASSIGN = 94;
    public const int REGULAR_EXPR_LITERAL = 132;
    public const int INTERFACE = 25;
    public const int XML_TEND = 111;
    public const int DIV = 78;
    public const int CR = 120;
    public const int PUBLIC = 34;
    public const int EXTENDS = 15;
    public const int SUB_ASSIGN = 100;
    public const int COMMENT_MULTILINE = 126;
    public const int LOR_ASSIGN = 105;
    public const int LF = 121;

    // delegates
    // delegators



    public AS3_exParser(ITokenStream input)
        : this(input, new RecognizerSharedState())
    {
    }

    public AS3_exParser(ITokenStream input, RecognizerSharedState state)
        : base(input, state)
    {
        InitializeCyclicDFAs();
        this.state.ruleMemo = new Hashtable[540 + 1];


    }

    protected ITreeAdaptor adaptor = new CommonTreeAdaptor();

    public ITreeAdaptor TreeAdaptor
    {
        get { return this.adaptor; }
        set
        {
            this.adaptor = value;
        }
    }

    override public string[] TokenNames
    {
        get { return AS3_exParser.tokenNames; }
    }

    override public string GrammarFileName
    {
        get { return "AS3_ex.g3"; }
    }



    //options
    //private List<Exception> mParseErrors;

    private ASPrettyPrinter mPrinter;
    private CommonTokenStream mRawTokens;

    private List<IfElseBlockTracker> mIfElseBlocks = new List<IfElseBlockTracker>();

    public AS3_exParser(ASPrettyPrinter printer, CommonTokenStream tokenStream)
        : this(tokenStream, new RecognizerSharedState())
    {
        mRawTokens = tokenStream;
        mPrinter = printer;
    }

    public class IfElseBlockTracker
    {
        public bool mBlockFlag = false;
        public bool mBlockFlagSet = false;
    }

    public void AddIfElseBlockTracker()
    {
        mIfElseBlocks.Add(new IfElseBlockTracker());
    }

    public void PopIfElseBlockTracker()
    {
        if (mIfElseBlocks.Count > 0)
            mIfElseBlocks.RemoveAt(mIfElseBlocks.Count - 1);
    }

    public IfElseBlockTracker GetCurrentIfElseTracker()
    {
        if (mIfElseBlocks.Count > 0)
            return mIfElseBlocks.ToArray()[mIfElseBlocks.Count - 1];

        return null;
    }

    public void SetBlockFlag(bool flag)
    {
        IfElseBlockTracker tracker = GetCurrentIfElseTracker();
        if (tracker != null)
        {
            //don't set if already set
            if (tracker.mBlockFlagSet)
                return;

            tracker.mBlockFlag = flag;
            tracker.mBlockFlagSet = true;
        }
    }

    public void MarkBlockFlag()
    {
        IfElseBlockTracker tracker = GetCurrentIfElseTracker();
        if (tracker != null)
            tracker.mBlockFlagSet = true;
    }

    public void ClearBlockFlag()
    {
        IfElseBlockTracker tracker = GetCurrentIfElseTracker();
        if (tracker != null)
            tracker.mBlockFlagSet = false;
    }

    public bool IsBlockFlag()
    {
        IfElseBlockTracker tracker = GetCurrentIfElseTracker();
        if (tracker != null)
            return tracker.mBlockFlag;

        return false;
    }

    public bool FoundNextLT()
    {
        int i = 1;
        while (true)
        {
            CommonToken token = (CommonToken)input.LT(i);
            if (token.Text != null && token.Text.StartsWith("<"))
                return (i > 1);
            if (token.Type == EOF)
                return false;
            i++;
        }
    }

    public void ChangeTokensUpToNextLT()
    {
        int i = 1;
        while (true)
        {
            CommonToken t = (CommonToken)input.LT(i);
            if (t.Text != null && t.Text.StartsWith("<"))
                return;
            if (t.Type == EOF)
                return;
            t.Type = XML_TEXT;

            i++;
        }
    }

    private void IndentEmit(CommonToken tokenOperator)
    {
        PushExpressionIndent();
        WrapOptions options = mPrinter.GetExpressionWrapOptions();
        if ((options.WrapType == WrapOptions.WRAP_BY_COLUMN || options.WrapType == WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && options.BeforeSeparator)
        {
            InsertMaxColumnCR();
        }
        char firstChar = Convert.ToChar(0);
        if (tokenOperator.Text.Length > 0)
            firstChar = tokenOperator.Text.ToCharArray()[0];
        if (firstChar != Convert.ToChar(0))
        {
            if (IsIdentifierPart(firstChar))
                InsertWS(1); //add 1 space around text operators (ex. 'as', 'instanceof')
            else
                InsertWS(mPrinter.GetExpressionSpacesAroundSymbolicOperators()); //add configurable symbolic operator value
        }
        Emit(tokenOperator);
        if ((options.WrapType == WrapOptions.WRAP_BY_COLUMN || options.WrapType == WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && !options.BeforeSeparator)
        {
            InsertMaxColumnCR();
        }
        if (firstChar != 0)
        {
            if (IsIdentifierPart(firstChar))
                InsertWS(1); //add 1 space around text operators (ex. 'as', 'instanceof')
            else
                InsertWS(mPrinter.GetExpressionSpacesAroundSymbolicOperators()); //add configurable symbolic operator value
        }
    }

    public static bool IsIdentifierPart(char ch)
    {
        return Char.IsLetterOrDigit(ch) || ch == '_';
    }

    private bool PushFormatType(WrapOptions options, bool lazy)
    {
        if (mPrinter.IsDoFormat())
        {
            int formatMode = 0;
            if (options.WrapType == WrapOptions.WRAP_DONT_PROCESS)
            {
                formatMode = ASPrettyPrinter.FORMAT_INDENT;
            }
            else if (options.WrapType == WrapOptions.WRAP_FORMAT_NO_CRs)
            {
                formatMode = ASPrettyPrinter.FORMAT_NOCRs;
            }
            else if (options.WrapType == WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS)
            {
                formatMode = ASPrettyPrinter.FORMAT_OnlyAddCRs;
            }
            else
            {
                //if we didn't have a restrictive format, we want to make sure we're using the full format
                formatMode = ASPrettyPrinter.FORMAT_ALL;
            }

            if (formatMode > 0)
            {
                mPrinter.SetFirstTokenBeforeFormatIndent();
                if (lazy)
                    mPrinter.PushLazyFormat(formatMode);
                else
                    mPrinter.PushFormatMode(formatMode);
                return true;
            }

        }

        return false;
    }

    private void EmitCRForTag(WrapOptions options)
    {
        if (options.WrapType == WrapOptions.WRAP_BY_COLUMN || options.WrapType == WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS)
        {
            InsertMaxColumnCR();
        }
        else if (options.WrapType == WrapOptions.WRAP_BY_TAG)
        {
            InsertCR(false);
        }

    }

    private bool EmitCommaWithSpacingAndCRs(WrapOptions options, CommonToken comma, bool pushedIndent)
    {
        if ((options.WrapType == WrapOptions.WRAP_BY_COLUMN || options.WrapType == WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && options.BeforeSeparator)
        {
            InsertMaxColumnCR();
        }

        if (!pushedIndent)
        {
            pushedIndent = true;
            PushExpressionIndent();
        }

        InsertWS(mPrinter.GetSpacesBeforeComma());
        Emit(comma);
        if ((options.WrapType == WrapOptions.WRAP_BY_COLUMN || options.WrapType == WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && !options.BeforeSeparator)
        {
            InsertMaxColumnCR();
        }
        InsertWS(mPrinter.GetSpacesAfterComma());
        return pushedIndent;
    }

    public bool FindVirtualHiddenToken(ParserRuleReturnScope retval)
    {
        int index = ((CommonToken)retval.Start).TokenIndex;
        if (index < 0)
        {
            index = input.Count;
        }
        for (int ix = index - 1; ix >= 0; ix--)
        {
            CommonToken lt = (CommonToken)input.Get(ix);
            int type = lt.Type;
            if (lt.Channel == Token.DEFAULT_CHANNEL)
                break;
            if (type == EOL || type == COMMENT_SINGLELINE || (type == COMMENT_MULTILINE && Regex.Match(lt.Text, "/.*\r\n|\r|\n").Success))
            {
                retval.Start = lt;
                return true;
            }
        }
        return false;

    }

    /*public void ReportError(RecognitionException e)
    {
        if (mParseErrors==null)
            mParseErrors=new List<Exception>();
        mParseErrors.add(e);
        base.ReportError(e);
    }*/

    private void InsertWS(int amt)
    {
        mPrinter.InsertWS(amt);
    }

    private void InsertLines(int amt)
    {
        InsertLines(amt, true);
    }

    private void InsertVariableDeclAssignmentWhitespace(CommonToken equalToken, bool before)
    {
        if (mPrinter.IsDoFormat() && !mPrinter.IsInParameterDecl() && mPrinter.IsKeepingExcessDeclWhitespace())
        {
            int spaceCount = 0;
            if (before)
            {
                CommonToken testToken = (CommonToken)mRawTokens.Get(equalToken.TokenIndex - 1);
                if (testToken.Channel == CHANNEL_WHITESPACE)
                {
                    //if the token before the whitespace is a carriage return, we *don't* want to apply this "preserve whitespace" logic
                    CommonToken prevTok = (CommonToken)mRawTokens.Get(equalToken.TokenIndex - 2);
                    if (!(prevTok.Channel == CHANNEL_SLCOMMENT || prevTok.Channel == CHANNEL_EOL))
                    {
                        if (testToken.Text.IndexOf('\t') >= 0)
                        {
                            spaceCount = mPrinter.GetColumnForIndex(equalToken, 0) - mPrinter.GetColumnForIndex(testToken, 0);
                        }
                        else
                        {
                            spaceCount = testToken.Text.Length;
                        }
                    }
                }
            }
            else
            {
                CommonToken testToken = (CommonToken)mRawTokens.Get(equalToken.TokenIndex + 1);
                if (testToken.Channel == CHANNEL_WHITESPACE)
                {
                    //if the token after the whitespace is a carriage return, we *don't* want to apply this "preserve whitespace" logic
                    //I think we only care about actual EOL here, not sl comment or ml comment, since there is actual text before the CR,
                    //even if it's not 'code' text.
                    CommonToken nextTok = (CommonToken)mRawTokens.Get(equalToken.TokenIndex + 2);
                    if (!(nextTok.Channel == CHANNEL_EOL))
                    {
                        if (testToken.Text.IndexOf('\t') >= 0)
                        {
                            spaceCount = mPrinter.GetColumnForIndex(testToken, testToken.Text.Length) - mPrinter.GetColumnForIndex(equalToken, equalToken.Text.Length);
                        }
                        else
                        {
                            spaceCount = testToken.Text.Length;
                        }
                    }
                }
            }

            if (spaceCount > mPrinter.GetSpacesAroundAssignment())
            {
                InsertWS(spaceCount);
                return;
            }
        }

        InsertWS(mPrinter.IsInParameterDecl() ? mPrinter.GetAdvancedSpacesAroundAssignmentInOptionalParameters() : mPrinter.GetSpacesAroundAssignment());
    }

    //this method is for inserting blank lines before elements, based on the format settings
    private void InsertLines(int amt, bool inCodeBlock)
    {
        //don't add blank lines if not inside a block
        if (!mPrinter.IsHardIndent())
            return;
        //don't add blank lines if the wrapper is a labeled statement indent
        if (mPrinter.IsLabeledIndent())
            return;

        //don't add blank lines if we are at start of block
        if (inCodeBlock)
        {
            if (!mPrinter.IsCanAddCRsAtBlockStart() && mPrinter.IsAtBlockStart())
            {
                return;
            }
        }

        for (int i = 0; i < amt; i++)
        {
            mPrinter.InsertCR(true);
        }
    }

    private void InsertMaxColumnCR()
    {
        mPrinter.InsertCRBeyondMaxCol();
    }

    private void InsertStatementCR()
    {
        if (!mPrinter.IsLabeledIndent())
            InsertCR(false);
    }

    private void InsertCR(bool doOverride)
    {
        mPrinter.InsertCR(doOverride);
    }

    private void PushLabeledIndent()
    {
        PushExpressionIndent(); //push an expression indent so that it won't further indent the nested statement 
        mPrinter.MakeLabeledIndent();
    }

    private void PushIndent(bool hardIndent)
    {
        mPrinter.PushIndent(hardIndent ? ASPrettyPrinter.BRACE_INDENT : ASPrettyPrinter.STATEMENT_INDENT);
    }

    private void PushExpressionIndent()
    {
        mPrinter.PushIndent(ASPrettyPrinter.EXPRESSION_INDENT);
    }

    private bool PushLazyParmIndent(bool alreadyPushed, int indentStyle)
    {
        if (!alreadyPushed)
        {
            if (indentStyle == WrapOptions.WRAP_STYLE_INDENT_TO_WRAP_ELEMENT)
                mPrinter.PushLazyIndent(ASPrettyPrinter.EXPRESSION_INDENT_NEXTITEM);
            else
                PushLazyIndent();
        }
        return true;
    }

    private void PushLazyIndent()
    {
        mPrinter.PushLazyIndent(ASPrettyPrinter.EXPRESSION_INDENT);
    }

    private void PopIndent()
    {
        mPrinter.PopIndent();
    }

    private void LeftCurlyNewlineHandler(bool checkBraceIndent)
    {
        if (mPrinter.IsCRBeforeOpenBrace() || (checkBraceIndent && mPrinter.GetIndentType(0) == ASPrettyPrinter.BRACE_INDENT))
            InsertCR(false);
        else
            InsertWS(1);
    }

    private void Emit(CommonToken tok)
    {
        mPrinter.Emit(tok);
    }


    /*public List<Exception> getParseErrors()
    {
        return mParseErrors;
    }*/


    public const int CHANNEL_SLCOMMENT = 43;
    public const int CHANNEL_MLCOMMENT = 42;
    public const int CHANNEL_WHITESPACE = 41;
    public const int CHANNEL_EOL = 40;

    private bool PromoteWhitespace()
    {
        //find the current lookahead token
        CommonToken lt = (CommonToken)input.LT(1);
        int index = lt.TokenIndex;
        if (index < 0)
        {
            index = input.Count;
        }

        //walk backward through tokens to see if the previous token is whitespace.
        for (int ix = index - 1; ix >= 0; ix--)
        {
            lt = (CommonToken)input.Get(ix);
            int channel = lt.Channel;
            if (channel == CHANNEL_EOL || channel == CHANNEL_WHITESPACE)
            {
                return true;
            }
            else if (channel == Token.DEFAULT_CHANNEL)
            {
                break;
            }
        }
        return false;
    }


    public class booleanLiteral_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "booleanLiteral"
    // AS3_ex.g3:1237:1: booleanLiteral : (T= TRUE | F= FALSE );
    public AS3_exParser.booleanLiteral_return booleanLiteral() // throws RecognitionException [1]
    {
        AS3_exParser.booleanLiteral_return retval = new AS3_exParser.booleanLiteral_return();
        retval.Start = input.LT(1);
        int booleanLiteral_StartIndex = input.Index();
        object root_0 = null;

        IToken T = null;
        IToken F = null;

        object T_tree = null;
        object F_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 1))
            {
                return retval;
            }
            // AS3_ex.g3:1237:36: (T= TRUE | F= FALSE )
            int alt1 = 2;
            int LA1_0 = input.LA(1);

            if ((LA1_0 == TRUE))
            {
                alt1 = 1;
            }
            else if ((LA1_0 == FALSE))
            {
                alt1 = 2;
            }
            else
            {
                if (state.backtracking > 0) { state.failed = true; return retval; }
                NoViableAltException nvae_d1s0 =
                    new NoViableAltException("", 1, 0, input);

                throw nvae_d1s0;
            }
            switch (alt1)
            {
                case 1:
                    // AS3_ex.g3:1237:40: T= TRUE
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        T = (IToken)Match(input, TRUE, FOLLOW_TRUE_in_booleanLiteral3587); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            T_tree = (object)adaptor.Create(T);
                            adaptor.AddChild(root_0, T_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)T);
                        }

                    }
                    break;
                case 2:
                    // AS3_ex.g3:1237:74: F= FALSE
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        F = (IToken)Match(input, FALSE, FOLLOW_FALSE_in_booleanLiteral3595); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            F_tree = (object)adaptor.Create(F);
                            adaptor.AddChild(root_0, F_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)F);
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 1, booleanLiteral_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "booleanLiteral"

    public class numericLiteral_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "numericLiteral"
    // AS3_ex.g3:1239:1: numericLiteral : (D= DEC_NUMBER_LITERAL | H= HEX_NUMBER_LITERAL );
    public AS3_exParser.numericLiteral_return numericLiteral() // throws RecognitionException [1]
    {
        AS3_exParser.numericLiteral_return retval = new AS3_exParser.numericLiteral_return();
        retval.Start = input.LT(1);
        int numericLiteral_StartIndex = input.Index();
        object root_0 = null;

        IToken D = null;
        IToken H = null;

        object D_tree = null;
        object H_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 2))
            {
                return retval;
            }
            // AS3_ex.g3:1239:36: (D= DEC_NUMBER_LITERAL | H= HEX_NUMBER_LITERAL )
            int alt2 = 2;
            int LA2_0 = input.LA(1);

            if ((LA2_0 == DEC_NUMBER_LITERAL))
            {
                alt2 = 1;
            }
            else if ((LA2_0 == HEX_NUMBER_LITERAL))
            {
                alt2 = 2;
            }
            else
            {
                if (state.backtracking > 0) { state.failed = true; return retval; }
                NoViableAltException nvae_d2s0 =
                    new NoViableAltException("", 2, 0, input);

                throw nvae_d2s0;
            }
            switch (alt2)
            {
                case 1:
                    // AS3_ex.g3:1239:40: D= DEC_NUMBER_LITERAL
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        D = (IToken)Match(input, DEC_NUMBER_LITERAL, FOLLOW_DEC_NUMBER_LITERAL_in_numericLiteral3629); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            D_tree = (object)adaptor.Create(D);
                            adaptor.AddChild(root_0, D_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)D);
                        }

                    }
                    break;
                case 2:
                    // AS3_ex.g3:1239:88: H= HEX_NUMBER_LITERAL
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        H = (IToken)Match(input, HEX_NUMBER_LITERAL, FOLLOW_HEX_NUMBER_LITERAL_in_numericLiteral3637); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            H_tree = (object)adaptor.Create(H);
                            adaptor.AddChild(root_0, H_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)H);
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 2, numericLiteral_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "numericLiteral"

    public class stringLiteral_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "stringLiteral"
    // AS3_ex.g3:1241:1: stringLiteral : (S= SINGLE_QUOTE_LITERAL | D= DOUBLE_QUOTE_LITERAL );
    public AS3_exParser.stringLiteral_return stringLiteral() // throws RecognitionException [1]
    {
        AS3_exParser.stringLiteral_return retval = new AS3_exParser.stringLiteral_return();
        retval.Start = input.LT(1);
        int stringLiteral_StartIndex = input.Index();
        object root_0 = null;

        IToken S = null;
        IToken D = null;

        object S_tree = null;
        object D_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 3))
            {
                return retval;
            }
            // AS3_ex.g3:1241:36: (S= SINGLE_QUOTE_LITERAL | D= DOUBLE_QUOTE_LITERAL )
            int alt3 = 2;
            int LA3_0 = input.LA(1);

            if ((LA3_0 == SINGLE_QUOTE_LITERAL))
            {
                alt3 = 1;
            }
            else if ((LA3_0 == DOUBLE_QUOTE_LITERAL))
            {
                alt3 = 2;
            }
            else
            {
                if (state.backtracking > 0) { state.failed = true; return retval; }
                NoViableAltException nvae_d3s0 =
                    new NoViableAltException("", 3, 0, input);

                throw nvae_d3s0;
            }
            switch (alt3)
            {
                case 1:
                    // AS3_ex.g3:1241:40: S= SINGLE_QUOTE_LITERAL
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        S = (IToken)Match(input, SINGLE_QUOTE_LITERAL, FOLLOW_SINGLE_QUOTE_LITERAL_in_stringLiteral3672); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            S_tree = (object)adaptor.Create(S);
                            adaptor.AddChild(root_0, S_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)S);
                        }

                    }
                    break;
                case 2:
                    // AS3_ex.g3:1241:89: D= DOUBLE_QUOTE_LITERAL
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        D = (IToken)Match(input, DOUBLE_QUOTE_LITERAL, FOLLOW_DOUBLE_QUOTE_LITERAL_in_stringLiteral3679); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            D_tree = (object)adaptor.Create(D);
                            adaptor.AddChild(root_0, D_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)D);
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 3, stringLiteral_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "stringLiteral"

    public class regularExpresionLiteral_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "regularExpresionLiteral"
    // AS3_ex.g3:1243:1: regularExpresionLiteral : R= REGULAR_EXPR_LITERAL ;
    public AS3_exParser.regularExpresionLiteral_return regularExpresionLiteral() // throws RecognitionException [1]
    {
        AS3_exParser.regularExpresionLiteral_return retval = new AS3_exParser.regularExpresionLiteral_return();
        retval.Start = input.LT(1);
        int regularExpresionLiteral_StartIndex = input.Index();
        object root_0 = null;

        IToken R = null;

        object R_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 4))
            {
                return retval;
            }
            // AS3_ex.g3:1243:36: (R= REGULAR_EXPR_LITERAL )
            // AS3_ex.g3:1243:40: R= REGULAR_EXPR_LITERAL
            {
                root_0 = (object)adaptor.GetNilNode();

                R = (IToken)Match(input, REGULAR_EXPR_LITERAL, FOLLOW_REGULAR_EXPR_LITERAL_in_regularExpresionLiteral3704); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)R);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 4, regularExpresionLiteral_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "regularExpresionLiteral"

    public class identifierLiteral_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "identifierLiteral"
    // AS3_ex.g3:1245:1: identifierLiteral : (I= IDENTIFIER | notQuiteReservedWord );
    public AS3_exParser.identifierLiteral_return identifierLiteral() // throws RecognitionException [1]
    {
        AS3_exParser.identifierLiteral_return retval = new AS3_exParser.identifierLiteral_return();
        retval.Start = input.LT(1);
        int identifierLiteral_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        AS3_exParser.notQuiteReservedWord_return notQuiteReservedWord1 = null;


        object I_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 5))
            {
                return retval;
            }
            // AS3_ex.g3:1245:36: (I= IDENTIFIER | notQuiteReservedWord )
            int alt4 = 2;
            int LA4_0 = input.LA(1);

            if ((LA4_0 == IDENTIFIER))
            {
                alt4 = 1;
            }
            else if ((LA4_0 == NATIVE || LA4_0 == TO || (LA4_0 >= EACH && LA4_0 <= NAMESPACE) || (LA4_0 >= DYNAMIC && LA4_0 <= STATIC)))
            {
                alt4 = 2;
            }
            else
            {
                if (state.backtracking > 0) { state.failed = true; return retval; }
                NoViableAltException nvae_d4s0 =
                    new NoViableAltException("", 4, 0, input);

                throw nvae_d4s0;
            }
            switch (alt4)
            {
                case 1:
                    // AS3_ex.g3:1245:83: I= IDENTIFIER
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        I = (IToken)Match(input, IDENTIFIER, FOLLOW_IDENTIFIER_in_identifierLiteral3737); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            I_tree = (object)adaptor.Create(I);
                            adaptor.AddChild(root_0, I_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)I);
                        }

                    }
                    break;
                case 2:
                    // AS3_ex.g3:1245:122: notQuiteReservedWord
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_notQuiteReservedWord_in_identifierLiteral3742);
                        notQuiteReservedWord1 = notQuiteReservedWord();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, notQuiteReservedWord1.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 5, identifierLiteral_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "identifierLiteral"

    public class xmlNameLiteral_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "xmlNameLiteral"
    // AS3_ex.g3:1247:1: xmlNameLiteral : (I= IDENTIFIER | allKeywords ) ({...}? => (s= SUB | d= DOT | c= COLON ) {...}? => (I2= IDENTIFIER | allKeywords ) )* ;
    public AS3_exParser.xmlNameLiteral_return xmlNameLiteral() // throws RecognitionException [1]
    {
        AS3_exParser.xmlNameLiteral_return retval = new AS3_exParser.xmlNameLiteral_return();
        retval.Start = input.LT(1);
        int xmlNameLiteral_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        IToken s = null;
        IToken d = null;
        IToken c = null;
        IToken I2 = null;
        AS3_exParser.allKeywords_return allKeywords2 = null;

        AS3_exParser.allKeywords_return allKeywords3 = null;


        object I_tree = null;
        object s_tree = null;
        object d_tree = null;
        object c_tree = null;
        object I2_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 6))
            {
                return retval;
            }
            // AS3_ex.g3:1247:36: ( (I= IDENTIFIER | allKeywords ) ({...}? => (s= SUB | d= DOT | c= COLON ) {...}? => (I2= IDENTIFIER | allKeywords ) )* )
            // AS3_ex.g3:1247:40: (I= IDENTIFIER | allKeywords ) ({...}? => (s= SUB | d= DOT | c= COLON ) {...}? => (I2= IDENTIFIER | allKeywords ) )*
            {
                root_0 = (object)adaptor.GetNilNode();

                // AS3_ex.g3:1247:40: (I= IDENTIFIER | allKeywords )
                int alt5 = 2;
                int LA5_0 = input.LA(1);

                if ((LA5_0 == IDENTIFIER))
                {
                    alt5 = 1;
                }
                else if (((LA5_0 >= AS && LA5_0 <= STATIC)))
                {
                    alt5 = 2;
                }
                else
                {
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    NoViableAltException nvae_d5s0 =
                        new NoViableAltException("", 5, 0, input);

                    throw nvae_d5s0;
                }
                switch (alt5)
                {
                    case 1:
                        // AS3_ex.g3:1247:41: I= IDENTIFIER
                        {
                            I = (IToken)Match(input, IDENTIFIER, FOLLOW_IDENTIFIER_in_xmlNameLiteral3777); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                I_tree = (object)adaptor.Create(I);
                                adaptor.AddChild(root_0, I_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)I);
                            }

                        }
                        break;
                    case 2:
                        // AS3_ex.g3:1247:80: allKeywords
                        {
                            PushFollow(FOLLOW_allKeywords_in_xmlNameLiteral3782);
                            allKeywords2 = allKeywords();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, allKeywords2.Tree);

                        }
                        break;

                }

                // AS3_ex.g3:1247:93: ({...}? => (s= SUB | d= DOT | c= COLON ) {...}? => (I2= IDENTIFIER | allKeywords ) )*
                do
                {
                    int alt8 = 2;
                    alt8 = dfa8.Predict(input);
                    switch (alt8)
                    {
                        case 1:
                            // AS3_ex.g3:1247:95: {...}? => (s= SUB | d= DOT | c= COLON ) {...}? => (I2= IDENTIFIER | allKeywords )
                            {
                                if (!((!PromoteWhitespace())))
                                {
                                    if (state.backtracking > 0) { state.failed = true; return retval; }
                                    throw new FailedPredicateException(input, "xmlNameLiteral", "!PromoteWhitespace()");
                                }
                                // AS3_ex.g3:1247:121: (s= SUB | d= DOT | c= COLON )
                                int alt6 = 3;
                                switch (input.LA(1))
                                {
                                    case SUB:
                                        {
                                            alt6 = 1;
                                        }
                                        break;
                                    case DOT:
                                        {
                                            alt6 = 2;
                                        }
                                        break;
                                    case COLON:
                                        {
                                            alt6 = 3;
                                        }
                                        break;
                                    default:
                                        if (state.backtracking > 0) { state.failed = true; return retval; }
                                        NoViableAltException nvae_d6s0 =
                                            new NoViableAltException("", 6, 0, input);

                                        throw nvae_d6s0;
                                }

                                switch (alt6)
                                {
                                    case 1:
                                        // AS3_ex.g3:1247:122: s= SUB
                                        {
                                            s = (IToken)Match(input, SUB, FOLLOW_SUB_in_xmlNameLiteral3793); if (state.failed) return retval;
                                            if (state.backtracking == 0)
                                            {
                                                s_tree = (object)adaptor.Create(s);
                                                adaptor.AddChild(root_0, s_tree);
                                            }
                                            if (state.backtracking == 0)
                                            {
                                                Emit((CommonToken)s);
                                            }

                                        }
                                        break;
                                    case 2:
                                        // AS3_ex.g3:1247:155: d= DOT
                                        {
                                            d = (IToken)Match(input, DOT, FOLLOW_DOT_in_xmlNameLiteral3801); if (state.failed) return retval;
                                            if (state.backtracking == 0)
                                            {
                                                d_tree = (object)adaptor.Create(d);
                                                adaptor.AddChild(root_0, d_tree);
                                            }
                                            if (state.backtracking == 0)
                                            {
                                                Emit((CommonToken)d);
                                            }

                                        }
                                        break;
                                    case 3:
                                        // AS3_ex.g3:1247:188: c= COLON
                                        {
                                            c = (IToken)Match(input, COLON, FOLLOW_COLON_in_xmlNameLiteral3809); if (state.failed) return retval;
                                            if (state.backtracking == 0)
                                            {
                                                c_tree = (object)adaptor.Create(c);
                                                adaptor.AddChild(root_0, c_tree);
                                            }
                                            if (state.backtracking == 0)
                                            {
                                                Emit((CommonToken)c);
                                            }

                                        }
                                        break;

                                }

                                if (!((!PromoteWhitespace())))
                                {
                                    if (state.backtracking > 0) { state.failed = true; return retval; }
                                    throw new FailedPredicateException(input, "xmlNameLiteral", "!PromoteWhitespace()");
                                }
                                // AS3_ex.g3:1247:248: (I2= IDENTIFIER | allKeywords )
                                int alt7 = 2;
                                int LA7_0 = input.LA(1);

                                if ((LA7_0 == IDENTIFIER))
                                {
                                    alt7 = 1;
                                }
                                else if (((LA7_0 >= AS && LA7_0 <= STATIC)))
                                {
                                    alt7 = 2;
                                }
                                else
                                {
                                    if (state.backtracking > 0) { state.failed = true; return retval; }
                                    NoViableAltException nvae_d7s0 =
                                        new NoViableAltException("", 7, 0, input);

                                    throw nvae_d7s0;
                                }
                                switch (alt7)
                                {
                                    case 1:
                                        // AS3_ex.g3:1247:249: I2= IDENTIFIER
                                        {
                                            I2 = (IToken)Match(input, IDENTIFIER, FOLLOW_IDENTIFIER_in_xmlNameLiteral3820); if (state.failed) return retval;
                                            if (state.backtracking == 0)
                                            {
                                                I2_tree = (object)adaptor.Create(I2);
                                                adaptor.AddChild(root_0, I2_tree);
                                            }
                                            if (state.backtracking == 0)
                                            {
                                                Emit((CommonToken)I2);
                                            }

                                        }
                                        break;
                                    case 2:
                                        // AS3_ex.g3:1247:291: allKeywords
                                        {
                                            PushFollow(FOLLOW_allKeywords_in_xmlNameLiteral3826);
                                            allKeywords3 = allKeywords();
                                            state.followingStackPointer--;
                                            if (state.failed) return retval;
                                            if (state.backtracking == 0) adaptor.AddChild(root_0, allKeywords3.Tree);

                                        }
                                        break;

                                }


                            }
                            break;

                        default:
                            goto loop8;
                    }
                } while (true);

            loop8:
                ;	// Stops C# compiler whining that label 'loop8' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 6, xmlNameLiteral_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "xmlNameLiteral"

    public class literal_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "literal"
    // AS3_ex.g3:1250:1: literal : (N= NULL | booleanLiteral | numericLiteral | stringLiteral | regularExpresionLiteral );
    public AS3_exParser.literal_return literal() // throws RecognitionException [1]
    {
        AS3_exParser.literal_return retval = new AS3_exParser.literal_return();
        retval.Start = input.LT(1);
        int literal_StartIndex = input.Index();
        object root_0 = null;

        IToken N = null;
        AS3_exParser.booleanLiteral_return booleanLiteral4 = null;

        AS3_exParser.numericLiteral_return numericLiteral5 = null;

        AS3_exParser.stringLiteral_return stringLiteral6 = null;

        AS3_exParser.regularExpresionLiteral_return regularExpresionLiteral7 = null;


        object N_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 7))
            {
                return retval;
            }
            // AS3_ex.g3:1250:36: (N= NULL | booleanLiteral | numericLiteral | stringLiteral | regularExpresionLiteral )
            int alt9 = 5;
            switch (input.LA(1))
            {
                case NULL:
                    {
                        alt9 = 1;
                    }
                    break;
                case FALSE:
                case TRUE:
                    {
                        alt9 = 2;
                    }
                    break;
                case HEX_NUMBER_LITERAL:
                case DEC_NUMBER_LITERAL:
                    {
                        alt9 = 3;
                    }
                    break;
                case SINGLE_QUOTE_LITERAL:
                case DOUBLE_QUOTE_LITERAL:
                    {
                        alt9 = 4;
                    }
                    break;
                case REGULAR_EXPR_LITERAL:
                    {
                        alt9 = 5;
                    }
                    break;
                default:
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    NoViableAltException nvae_d9s0 =
                        new NoViableAltException("", 9, 0, input);

                    throw nvae_d9s0;
            }

            switch (alt9)
            {
                case 1:
                    // AS3_ex.g3:1250:40: N= NULL
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        N = (IToken)Match(input, NULL, FOLLOW_NULL_in_literal3879); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            N_tree = (object)adaptor.Create(N);
                            adaptor.AddChild(root_0, N_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)N);
                        }

                    }
                    break;
                case 2:
                    // AS3_ex.g3:1250:74: booleanLiteral
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_booleanLiteral_in_literal3885);
                        booleanLiteral4 = booleanLiteral();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, booleanLiteral4.Tree);

                    }
                    break;
                case 3:
                    // AS3_ex.g3:1250:91: numericLiteral
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_numericLiteral_in_literal3889);
                        numericLiteral5 = numericLiteral();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, numericLiteral5.Tree);

                    }
                    break;
                case 4:
                    // AS3_ex.g3:1250:108: stringLiteral
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_stringLiteral_in_literal3893);
                        stringLiteral6 = stringLiteral();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, stringLiteral6.Tree);

                    }
                    break;
                case 5:
                    // AS3_ex.g3:1250:124: regularExpresionLiteral
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_regularExpresionLiteral_in_literal3897);
                        regularExpresionLiteral7 = regularExpresionLiteral();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, regularExpresionLiteral7.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 7, literal_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "literal"

    public class xmlMarkup_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "xmlMarkup"
    // AS3_ex.g3:1253:1: xmlMarkup : ( xmlComment | xmlCDATA | xmlPI );
    public AS3_exParser.xmlMarkup_return xmlMarkup() // throws RecognitionException [1]
    {
        AS3_exParser.xmlMarkup_return retval = new AS3_exParser.xmlMarkup_return();
        retval.Start = input.LT(1);
        int xmlMarkup_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.xmlComment_return xmlComment8 = null;

        AS3_exParser.xmlCDATA_return xmlCDATA9 = null;

        AS3_exParser.xmlPI_return xmlPI10 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 8))
            {
                return retval;
            }
            // AS3_ex.g3:1253:36: ( xmlComment | xmlCDATA | xmlPI )
            int alt10 = 3;
            switch (input.LA(1))
            {
                case XML_COMMENT:
                    {
                        alt10 = 1;
                    }
                    break;
                case XML_CDATA:
                    {
                        alt10 = 2;
                    }
                    break;
                case XML_PI:
                    {
                        alt10 = 3;
                    }
                    break;
                default:
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    NoViableAltException nvae_d10s0 =
                        new NoViableAltException("", 10, 0, input);

                    throw nvae_d10s0;
            }

            switch (alt10)
            {
                case 1:
                    // AS3_ex.g3:1253:40: xmlComment
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlComment_in_xmlMarkup3933);
                        xmlComment8 = xmlComment();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, xmlComment8.Tree);

                    }
                    break;
                case 2:
                    // AS3_ex.g3:1253:53: xmlCDATA
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlCDATA_in_xmlMarkup3937);
                        xmlCDATA9 = xmlCDATA();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, xmlCDATA9.Tree);

                    }
                    break;
                case 3:
                    // AS3_ex.g3:1253:64: xmlPI
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlPI_in_xmlMarkup3941);
                        xmlPI10 = xmlPI();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, xmlPI10.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 8, xmlMarkup_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "xmlMarkup"

    public class xmlComment_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "xmlComment"
    // AS3_ex.g3:1254:1: xmlComment : x= XML_COMMENT ;
    public AS3_exParser.xmlComment_return xmlComment() // throws RecognitionException [1]
    {
        AS3_exParser.xmlComment_return retval = new AS3_exParser.xmlComment_return();
        retval.Start = input.LT(1);
        int xmlComment_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;

        object x_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 9))
            {
                return retval;
            }
            // AS3_ex.g3:1254:36: (x= XML_COMMENT )
            // AS3_ex.g3:1254:40: x= XML_COMMENT
            {
                root_0 = (object)adaptor.GetNilNode();

                x = (IToken)Match(input, XML_COMMENT, FOLLOW_XML_COMMENT_in_xmlComment3976); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    x_tree = (object)adaptor.Create(x);
                    adaptor.AddChild(root_0, x_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)x);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 9, xmlComment_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "xmlComment"

    public class xmlCDATA_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "xmlCDATA"
    // AS3_ex.g3:1255:1: xmlCDATA : x= XML_CDATA ;
    public AS3_exParser.xmlCDATA_return xmlCDATA() // throws RecognitionException [1]
    {
        AS3_exParser.xmlCDATA_return retval = new AS3_exParser.xmlCDATA_return();
        retval.Start = input.LT(1);
        int xmlCDATA_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;

        object x_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 10))
            {
                return retval;
            }
            // AS3_ex.g3:1255:36: (x= XML_CDATA )
            // AS3_ex.g3:1255:40: x= XML_CDATA
            {
                root_0 = (object)adaptor.GetNilNode();

                x = (IToken)Match(input, XML_CDATA, FOLLOW_XML_CDATA_in_xmlCDATA4018); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    x_tree = (object)adaptor.Create(x);
                    adaptor.AddChild(root_0, x_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)x);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 10, xmlCDATA_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "xmlCDATA"

    public class xmlPI_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "xmlPI"
    // AS3_ex.g3:1256:1: xmlPI : x= XML_PI ;
    public AS3_exParser.xmlPI_return xmlPI() // throws RecognitionException [1]
    {
        AS3_exParser.xmlPI_return retval = new AS3_exParser.xmlPI_return();
        retval.Start = input.LT(1);
        int xmlPI_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;

        object x_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 11))
            {
                return retval;
            }
            // AS3_ex.g3:1256:36: (x= XML_PI )
            // AS3_ex.g3:1256:40: x= XML_PI
            {
                root_0 = (object)adaptor.GetNilNode();

                x = (IToken)Match(input, XML_PI, FOLLOW_XML_PI_in_xmlPI4061); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    x_tree = (object)adaptor.Create(x);
                    adaptor.AddChild(root_0, x_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)x);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 11, xmlPI_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "xmlPI"

    public class xmlExprEval_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "xmlExprEval"
    // AS3_ex.g3:1257:1: xmlExprEval : L= LCURLY expression R= RCURLY ;
    public AS3_exParser.xmlExprEval_return xmlExprEval() // throws RecognitionException [1]
    {
        AS3_exParser.xmlExprEval_return retval = new AS3_exParser.xmlExprEval_return();
        retval.Start = input.LT(1);
        int xmlExprEval_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        AS3_exParser.expression_return expression11 = null;


        object L_tree = null;
        object R_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 12))
            {
                return retval;
            }
            // AS3_ex.g3:1257:36: (L= LCURLY expression R= RCURLY )
            // AS3_ex.g3:1257:40: L= LCURLY expression R= RCURLY
            {
                root_0 = (object)adaptor.GetNilNode();

                L = (IToken)Match(input, LCURLY, FOLLOW_LCURLY_in_xmlExprEval4099); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)L); PushIndent(true);
                }
                PushFollow(FOLLOW_expression_in_xmlExprEval4103);
                expression11 = expression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, expression11.Tree);
                R = (IToken)Match(input, RCURLY, FOLLOW_RCURLY_in_xmlExprEval4107); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if (state.backtracking == 0)
                {
                    PopIndent(); Emit((CommonToken)R);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 12, xmlExprEval_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "xmlExprEval"

    public class xmlTextElement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "xmlTextElement"
    // AS3_ex.g3:1260:1: xmlTextElement : ( allKeywords | lexToken= ( DEC_NUMBER_LITERAL | HEX_NUMBER_LITERAL | SINGLE_QUOTE_LITERAL | DOUBLE_QUOTE_LITERAL | IDENTIFIER | XML_TEXT | DIV | SEMI | RCURLY | LPAREN | RPAREN | LBRACK | RBRACK | DOT | COMMA | GT | LTE | EQ | NEQ | SAME | NSAME | PLUS | SUB | STAR | MOD | INC | DEC | SHL | AND | OR | XOR | NOT | INV | LAND | LOR | QUE | COLON | ASSIGN | UNDERSCORE | DOLLAR | DIV_ASSIGN | MOD_ASSIGN | ADD_ASSIGN | SUB_ASSIGN | SHL_ASSIGN | AND_ASSIGN | XOR_ASSIGN | OR_ASSIGN | LOR_ASSIGN | LAND_ASSIGN | ELLIPSIS | XML_ELLIPSIS | XML_NS_OP | XML_AT ) );
    public AS3_exParser.xmlTextElement_return xmlTextElement() // throws RecognitionException [1]
    {
        AS3_exParser.xmlTextElement_return retval = new AS3_exParser.xmlTextElement_return();
        retval.Start = input.LT(1);
        int xmlTextElement_StartIndex = input.Index();
        object root_0 = null;

        IToken lexToken = null;
        AS3_exParser.allKeywords_return allKeywords12 = null;


        //object lexToken_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 13))
            {
                return retval;
            }
            // AS3_ex.g3:1261:5: ( allKeywords | lexToken= ( DEC_NUMBER_LITERAL | HEX_NUMBER_LITERAL | SINGLE_QUOTE_LITERAL | DOUBLE_QUOTE_LITERAL | IDENTIFIER | XML_TEXT | DIV | SEMI | RCURLY | LPAREN | RPAREN | LBRACK | RBRACK | DOT | COMMA | GT | LTE | EQ | NEQ | SAME | NSAME | PLUS | SUB | STAR | MOD | INC | DEC | SHL | AND | OR | XOR | NOT | INV | LAND | LOR | QUE | COLON | ASSIGN | UNDERSCORE | DOLLAR | DIV_ASSIGN | MOD_ASSIGN | ADD_ASSIGN | SUB_ASSIGN | SHL_ASSIGN | AND_ASSIGN | XOR_ASSIGN | OR_ASSIGN | LOR_ASSIGN | LAND_ASSIGN | ELLIPSIS | XML_ELLIPSIS | XML_NS_OP | XML_AT ) )
            int alt11 = 2;
            int LA11_0 = input.LA(1);

            if (((LA11_0 >= AS && LA11_0 <= STATIC)))
            {
                alt11 = 1;
            }
            else if ((LA11_0 == SEMI || (LA11_0 >= RCURLY && LA11_0 <= COMMA) || (LA11_0 >= GT && LA11_0 <= LTE) || (LA11_0 >= EQ && LA11_0 <= SHL) || (LA11_0 >= AND && LA11_0 <= SHL_ASSIGN) || (LA11_0 >= LAND_ASSIGN && LA11_0 <= XML_ELLIPSIS) || (LA11_0 >= XML_NS_OP && LA11_0 <= XML_AT) || (LA11_0 >= SINGLE_QUOTE_LITERAL && LA11_0 <= DOUBLE_QUOTE_LITERAL) || LA11_0 == HEX_NUMBER_LITERAL || LA11_0 == DEC_NUMBER_LITERAL || LA11_0 == IDENTIFIER || LA11_0 == XML_TEXT))
            {
                alt11 = 2;
            }
            else
            {
                if (state.backtracking > 0) { state.failed = true; return retval; }
                NoViableAltException nvae_d11s0 =
                    new NoViableAltException("", 11, 0, input);

                throw nvae_d11s0;
            }
            switch (alt11)
            {
                case 1:
                    // AS3_ex.g3:1262:3: allKeywords
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_allKeywords_in_xmlTextElement4125);
                        allKeywords12 = allKeywords();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, allKeywords12.Tree);
                        if (state.backtracking == 0)
                        {
                            /*TODO: see if I can change token type*/
                        }

                    }
                    break;
                case 2:
                    // AS3_ex.g3:1263:7: lexToken= ( DEC_NUMBER_LITERAL | HEX_NUMBER_LITERAL | SINGLE_QUOTE_LITERAL | DOUBLE_QUOTE_LITERAL | IDENTIFIER | XML_TEXT | DIV | SEMI | RCURLY | LPAREN | RPAREN | LBRACK | RBRACK | DOT | COMMA | GT | LTE | EQ | NEQ | SAME | NSAME | PLUS | SUB | STAR | MOD | INC | DEC | SHL | AND | OR | XOR | NOT | INV | LAND | LOR | QUE | COLON | ASSIGN | UNDERSCORE | DOLLAR | DIV_ASSIGN | MOD_ASSIGN | ADD_ASSIGN | SUB_ASSIGN | SHL_ASSIGN | AND_ASSIGN | XOR_ASSIGN | OR_ASSIGN | LOR_ASSIGN | LAND_ASSIGN | ELLIPSIS | XML_ELLIPSIS | XML_NS_OP | XML_AT )
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        lexToken = (IToken)input.LT(1);
                        if (input.LA(1) == SEMI || (input.LA(1) >= RCURLY && input.LA(1) <= COMMA) || (input.LA(1) >= GT && input.LA(1) <= LTE) || (input.LA(1) >= EQ && input.LA(1) <= SHL) || (input.LA(1) >= AND && input.LA(1) <= SHL_ASSIGN) || (input.LA(1) >= LAND_ASSIGN && input.LA(1) <= XML_ELLIPSIS) || (input.LA(1) >= XML_NS_OP && input.LA(1) <= XML_AT) || (input.LA(1) >= SINGLE_QUOTE_LITERAL && input.LA(1) <= DOUBLE_QUOTE_LITERAL) || input.LA(1) == HEX_NUMBER_LITERAL || input.LA(1) == DEC_NUMBER_LITERAL || input.LA(1) == IDENTIFIER || input.LA(1) == XML_TEXT)
                        {
                            input.Consume();
                            if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(lexToken));
                            state.errorRecovery = false; state.failed = false;
                        }
                        else
                        {
                            if (state.backtracking > 0) { state.failed = true; return retval; }
                            MismatchedSetException mse = new MismatchedSetException(null, input);
                            throw mse;
                        }

                        if (state.backtracking == 0)
                        {

                            lexToken.Type = XML_TEXT;
                            Emit((CommonToken)lexToken);

                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 13, xmlTextElement_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "xmlTextElement"

    public class xmlText_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "xmlText"
    // AS3_ex.g3:1334:1: xmlText : (x= XML_TEXT | xmlTextElement )+ ;
    public AS3_exParser.xmlText_return xmlText() // throws RecognitionException [1]
    {
        AS3_exParser.xmlText_return retval = new AS3_exParser.xmlText_return();
        retval.Start = input.LT(1);
        int xmlText_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;
        AS3_exParser.xmlTextElement_return xmlTextElement13 = null;


        object x_tree = null;




        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 14))
            {
                return retval;
            }
            // AS3_ex.g3:1342:5: ( (x= XML_TEXT | xmlTextElement )+ )
            // AS3_ex.g3:1344:2: (x= XML_TEXT | xmlTextElement )+
            {
                root_0 = (object)adaptor.GetNilNode();

                if (state.backtracking == 0)
                {
                    mPrinter.SetE4XTextContent(true);
                }
                // AS3_ex.g3:1345:5: (x= XML_TEXT | xmlTextElement )+
                int cnt12 = 0;
                do
                {
                    int alt12 = 3;
                    switch (input.LA(1))
                    {
                        case XML_TEXT:
                            {
                                int LA12_2 = input.LA(2);

                                if ((synpred70_AS3_ex()))
                                {
                                    alt12 = 1;
                                }
                                else if ((synpred71_AS3_ex()))
                                {
                                    alt12 = 2;
                                }


                            }
                            break;
                        case AS:
                        case BREAK:
                        case CASE:
                        case CATCH:
                        case CLASS:
                        case CONST:
                        case CONTINUE:
                        case DEFAULT:
                        case DELETE:
                        case DO:
                        case ELSE:
                        case EXTENDS:
                        case FALSE:
                        case FINALLY:
                        case FOR:
                        case FUNCTION:
                        case IF:
                        case IMPLEMENTS:
                        case IMPORT:
                        case IN:
                        case INSTANCEOF:
                        case INTERFACE:
                        case INTERNAL:
                        case IS:
                        case NEW:
                        case NULL:
                        case PACKAGE:
                        case PRIVATE:
                        case PROTECTED:
                        case PUBLIC:
                        case RETURN:
                        case SUPER:
                        case SWITCH:
                        case THIS:
                        case THROW:
                        case TRUE:
                        case TRY:
                        case TYPEOF:
                        case USE:
                        case VAR:
                        case VOID:
                        case WHILE:
                        case WITH:
                        case INCLUDE:
                            {
                                int LA12_3 = input.LA(2);

                                if ((synpred71_AS3_ex()))
                                {
                                    alt12 = 2;
                                }


                            }
                            break;
                        case NATIVE:
                        case TO:
                        case EACH:
                        case GET:
                        case SET:
                        case NAMESPACE:
                        case DYNAMIC:
                        case FINAL:
                        case OVERRIDE:
                        case STATIC:
                            {
                                int LA12_4 = input.LA(2);

                                if ((synpred71_AS3_ex()))
                                {
                                    alt12 = 2;
                                }


                            }
                            break;
                        case SEMI:
                        case RCURLY:
                        case LPAREN:
                        case RPAREN:
                        case LBRACK:
                        case RBRACK:
                        case DOT:
                        case COMMA:
                        case GT:
                        case LTE:
                        case EQ:
                        case NEQ:
                        case SAME:
                        case NSAME:
                        case PLUS:
                        case SUB:
                        case STAR:
                        case DIV:
                        case MOD:
                        case INC:
                        case DEC:
                        case SHL:
                        case AND:
                        case OR:
                        case XOR:
                        case NOT:
                        case INV:
                        case LAND:
                        case LOR:
                        case QUE:
                        case COLON:
                        case ASSIGN:
                        case UNDERSCORE:
                        case DOLLAR:
                        case DIV_ASSIGN:
                        case MOD_ASSIGN:
                        case ADD_ASSIGN:
                        case SUB_ASSIGN:
                        case SHL_ASSIGN:
                        case LAND_ASSIGN:
                        case LOR_ASSIGN:
                        case AND_ASSIGN:
                        case XOR_ASSIGN:
                        case OR_ASSIGN:
                        case ELLIPSIS:
                        case XML_ELLIPSIS:
                        case XML_NS_OP:
                        case XML_AT:
                        case SINGLE_QUOTE_LITERAL:
                        case DOUBLE_QUOTE_LITERAL:
                        case HEX_NUMBER_LITERAL:
                        case DEC_NUMBER_LITERAL:
                        case IDENTIFIER:
                            {
                                int LA12_5 = input.LA(2);

                                if ((synpred71_AS3_ex()))
                                {
                                    alt12 = 2;
                                }


                            }
                            break;

                    }

                    switch (alt12)
                    {
                        case 1:
                            // AS3_ex.g3:1345:6: x= XML_TEXT
                            {
                                x = (IToken)Match(input, XML_TEXT, FOLLOW_XML_TEXT_in_xmlText4890); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    x_tree = (object)adaptor.Create(x);
                                    adaptor.AddChild(root_0, x_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    Emit((CommonToken)x);
                                }

                            }
                            break;
                        case 2:
                            // AS3_ex.g3:1345:44: xmlTextElement
                            {
                                PushFollow(FOLLOW_xmlTextElement_in_xmlText4896);
                                xmlTextElement13 = xmlTextElement();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, xmlTextElement13.Tree);

                            }
                            break;

                        default:
                            if (cnt12 >= 1) goto loop12;
                            if (state.backtracking > 0) { state.failed = true; return retval; }
                            EarlyExitException eee =
                                new EarlyExitException(12, input);
                            throw eee;
                    }
                    cnt12++;
                } while (true);

            loop12:
                ;	// Stops C# compiler whinging that label 'loop12' has no statements

                if (state.backtracking == 0)
                {
                    mPrinter.SetE4XTextContent(false);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
            if (state.backtracking == 0)
            {

                // System.out.println("xmlText.text=("+input.ToString((IToken)retval.Start,input.LT(-1))+")");
                // System.out.println("xmlText after start currentIndex = "+input.index()+"size = "+input.size());

            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 14, xmlText_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "xmlText"

    public class xmlPrimaryExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "xmlPrimaryExpression"
    // AS3_ex.g3:1350:1: xmlPrimaryExpression : ( xmlPropertyIdentifier | xmlInitialiser | xmlListInitialiser );
    public AS3_exParser.xmlPrimaryExpression_return xmlPrimaryExpression() // throws RecognitionException [1]
    {
        AS3_exParser.xmlPrimaryExpression_return retval = new AS3_exParser.xmlPrimaryExpression_return();
        retval.Start = input.LT(1);
        int xmlPrimaryExpression_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.xmlPropertyIdentifier_return xmlPropertyIdentifier14 = null;

        AS3_exParser.xmlInitialiser_return xmlInitialiser15 = null;

        AS3_exParser.xmlListInitialiser_return xmlListInitialiser16 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 15))
            {
                return retval;
            }
            // AS3_ex.g3:1351:5: ( xmlPropertyIdentifier | xmlInitialiser | xmlListInitialiser )
            int alt13 = 3;
            switch (input.LA(1))
            {
                case AS:
                case BREAK:
                case CASE:
                case CATCH:
                case CLASS:
                case CONST:
                case CONTINUE:
                case DEFAULT:
                case DELETE:
                case DO:
                case ELSE:
                case EXTENDS:
                case FALSE:
                case FINALLY:
                case FOR:
                case FUNCTION:
                case IF:
                case IMPLEMENTS:
                case IMPORT:
                case IN:
                case INSTANCEOF:
                case INTERFACE:
                case INTERNAL:
                case IS:
                case NATIVE:
                case NEW:
                case NULL:
                case PACKAGE:
                case PRIVATE:
                case PROTECTED:
                case PUBLIC:
                case RETURN:
                case SUPER:
                case SWITCH:
                case THIS:
                case THROW:
                case TO:
                case TRUE:
                case TRY:
                case TYPEOF:
                case USE:
                case VAR:
                case VOID:
                case WHILE:
                case WITH:
                case EACH:
                case GET:
                case SET:
                case NAMESPACE:
                case INCLUDE:
                case DYNAMIC:
                case FINAL:
                case OVERRIDE:
                case STATIC:
                case STAR:
                case XML_AT:
                case IDENTIFIER:
                    {
                        alt13 = 1;
                    }
                    break;
                case LT:
                case XML_COMMENT:
                case XML_CDATA:
                case XML_PI:
                    {
                        alt13 = 2;
                    }
                    break;
                case XML_LS_STD:
                    {
                        alt13 = 3;
                    }
                    break;
                default:
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    NoViableAltException nvae_d13s0 =
                        new NoViableAltException("", 13, 0, input);

                    throw nvae_d13s0;
            }

            switch (alt13)
            {
                case 1:
                    // AS3_ex.g3:1351:9: xmlPropertyIdentifier
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlPropertyIdentifier_in_xmlPrimaryExpression4998);
                        xmlPropertyIdentifier14 = xmlPropertyIdentifier();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, xmlPropertyIdentifier14.Tree);

                    }
                    break;
                case 2:
                    // AS3_ex.g3:1352:9: xmlInitialiser
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlInitialiser_in_xmlPrimaryExpression5008);
                        xmlInitialiser15 = xmlInitialiser();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, xmlInitialiser15.Tree);

                    }
                    break;
                case 3:
                    // AS3_ex.g3:1353:9: xmlListInitialiser
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlListInitialiser_in_xmlPrimaryExpression5018);
                        xmlListInitialiser16 = xmlListInitialiser();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, xmlListInitialiser16.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 15, xmlPrimaryExpression_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "xmlPrimaryExpression"

    public class xmlPropertyIdentifier_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "xmlPropertyIdentifier"
    // AS3_ex.g3:1366:1: xmlPropertyIdentifier : ( xmlAttributeIdentifier | xmlQualifiedIdentifier | s= STAR );
    public AS3_exParser.xmlPropertyIdentifier_return xmlPropertyIdentifier() // throws RecognitionException [1]
    {
        AS3_exParser.xmlPropertyIdentifier_return retval = new AS3_exParser.xmlPropertyIdentifier_return();
        retval.Start = input.LT(1);
        int xmlPropertyIdentifier_StartIndex = input.Index();
        object root_0 = null;

        IToken s = null;
        AS3_exParser.xmlAttributeIdentifier_return xmlAttributeIdentifier17 = null;

        AS3_exParser.xmlQualifiedIdentifier_return xmlQualifiedIdentifier18 = null;


        object s_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 16))
            {
                return retval;
            }
            // AS3_ex.g3:1367:7: ( xmlAttributeIdentifier | xmlQualifiedIdentifier | s= STAR )
            int alt14 = 3;
            alt14 = dfa14.Predict(input);
            switch (alt14)
            {
                case 1:
                    // AS3_ex.g3:1367:11: xmlAttributeIdentifier
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlAttributeIdentifier_in_xmlPropertyIdentifier5111);
                        xmlAttributeIdentifier17 = xmlAttributeIdentifier();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, xmlAttributeIdentifier17.Tree);

                    }
                    break;
                case 2:
                    // AS3_ex.g3:1368:11: xmlQualifiedIdentifier
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlQualifiedIdentifier_in_xmlPropertyIdentifier5123);
                        xmlQualifiedIdentifier18 = xmlQualifiedIdentifier();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, xmlQualifiedIdentifier18.Tree);

                    }
                    break;
                case 3:
                    // AS3_ex.g3:1369:11: s= STAR
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        s = (IToken)Match(input, STAR, FOLLOW_STAR_in_xmlPropertyIdentifier5137); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            s_tree = (object)adaptor.Create(s);
                            adaptor.AddChild(root_0, s_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)s);
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 16, xmlPropertyIdentifier_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "xmlPropertyIdentifier"

    public class xmlAttributeIdentifier_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "xmlAttributeIdentifier"
    // AS3_ex.g3:1372:1: xmlAttributeIdentifier : at= XML_AT ( xmlQualifiedIdentifier | xmlPropertySelector | indexSuffix ) ;
    public AS3_exParser.xmlAttributeIdentifier_return xmlAttributeIdentifier() // throws RecognitionException [1]
    {
        AS3_exParser.xmlAttributeIdentifier_return retval = new AS3_exParser.xmlAttributeIdentifier_return();
        retval.Start = input.LT(1);
        int xmlAttributeIdentifier_StartIndex = input.Index();
        object root_0 = null;

        IToken at = null;
        AS3_exParser.xmlQualifiedIdentifier_return xmlQualifiedIdentifier19 = null;

        AS3_exParser.xmlPropertySelector_return xmlPropertySelector20 = null;

        AS3_exParser.indexSuffix_return indexSuffix21 = null;


        object at_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 17))
            {
                return retval;
            }
            // AS3_ex.g3:1373:5: (at= XML_AT ( xmlQualifiedIdentifier | xmlPropertySelector | indexSuffix ) )
            // AS3_ex.g3:1373:9: at= XML_AT ( xmlQualifiedIdentifier | xmlPropertySelector | indexSuffix )
            {
                root_0 = (object)adaptor.GetNilNode();

                at = (IToken)Match(input, XML_AT, FOLLOW_XML_AT_in_xmlAttributeIdentifier5202); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    at_tree = (object)adaptor.Create(at);
                    adaptor.AddChild(root_0, at_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)at);
                }
                // AS3_ex.g3:1374:9: ( xmlQualifiedIdentifier | xmlPropertySelector | indexSuffix )
                int alt15 = 3;
                switch (input.LA(1))
                {
                    case IDENTIFIER:
                        {
                            int LA15_1 = input.LA(2);

                            if ((synpred76_AS3_ex()))
                            {
                                alt15 = 1;
                            }
                            else if ((synpred77_AS3_ex()))
                            {
                                alt15 = 2;
                            }
                            else
                            {
                                if (state.backtracking > 0) { state.failed = true; return retval; }
                                NoViableAltException nvae_d15s1 =
                                    new NoViableAltException("", 15, 1, input);

                                throw nvae_d15s1;
                            }
                        }
                        break;
                    case AS:
                    case BREAK:
                    case CASE:
                    case CATCH:
                    case CLASS:
                    case CONST:
                    case CONTINUE:
                    case DEFAULT:
                    case DELETE:
                    case DO:
                    case ELSE:
                    case EXTENDS:
                    case FALSE:
                    case FINALLY:
                    case FOR:
                    case FUNCTION:
                    case IF:
                    case IMPLEMENTS:
                    case IMPORT:
                    case IN:
                    case INSTANCEOF:
                    case INTERFACE:
                    case INTERNAL:
                    case IS:
                    case NEW:
                    case NULL:
                    case PACKAGE:
                    case PRIVATE:
                    case PROTECTED:
                    case PUBLIC:
                    case RETURN:
                    case SUPER:
                    case SWITCH:
                    case THIS:
                    case THROW:
                    case TRUE:
                    case TRY:
                    case TYPEOF:
                    case USE:
                    case VAR:
                    case VOID:
                    case WHILE:
                    case WITH:
                    case INCLUDE:
                        {
                            int LA15_2 = input.LA(2);

                            if ((synpred76_AS3_ex()))
                            {
                                alt15 = 1;
                            }
                            else if ((synpred77_AS3_ex()))
                            {
                                alt15 = 2;
                            }
                            else
                            {
                                if (state.backtracking > 0) { state.failed = true; return retval; }
                                NoViableAltException nvae_d15s2 =
                                    new NoViableAltException("", 15, 2, input);

                                throw nvae_d15s2;
                            }
                        }
                        break;
                    case NATIVE:
                    case TO:
                    case EACH:
                    case GET:
                    case SET:
                    case NAMESPACE:
                    case DYNAMIC:
                    case FINAL:
                    case OVERRIDE:
                    case STATIC:
                        {
                            int LA15_3 = input.LA(2);

                            if ((synpred76_AS3_ex()))
                            {
                                alt15 = 1;
                            }
                            else if ((synpred77_AS3_ex()))
                            {
                                alt15 = 2;
                            }
                            else
                            {
                                if (state.backtracking > 0) { state.failed = true; return retval; }
                                NoViableAltException nvae_d15s3 =
                                    new NoViableAltException("", 15, 3, input);

                                throw nvae_d15s3;
                            }
                        }
                        break;
                    case STAR:
                        {
                            int LA15_4 = input.LA(2);

                            if ((synpred76_AS3_ex()))
                            {
                                alt15 = 1;
                            }
                            else if ((synpred77_AS3_ex()))
                            {
                                alt15 = 2;
                            }
                            else
                            {
                                if (state.backtracking > 0) { state.failed = true; return retval; }
                                NoViableAltException nvae_d15s4 =
                                    new NoViableAltException("", 15, 4, input);

                                throw nvae_d15s4;
                            }
                        }
                        break;
                    case LBRACK:
                        {
                            alt15 = 3;
                        }
                        break;
                    default:
                        if (state.backtracking > 0) { state.failed = true; return retval; }
                        NoViableAltException nvae_d15s0 =
                            new NoViableAltException("", 15, 0, input);

                        throw nvae_d15s0;
                }

                switch (alt15)
                {
                    case 1:
                        // AS3_ex.g3:1375:12: xmlQualifiedIdentifier
                        {
                            PushFollow(FOLLOW_xmlQualifiedIdentifier_in_xmlAttributeIdentifier5228);
                            xmlQualifiedIdentifier19 = xmlQualifiedIdentifier();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, xmlQualifiedIdentifier19.Tree);

                        }
                        break;
                    case 2:
                        // AS3_ex.g3:1376:14: xmlPropertySelector
                        {
                            PushFollow(FOLLOW_xmlPropertySelector_in_xmlAttributeIdentifier5243);
                            xmlPropertySelector20 = xmlPropertySelector();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, xmlPropertySelector20.Tree);

                        }
                        break;
                    case 3:
                        // AS3_ex.g3:1377:14: indexSuffix
                        {
                            PushFollow(FOLLOW_indexSuffix_in_xmlAttributeIdentifier5258);
                            indexSuffix21 = indexSuffix();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, indexSuffix21.Tree);

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 17, xmlAttributeIdentifier_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "xmlAttributeIdentifier"

    public class xmlPropertySelector_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "xmlPropertySelector"
    // AS3_ex.g3:1381:1: xmlPropertySelector : ( xmlNameLiteral | s= STAR );
    public AS3_exParser.xmlPropertySelector_return xmlPropertySelector() // throws RecognitionException [1]
    {
        AS3_exParser.xmlPropertySelector_return retval = new AS3_exParser.xmlPropertySelector_return();
        retval.Start = input.LT(1);
        int xmlPropertySelector_StartIndex = input.Index();
        object root_0 = null;

        IToken s = null;
        AS3_exParser.xmlNameLiteral_return xmlNameLiteral22 = null;


        object s_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 18))
            {
                return retval;
            }
            // AS3_ex.g3:1382:5: ( xmlNameLiteral | s= STAR )
            int alt16 = 2;
            int LA16_0 = input.LA(1);

            if (((LA16_0 >= AS && LA16_0 <= STATIC) || LA16_0 == IDENTIFIER))
            {
                alt16 = 1;
            }
            else if ((LA16_0 == STAR))
            {
                alt16 = 2;
            }
            else
            {
                if (state.backtracking > 0) { state.failed = true; return retval; }
                NoViableAltException nvae_d16s0 =
                    new NoViableAltException("", 16, 0, input);

                throw nvae_d16s0;
            }
            switch (alt16)
            {
                case 1:
                    // AS3_ex.g3:1382:9: xmlNameLiteral
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlNameLiteral_in_xmlPropertySelector5348);
                        xmlNameLiteral22 = xmlNameLiteral();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, xmlNameLiteral22.Tree);

                    }
                    break;
                case 2:
                    // AS3_ex.g3:1383:9: s= STAR
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        s = (IToken)Match(input, STAR, FOLLOW_STAR_in_xmlPropertySelector5361); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            s_tree = (object)adaptor.Create(s);
                            adaptor.AddChild(root_0, s_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)s);
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 18, xmlPropertySelector_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "xmlPropertySelector"

    public class xmlQualifiedIdentifier_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "xmlQualifiedIdentifier"
    // AS3_ex.g3:1386:1: xmlQualifiedIdentifier : xmlPropertySelector x= XML_NS_OP ( xmlPropertySelector | indexSuffix ) ;
    public AS3_exParser.xmlQualifiedIdentifier_return xmlQualifiedIdentifier() // throws RecognitionException [1]
    {
        AS3_exParser.xmlQualifiedIdentifier_return retval = new AS3_exParser.xmlQualifiedIdentifier_return();
        retval.Start = input.LT(1);
        int xmlQualifiedIdentifier_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;
        AS3_exParser.xmlPropertySelector_return xmlPropertySelector23 = null;

        AS3_exParser.xmlPropertySelector_return xmlPropertySelector24 = null;

        AS3_exParser.indexSuffix_return indexSuffix25 = null;


        object x_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 19))
            {
                return retval;
            }
            // AS3_ex.g3:1387:5: ( xmlPropertySelector x= XML_NS_OP ( xmlPropertySelector | indexSuffix ) )
            // AS3_ex.g3:1387:9: xmlPropertySelector x= XML_NS_OP ( xmlPropertySelector | indexSuffix )
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_xmlPropertySelector_in_xmlQualifiedIdentifier5382);
                xmlPropertySelector23 = xmlPropertySelector();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, xmlPropertySelector23.Tree);
                x = (IToken)Match(input, XML_NS_OP, FOLLOW_XML_NS_OP_in_xmlQualifiedIdentifier5387); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    x_tree = (object)adaptor.Create(x);
                    adaptor.AddChild(root_0, x_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)x);
                }
                // AS3_ex.g3:1388:5: ( xmlPropertySelector | indexSuffix )
                int alt17 = 2;
                int LA17_0 = input.LA(1);

                if (((LA17_0 >= AS && LA17_0 <= STATIC) || LA17_0 == STAR || LA17_0 == IDENTIFIER))
                {
                    alt17 = 1;
                }
                else if ((LA17_0 == LBRACK))
                {
                    alt17 = 2;
                }
                else
                {
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    NoViableAltException nvae_d17s0 =
                        new NoViableAltException("", 17, 0, input);

                    throw nvae_d17s0;
                }
                switch (alt17)
                {
                    case 1:
                        // AS3_ex.g3:1389:9: xmlPropertySelector
                        {
                            PushFollow(FOLLOW_xmlPropertySelector_in_xmlQualifiedIdentifier5422);
                            xmlPropertySelector24 = xmlPropertySelector();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, xmlPropertySelector24.Tree);

                        }
                        break;
                    case 2:
                        // AS3_ex.g3:1390:11: indexSuffix
                        {
                            PushFollow(FOLLOW_indexSuffix_in_xmlQualifiedIdentifier5434);
                            indexSuffix25 = indexSuffix();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, indexSuffix25.Tree);

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 19, xmlQualifiedIdentifier_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "xmlQualifiedIdentifier"

    public class xmlInitialiser_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "xmlInitialiser"
    // AS3_ex.g3:1394:1: xmlInitialiser : ( xmlMarkup | xmlElement );
    public AS3_exParser.xmlInitialiser_return xmlInitialiser() // throws RecognitionException [1]
    {
        AS3_exParser.xmlInitialiser_return retval = new AS3_exParser.xmlInitialiser_return();
        retval.Start = input.LT(1);
        int xmlInitialiser_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.xmlMarkup_return xmlMarkup26 = null;

        AS3_exParser.xmlElement_return xmlElement27 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 20))
            {
                return retval;
            }
            // AS3_ex.g3:1395:5: ( xmlMarkup | xmlElement )
            int alt18 = 2;
            int LA18_0 = input.LA(1);

            if (((LA18_0 >= XML_COMMENT && LA18_0 <= XML_PI)))
            {
                alt18 = 1;
            }
            else if ((LA18_0 == LT))
            {
                alt18 = 2;
            }
            else
            {
                if (state.backtracking > 0) { state.failed = true; return retval; }
                NoViableAltException nvae_d18s0 =
                    new NoViableAltException("", 18, 0, input);

                throw nvae_d18s0;
            }
            switch (alt18)
            {
                case 1:
                    // AS3_ex.g3:1395:9: xmlMarkup
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlMarkup_in_xmlInitialiser5459);
                        xmlMarkup26 = xmlMarkup();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, xmlMarkup26.Tree);

                    }
                    break;
                case 2:
                    // AS3_ex.g3:1396:9: xmlElement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlElement_in_xmlInitialiser5469);
                        xmlElement27 = xmlElement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, xmlElement27.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 20, xmlInitialiser_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "xmlInitialiser"

    public class xmlElement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "xmlElement"
    // AS3_ex.g3:1399:1: xmlElement : L= LT xmlTagName ( xmlAttributes )? (x= XML_TEND | G= GT ( xmlElementContent )? x= XML_E_TEND xmlTagName G= GT ) ;
    public AS3_exParser.xmlElement_return xmlElement() // throws RecognitionException [1]
    {
        AS3_exParser.xmlElement_return retval = new AS3_exParser.xmlElement_return();
        retval.Start = input.LT(1);
        int xmlElement_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken x = null;
        IToken G = null;
        AS3_exParser.xmlTagName_return xmlTagName28 = null;

        AS3_exParser.xmlAttributes_return xmlAttributes29 = null;

        AS3_exParser.xmlElementContent_return xmlElementContent30 = null;

        AS3_exParser.xmlTagName_return xmlTagName31 = null;


        object L_tree = null;
        object x_tree = null;
        object G_tree = null;


        WrapOptions options = mPrinter.GetXMLWrapOptions();
        bool pushedFormat = false;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 21))
            {
                return retval;
            }
            // AS3_ex.g3:1405:5: (L= LT xmlTagName ( xmlAttributes )? (x= XML_TEND | G= GT ( xmlElementContent )? x= XML_E_TEND xmlTagName G= GT ) )
            // AS3_ex.g3:1406:5: L= LT xmlTagName ( xmlAttributes )? (x= XML_TEND | G= GT ( xmlElementContent )? x= XML_E_TEND xmlTagName G= GT )
            {
                root_0 = (object)adaptor.GetNilNode();

                if (state.backtracking == 0)
                {
                    pushedFormat = PushFormatType(options, false);
                }
                if (state.backtracking == 0)
                {
                    EmitCRForTag(options);
                }
                L = (IToken)Match(input, LT, FOLLOW_LT_in_xmlElement5513); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)L);
                }
                if (state.backtracking == 0)
                {
                    PushIndent(true);
                }
                PushFollow(FOLLOW_xmlTagName_in_xmlElement5518);
                xmlTagName28 = xmlTagName();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, xmlTagName28.Tree);
                // AS3_ex.g3:1408:65: ( xmlAttributes )?
                int alt19 = 2;
                int LA19_0 = input.LA(1);

                if (((LA19_0 >= AS && LA19_0 <= STATIC) || LA19_0 == IDENTIFIER))
                {
                    alt19 = 1;
                }
                switch (alt19)
                {
                    case 1:
                        // AS3_ex.g3:0:0: xmlAttributes
                        {
                            PushFollow(FOLLOW_xmlAttributes_in_xmlElement5520);
                            xmlAttributes29 = xmlAttributes();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, xmlAttributes29.Tree);

                        }
                        break;

                }

                // AS3_ex.g3:1409:5: (x= XML_TEND | G= GT ( xmlElementContent )? x= XML_E_TEND xmlTagName G= GT )
                int alt21 = 2;
                int LA21_0 = input.LA(1);

                if ((LA21_0 == XML_TEND))
                {
                    alt21 = 1;
                }
                else if ((LA21_0 == GT))
                {
                    alt21 = 2;
                }
                else
                {
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    NoViableAltException nvae_d21s0 =
                        new NoViableAltException("", 21, 0, input);

                    throw nvae_d21s0;
                }
                switch (alt21)
                {
                    case 1:
                        // AS3_ex.g3:1410:9: x= XML_TEND
                        {
                            x = (IToken)Match(input, XML_TEND, FOLLOW_XML_TEND_in_xmlElement5540); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                x_tree = (object)adaptor.Create(x);
                                adaptor.AddChild(root_0, x_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)x);
                            }
                            if (state.backtracking == 0)
                            {
                                EmitCRForTag(options);
                            }
                            if (state.backtracking == 0)
                            {
                                PopIndent();
                            }

                        }
                        break;
                    case 2:
                        // AS3_ex.g3:1414:9: G= GT ( xmlElementContent )? x= XML_E_TEND xmlTagName G= GT
                        {
                            G = (IToken)Match(input, GT, FOLLOW_GT_in_xmlElement5585); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                G_tree = (object)adaptor.Create(G);
                                adaptor.AddChild(root_0, G_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)G);
                            }
                            if (state.backtracking == 0)
                            {
                                EmitCRForTag(options);
                            }
                            // AS3_ex.g3:1414:62: ( xmlElementContent )?
                            int alt20 = 2;
                            int LA20_0 = input.LA(1);

                            if (((LA20_0 >= AS && LA20_0 <= LTE) || (LA20_0 >= EQ && LA20_0 <= SHL) || (LA20_0 >= AND && LA20_0 <= SHL_ASSIGN) || (LA20_0 >= LAND_ASSIGN && LA20_0 <= XML_ELLIPSIS) || (LA20_0 >= XML_NS_OP && LA20_0 <= XML_AT) || (LA20_0 >= SINGLE_QUOTE_LITERAL && LA20_0 <= DOUBLE_QUOTE_LITERAL) || LA20_0 == HEX_NUMBER_LITERAL || LA20_0 == DEC_NUMBER_LITERAL || LA20_0 == IDENTIFIER || (LA20_0 >= XML_COMMENT && LA20_0 <= XML_TEXT)))
                            {
                                alt20 = 1;
                            }
                            switch (alt20)
                            {
                                case 1:
                                    // AS3_ex.g3:0:0: xmlElementContent
                                    {
                                        PushFollow(FOLLOW_xmlElementContent_in_xmlElement5589);
                                        xmlElementContent30 = xmlElementContent();
                                        state.followingStackPointer--;
                                        if (state.failed) return retval;
                                        if (state.backtracking == 0) adaptor.AddChild(root_0, xmlElementContent30.Tree);

                                    }
                                    break;

                            }

                            x = (IToken)Match(input, XML_E_TEND, FOLLOW_XML_E_TEND_in_xmlElement5603); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                x_tree = (object)adaptor.Create(x);
                                adaptor.AddChild(root_0, x_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                PopIndent();
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)x);
                            }
                            PushFollow(FOLLOW_xmlTagName_in_xmlElement5617);
                            xmlTagName31 = xmlTagName();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, xmlTagName31.Tree);
                            G = (IToken)Match(input, GT, FOLLOW_GT_in_xmlElement5621); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                G_tree = (object)adaptor.Create(G);
                                adaptor.AddChild(root_0, G_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)G);
                            }
                            if (state.backtracking == 0)
                            {
                                EmitCRForTag(options);
                            }

                        }
                        break;

                }

                if (state.backtracking == 0)
                {

                    if (pushedFormat)
                        mPrinter.PopFormatMode();

                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 21, xmlElement_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "xmlElement"

    public class xmlAttributes_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "xmlAttributes"
    // AS3_ex.g3:1424:1: xmlAttributes : ( xmlAttribute )+ ;
    public AS3_exParser.xmlAttributes_return xmlAttributes() // throws RecognitionException [1]
    {
        AS3_exParser.xmlAttributes_return retval = new AS3_exParser.xmlAttributes_return();
        retval.Start = input.LT(1);
        int xmlAttributes_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.xmlAttribute_return xmlAttribute32 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 22))
            {
                return retval;
            }
            // AS3_ex.g3:1425:5: ( ( xmlAttribute )+ )
            // AS3_ex.g3:1425:9: ( xmlAttribute )+
            {
                root_0 = (object)adaptor.GetNilNode();

                // AS3_ex.g3:1425:9: ( xmlAttribute )+
                int cnt22 = 0;
                do
                {
                    int alt22 = 2;
                    int LA22_0 = input.LA(1);

                    if (((LA22_0 >= AS && LA22_0 <= STATIC) || LA22_0 == IDENTIFIER))
                    {
                        alt22 = 1;
                    }


                    switch (alt22)
                    {
                        case 1:
                            // AS3_ex.g3:0:0: xmlAttribute
                            {
                                PushFollow(FOLLOW_xmlAttribute_in_xmlAttributes5660);
                                xmlAttribute32 = xmlAttribute();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, xmlAttribute32.Tree);

                            }
                            break;

                        default:
                            if (cnt22 >= 1) goto loop22;
                            if (state.backtracking > 0) { state.failed = true; return retval; }
                            EarlyExitException eee =
                                new EarlyExitException(22, input);
                            throw eee;
                    }
                    cnt22++;
                } while (true);

            loop22:
                ;	// Stops C# compiler whinging that label 'loop22' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 22, xmlAttributes_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "xmlAttributes"

    public class xmlTagName_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "xmlTagName"
    // AS3_ex.g3:1428:1: xmlTagName : ( xmlExprEval | xmlNameLiteral );
    public AS3_exParser.xmlTagName_return xmlTagName() // throws RecognitionException [1]
    {
        AS3_exParser.xmlTagName_return retval = new AS3_exParser.xmlTagName_return();
        retval.Start = input.LT(1);
        int xmlTagName_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.xmlExprEval_return xmlExprEval33 = null;

        AS3_exParser.xmlNameLiteral_return xmlNameLiteral34 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 23))
            {
                return retval;
            }
            // AS3_ex.g3:1429:5: ( xmlExprEval | xmlNameLiteral )
            int alt23 = 2;
            int LA23_0 = input.LA(1);

            if ((LA23_0 == LCURLY))
            {
                alt23 = 1;
            }
            else if (((LA23_0 >= AS && LA23_0 <= STATIC) || LA23_0 == IDENTIFIER))
            {
                alt23 = 2;
            }
            else
            {
                if (state.backtracking > 0) { state.failed = true; return retval; }
                NoViableAltException nvae_d23s0 =
                    new NoViableAltException("", 23, 0, input);

                throw nvae_d23s0;
            }
            switch (alt23)
            {
                case 1:
                    // AS3_ex.g3:1429:9: xmlExprEval
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlExprEval_in_xmlTagName5690);
                        xmlExprEval33 = xmlExprEval();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, xmlExprEval33.Tree);

                    }
                    break;
                case 2:
                    // AS3_ex.g3:1430:4: xmlNameLiteral
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlNameLiteral_in_xmlTagName5695);
                        xmlNameLiteral34 = xmlNameLiteral();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, xmlNameLiteral34.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 23, xmlTagName_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "xmlTagName"

    public class xmlAttribute_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "xmlAttribute"
    // AS3_ex.g3:1433:1: xmlAttribute : {...}? xmlNameLiteral A= ASSIGN ( xmlExprEval | stringLiteral ) ;
    public AS3_exParser.xmlAttribute_return xmlAttribute() // throws RecognitionException [1]
    {
        AS3_exParser.xmlAttribute_return retval = new AS3_exParser.xmlAttribute_return();
        retval.Start = input.LT(1);
        int xmlAttribute_StartIndex = input.Index();
        object root_0 = null;

        IToken A = null;
        AS3_exParser.xmlNameLiteral_return xmlNameLiteral35 = null;

        AS3_exParser.xmlExprEval_return xmlExprEval36 = null;

        AS3_exParser.stringLiteral_return stringLiteral37 = null;


        object A_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 24))
            {
                return retval;
            }
            // AS3_ex.g3:1434:5: ({...}? xmlNameLiteral A= ASSIGN ( xmlExprEval | stringLiteral ) )
            // AS3_ex.g3:1434:8: {...}? xmlNameLiteral A= ASSIGN ( xmlExprEval | stringLiteral )
            {
                root_0 = (object)adaptor.GetNilNode();

                if (!((PromoteWhitespace())))
                {
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    throw new FailedPredicateException(input, "xmlAttribute", "PromoteWhitespace()");
                }
                if (state.backtracking == 0)
                {
                    InsertWS(1);
                }
                PushFollow(FOLLOW_xmlNameLiteral_in_xmlAttribute5718);
                xmlNameLiteral35 = xmlNameLiteral();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, xmlNameLiteral35.Tree);
                A = (IToken)Match(input, ASSIGN, FOLLOW_ASSIGN_in_xmlAttribute5722); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    A_tree = (object)adaptor.Create(A);
                    adaptor.AddChild(root_0, A_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)A);
                }
                // AS3_ex.g3:1435:5: ( xmlExprEval | stringLiteral )
                int alt24 = 2;
                int LA24_0 = input.LA(1);

                if ((LA24_0 == LCURLY))
                {
                    alt24 = 1;
                }
                else if (((LA24_0 >= SINGLE_QUOTE_LITERAL && LA24_0 <= DOUBLE_QUOTE_LITERAL)))
                {
                    alt24 = 2;
                }
                else
                {
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    NoViableAltException nvae_d24s0 =
                        new NoViableAltException("", 24, 0, input);

                    throw nvae_d24s0;
                }
                switch (alt24)
                {
                    case 1:
                        // AS3_ex.g3:1436:9: xmlExprEval
                        {
                            PushFollow(FOLLOW_xmlExprEval_in_xmlAttribute5741);
                            xmlExprEval36 = xmlExprEval();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, xmlExprEval36.Tree);

                        }
                        break;
                    case 2:
                        // AS3_ex.g3:1437:11: stringLiteral
                        {
                            PushFollow(FOLLOW_stringLiteral_in_xmlAttribute5753);
                            stringLiteral37 = stringLiteral();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, stringLiteral37.Tree);

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 24, xmlAttribute_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "xmlAttribute"

    public class xmlElementContent_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "xmlElementContent"
    // AS3_ex.g3:1441:1: xmlElementContent : ( xmlElementContentHelper )+ ;
    public AS3_exParser.xmlElementContent_return xmlElementContent() // throws RecognitionException [1]
    {
        AS3_exParser.xmlElementContent_return retval = new AS3_exParser.xmlElementContent_return();
        retval.Start = input.LT(1);
        int xmlElementContent_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.xmlElementContentHelper_return xmlElementContentHelper38 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 25))
            {
                return retval;
            }
            // AS3_ex.g3:1442:5: ( ( xmlElementContentHelper )+ )
            // AS3_ex.g3:1442:8: ( xmlElementContentHelper )+
            {
                root_0 = (object)adaptor.GetNilNode();

                // AS3_ex.g3:1442:8: ( xmlElementContentHelper )+
                int cnt25 = 0;
                do
                {
                    int alt25 = 2;
                    int LA25_0 = input.LA(1);

                    if (((LA25_0 >= AS && LA25_0 <= LTE) || (LA25_0 >= EQ && LA25_0 <= SHL) || (LA25_0 >= AND && LA25_0 <= SHL_ASSIGN) || (LA25_0 >= LAND_ASSIGN && LA25_0 <= XML_ELLIPSIS) || (LA25_0 >= XML_NS_OP && LA25_0 <= XML_AT) || (LA25_0 >= SINGLE_QUOTE_LITERAL && LA25_0 <= DOUBLE_QUOTE_LITERAL) || LA25_0 == HEX_NUMBER_LITERAL || LA25_0 == DEC_NUMBER_LITERAL || LA25_0 == IDENTIFIER || (LA25_0 >= XML_COMMENT && LA25_0 <= XML_TEXT)))
                    {
                        alt25 = 1;
                    }


                    switch (alt25)
                    {
                        case 1:
                            // AS3_ex.g3:0:0: xmlElementContentHelper
                            {
                                PushFollow(FOLLOW_xmlElementContentHelper_in_xmlElementContent5784);
                                xmlElementContentHelper38 = xmlElementContentHelper();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, xmlElementContentHelper38.Tree);

                            }
                            break;

                        default:
                            if (cnt25 >= 1) goto loop25;
                            if (state.backtracking > 0) { state.failed = true; return retval; }
                            EarlyExitException eee =
                                new EarlyExitException(25, input);
                            throw eee;
                    }
                    cnt25++;
                } while (true);

            loop25:
                ;	// Stops C# compiler whinging that label 'loop25' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 25, xmlElementContent_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "xmlElementContent"

    public class xmlElementContentHelper_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "xmlElementContentHelper"
    // AS3_ex.g3:1445:1: xmlElementContentHelper : ( xmlExprEval | xmlMarkup | xmlElement | xmlText );
    public AS3_exParser.xmlElementContentHelper_return xmlElementContentHelper() // throws RecognitionException [1]
    {
        AS3_exParser.xmlElementContentHelper_return retval = new AS3_exParser.xmlElementContentHelper_return();
        retval.Start = input.LT(1);
        int xmlElementContentHelper_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.xmlExprEval_return xmlExprEval39 = null;

        AS3_exParser.xmlMarkup_return xmlMarkup40 = null;

        AS3_exParser.xmlElement_return xmlElement41 = null;

        AS3_exParser.xmlText_return xmlText42 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 26))
            {
                return retval;
            }
            // AS3_ex.g3:1446:5: ( xmlExprEval | xmlMarkup | xmlElement | xmlText )
            int alt26 = 4;
            switch (input.LA(1))
            {
                case LCURLY:
                    {
                        alt26 = 1;
                    }
                    break;
                case XML_COMMENT:
                case XML_CDATA:
                case XML_PI:
                    {
                        alt26 = 2;
                    }
                    break;
                case LT:
                    {
                        alt26 = 3;
                    }
                    break;
                case AS:
                case BREAK:
                case CASE:
                case CATCH:
                case CLASS:
                case CONST:
                case CONTINUE:
                case DEFAULT:
                case DELETE:
                case DO:
                case ELSE:
                case EXTENDS:
                case FALSE:
                case FINALLY:
                case FOR:
                case FUNCTION:
                case IF:
                case IMPLEMENTS:
                case IMPORT:
                case IN:
                case INSTANCEOF:
                case INTERFACE:
                case INTERNAL:
                case IS:
                case NATIVE:
                case NEW:
                case NULL:
                case PACKAGE:
                case PRIVATE:
                case PROTECTED:
                case PUBLIC:
                case RETURN:
                case SUPER:
                case SWITCH:
                case THIS:
                case THROW:
                case TO:
                case TRUE:
                case TRY:
                case TYPEOF:
                case USE:
                case VAR:
                case VOID:
                case WHILE:
                case WITH:
                case EACH:
                case GET:
                case SET:
                case NAMESPACE:
                case INCLUDE:
                case DYNAMIC:
                case FINAL:
                case OVERRIDE:
                case STATIC:
                case SEMI:
                case RCURLY:
                case LPAREN:
                case RPAREN:
                case LBRACK:
                case RBRACK:
                case DOT:
                case COMMA:
                case GT:
                case LTE:
                case EQ:
                case NEQ:
                case SAME:
                case NSAME:
                case PLUS:
                case SUB:
                case STAR:
                case DIV:
                case MOD:
                case INC:
                case DEC:
                case SHL:
                case AND:
                case OR:
                case XOR:
                case NOT:
                case INV:
                case LAND:
                case LOR:
                case QUE:
                case COLON:
                case ASSIGN:
                case UNDERSCORE:
                case DOLLAR:
                case DIV_ASSIGN:
                case MOD_ASSIGN:
                case ADD_ASSIGN:
                case SUB_ASSIGN:
                case SHL_ASSIGN:
                case LAND_ASSIGN:
                case LOR_ASSIGN:
                case AND_ASSIGN:
                case XOR_ASSIGN:
                case OR_ASSIGN:
                case ELLIPSIS:
                case XML_ELLIPSIS:
                case XML_NS_OP:
                case XML_AT:
                case SINGLE_QUOTE_LITERAL:
                case DOUBLE_QUOTE_LITERAL:
                case HEX_NUMBER_LITERAL:
                case DEC_NUMBER_LITERAL:
                case IDENTIFIER:
                case XML_TEXT:
                    {
                        alt26 = 4;
                    }
                    break;
                default:
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    NoViableAltException nvae_d26s0 =
                        new NoViableAltException("", 26, 0, input);

                    throw nvae_d26s0;
            }

            switch (alt26)
            {
                case 1:
                    // AS3_ex.g3:1446:7: xmlExprEval
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlExprEval_in_xmlElementContentHelper5802);
                        xmlExprEval39 = xmlExprEval();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, xmlExprEval39.Tree);

                    }
                    break;
                case 2:
                    // AS3_ex.g3:1447:7: xmlMarkup
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlMarkup_in_xmlElementContentHelper5811);
                        xmlMarkup40 = xmlMarkup();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, xmlMarkup40.Tree);

                    }
                    break;
                case 3:
                    // AS3_ex.g3:1448:7: xmlElement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlElement_in_xmlElementContentHelper5820);
                        xmlElement41 = xmlElement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, xmlElement41.Tree);

                    }
                    break;
                case 4:
                    // AS3_ex.g3:1449:7: xmlText
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if (state.backtracking == 0)
                        {
                            mPrinter.PushFormatMode(ASPrettyPrinter.FORMAT_INDENT);
                        }
                        PushFollow(FOLLOW_xmlText_in_xmlElementContentHelper5830);
                        xmlText42 = xmlText();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, xmlText42.Tree);
                        if (state.backtracking == 0)
                        {
                            mPrinter.PopFormatMode();
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 26, xmlElementContentHelper_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "xmlElementContentHelper"

    public class xmlListInitialiser_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "xmlListInitialiser"
    // AS3_ex.g3:1452:1: xmlListInitialiser : x= XML_LS_STD ( xmlElementContent )? x= XML_LS_END ;
    public AS3_exParser.xmlListInitialiser_return xmlListInitialiser() // throws RecognitionException [1]
    {
        AS3_exParser.xmlListInitialiser_return retval = new AS3_exParser.xmlListInitialiser_return();
        retval.Start = input.LT(1);
        int xmlListInitialiser_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;
        AS3_exParser.xmlElementContent_return xmlElementContent43 = null;


        object x_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 27))
            {
                return retval;
            }
            // AS3_ex.g3:1453:5: (x= XML_LS_STD ( xmlElementContent )? x= XML_LS_END )
            // AS3_ex.g3:1453:9: x= XML_LS_STD ( xmlElementContent )? x= XML_LS_END
            {
                root_0 = (object)adaptor.GetNilNode();

                if (state.backtracking == 0)
                {
                    InsertCR(false);
                }
                x = (IToken)Match(input, XML_LS_STD, FOLLOW_XML_LS_STD_in_xmlListInitialiser5851); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    x_tree = (object)adaptor.Create(x);
                    adaptor.AddChild(root_0, x_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)x);
                }
                if (state.backtracking == 0)
                {
                    InsertCR(false);
                }
                if (state.backtracking == 0)
                {
                    PushIndent(true);
                }
                // AS3_ex.g3:1455:5: ( xmlElementContent )?
                int alt27 = 2;
                int LA27_0 = input.LA(1);

                if (((LA27_0 >= AS && LA27_0 <= LTE) || (LA27_0 >= EQ && LA27_0 <= SHL) || (LA27_0 >= AND && LA27_0 <= SHL_ASSIGN) || (LA27_0 >= LAND_ASSIGN && LA27_0 <= XML_ELLIPSIS) || (LA27_0 >= XML_NS_OP && LA27_0 <= XML_AT) || (LA27_0 >= SINGLE_QUOTE_LITERAL && LA27_0 <= DOUBLE_QUOTE_LITERAL) || LA27_0 == HEX_NUMBER_LITERAL || LA27_0 == DEC_NUMBER_LITERAL || LA27_0 == IDENTIFIER || (LA27_0 >= XML_COMMENT && LA27_0 <= XML_TEXT)))
                {
                    alt27 = 1;
                }
                switch (alt27)
                {
                    case 1:
                        // AS3_ex.g3:0:0: xmlElementContent
                        {
                            PushFollow(FOLLOW_xmlElementContent_in_xmlListInitialiser5866);
                            xmlElementContent43 = xmlElementContent();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, xmlElementContent43.Tree);

                        }
                        break;

                }

                if (state.backtracking == 0)
                {
                    InsertCR(false);
                }
                x = (IToken)Match(input, XML_LS_END, FOLLOW_XML_LS_END_in_xmlListInitialiser5878); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    x_tree = (object)adaptor.Create(x);
                    adaptor.AddChild(root_0, x_tree);
                }
                if (state.backtracking == 0)
                {
                    PopIndent();
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)x);
                }
                if (state.backtracking == 0)
                {
                    InsertCR(false);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 27, xmlListInitialiser_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "xmlListInitialiser"

    public class semic_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "semic"
    // AS3_ex.g3:1460:1: semic : (S= SEMI | E= EOF | R= RCURLY );
    public AS3_exParser.semic_return semic() // throws RecognitionException [1]
    {
        AS3_exParser.semic_return retval = new AS3_exParser.semic_return();
        retval.Start = input.LT(1);
        int semic_StartIndex = input.Index();
        object root_0 = null;

        IToken S = null;
        IToken E = null;
        IToken R = null;

        object S_tree = null;
        object E_tree = null;
        object R_tree = null;


        // Mark current position so we can unconsume a RBRACE.
        int marker = input.Mark();
        // Promote EOL if appropriate
        bool onBrace = false;
        if (((CommonToken)retval.Start).Text != null && ((CommonToken)retval.Start).Text.Equals("}"))
        {
            onBrace = true;
            if (state.backtracking > 0)
            {
                retval.Stop = retval.Start;
                return retval; //we don't want to consume the '}' during the prediction phase
            }
        }

        if (FindVirtualHiddenToken(retval))
        {
            retval.Stop = retval.Start;
            return retval;
        }

        //   promoteEOL(retval);

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 28))
            {
                return retval;
            }
            // AS3_ex.g3:1485:5: (S= SEMI | E= EOF | R= RCURLY )
            int alt28 = 3;
            switch (input.LA(1))
            {
                case SEMI:
                    {
                        alt28 = 1;
                    }
                    break;
                case EOF:
                    {
                        alt28 = 2;
                    }
                    break;
                case RCURLY:
                    {
                        alt28 = 3;
                    }
                    break;
                default:
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    NoViableAltException nvae_d28s0 =
                        new NoViableAltException("", 28, 0, input);

                    throw nvae_d28s0;
            }

            switch (alt28)
            {
                case 1:
                    // AS3_ex.g3:1485:9: S= SEMI
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        S = (IToken)Match(input, SEMI, FOLLOW_SEMI_in_semic5909); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            S_tree = (object)adaptor.Create(S);
                            adaptor.AddChild(root_0, S_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)S);
                        }

                    }
                    break;
                case 2:
                    // AS3_ex.g3:1486:9: E= EOF
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        E = (IToken)Match(input, EOF, FOLLOW_EOF_in_semic5923); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            E_tree = (object)adaptor.Create(E);
                            adaptor.AddChild(root_0, E_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)E);
                        }

                    }
                    break;
                case 3:
                    // AS3_ex.g3:1487:9: R= RCURLY
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        R = (IToken)Match(input, RCURLY, FOLLOW_RCURLY_in_semic5937); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            R_tree = (object)adaptor.Create(R);
                            adaptor.AddChild(root_0, R_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            input.Rewind(marker);
                            if (onBrace)
                                retval.Start = input.LT(-1);

                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 28, semic_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "semic"

    public class fileContents_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "fileContents"
    // AS3_ex.g3:1496:1: fileContents : ( ( ( packageDeclaration )? ( packageElement )* ) | EOF );
    public AS3_exParser.fileContents_return fileContents() // throws RecognitionException [1]
    {
        AS3_exParser.fileContents_return retval = new AS3_exParser.fileContents_return();
        retval.Start = input.LT(1);
        int fileContents_StartIndex = input.Index();
        object root_0 = null;

        IToken EOF46 = null;
        AS3_exParser.packageDeclaration_return packageDeclaration44 = null;

        AS3_exParser.packageElement_return packageElement45 = null;


        object EOF46_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 29))
            {
                return retval;
            }
            // AS3_ex.g3:1497:2: ( ( ( packageDeclaration )? ( packageElement )* ) | EOF )
            int alt31 = 2;
            int LA31_0 = input.LA(1);

            if (((LA31_0 >= AS && LA31_0 <= LCURLY) || LA31_0 == LPAREN || LA31_0 == LBRACK || LA31_0 == LT || (LA31_0 >= PLUS && LA31_0 <= STAR) || (LA31_0 >= INC && LA31_0 <= DEC) || (LA31_0 >= NOT && LA31_0 <= INV) || (LA31_0 >= XML_AT && LA31_0 <= XML_LS_STD) || (LA31_0 >= SINGLE_QUOTE_LITERAL && LA31_0 <= DOUBLE_QUOTE_LITERAL) || LA31_0 == REGULAR_EXPR_LITERAL || LA31_0 == HEX_NUMBER_LITERAL || LA31_0 == DEC_NUMBER_LITERAL || LA31_0 == IDENTIFIER || (LA31_0 >= XML_COMMENT && LA31_0 <= XML_PI)))
            {
                alt31 = 1;
            }
            else if ((LA31_0 == EOF))
            {
                int LA31_2 = input.LA(2);

                if ((LA31_2 == EOF))
                {
                    alt31 = 2;
                }
                else
                {
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    NoViableAltException nvae_d31s2 =
                        new NoViableAltException("", 31, 2, input);

                    throw nvae_d31s2;
                }
            }
            else
            {
                if (state.backtracking > 0) { state.failed = true; return retval; }
                NoViableAltException nvae_d31s0 =
                    new NoViableAltException("", 31, 0, input);

                throw nvae_d31s0;
            }
            switch (alt31)
            {
                case 1:
                    // AS3_ex.g3:1497:4: ( ( packageDeclaration )? ( packageElement )* )
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        // AS3_ex.g3:1497:4: ( ( packageDeclaration )? ( packageElement )* )
                        // AS3_ex.g3:1497:5: ( packageDeclaration )? ( packageElement )*
                        {
                            // AS3_ex.g3:1497:5: ( packageDeclaration )?
                            int alt29 = 2;
                            int LA29_0 = input.LA(1);

                            if ((LA29_0 == PACKAGE))
                            {
                                int LA29_1 = input.LA(2);

                                if ((LA29_1 == DEFAULT || LA29_1 == INTERNAL || LA29_1 == NATIVE || LA29_1 == TO || LA29_1 == VOID || (LA29_1 >= EACH && LA29_1 <= NAMESPACE) || (LA29_1 >= DYNAMIC && LA29_1 <= STATIC) || LA29_1 == LCURLY || LA29_1 == STAR || LA29_1 == IDENTIFIER))
                                {
                                    alt29 = 1;
                                }
                            }
                            switch (alt29)
                            {
                                case 1:
                                    // AS3_ex.g3:0:0: packageDeclaration
                                    {
                                        PushFollow(FOLLOW_packageDeclaration_in_fileContents5957);
                                        packageDeclaration44 = packageDeclaration();
                                        state.followingStackPointer--;
                                        if (state.failed) return retval;
                                        if (state.backtracking == 0) adaptor.AddChild(root_0, packageDeclaration44.Tree);

                                    }
                                    break;

                            }

                            // AS3_ex.g3:1497:25: ( packageElement )*
                            do
                            {
                                int alt30 = 2;
                                int LA30_0 = input.LA(1);

                                if (((LA30_0 >= AS && LA30_0 <= LCURLY) || LA30_0 == LPAREN || LA30_0 == LBRACK || LA30_0 == LT || (LA30_0 >= PLUS && LA30_0 <= STAR) || (LA30_0 >= INC && LA30_0 <= DEC) || (LA30_0 >= NOT && LA30_0 <= INV) || (LA30_0 >= XML_AT && LA30_0 <= XML_LS_STD) || (LA30_0 >= SINGLE_QUOTE_LITERAL && LA30_0 <= DOUBLE_QUOTE_LITERAL) || LA30_0 == REGULAR_EXPR_LITERAL || LA30_0 == HEX_NUMBER_LITERAL || LA30_0 == DEC_NUMBER_LITERAL || LA30_0 == IDENTIFIER || (LA30_0 >= XML_COMMENT && LA30_0 <= XML_PI)))
                                {
                                    alt30 = 1;
                                }


                                switch (alt30)
                                {
                                    case 1:
                                        // AS3_ex.g3:0:0: packageElement
                                        {
                                            PushFollow(FOLLOW_packageElement_in_fileContents5960);
                                            packageElement45 = packageElement();
                                            state.followingStackPointer--;
                                            if (state.failed) return retval;
                                            if (state.backtracking == 0) adaptor.AddChild(root_0, packageElement45.Tree);

                                        }
                                        break;

                                    default:
                                        goto loop30;
                                }
                            } while (true);

                        loop30:
                            ;	// Stops C# compiler whining that label 'loop30' has no statements


                        }


                    }
                    break;
                case 2:
                    // AS3_ex.g3:1497:44: EOF
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        EOF46 = (IToken)Match(input, EOF, FOLLOW_EOF_in_fileContents5966); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            EOF46_tree = (object)adaptor.Create(EOF46);
                            adaptor.AddChild(root_0, EOF46_tree);
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 29, fileContents_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "fileContents"

    public class packageDeclaration_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "packageDeclaration"
    // AS3_ex.g3:1502:1: packageDeclaration : p= PACKAGE ( type )? l= LCURLY ( packageElement )* r= RCURLY ;
    public AS3_exParser.packageDeclaration_return packageDeclaration() // throws RecognitionException [1]
    {
        AS3_exParser.packageDeclaration_return retval = new AS3_exParser.packageDeclaration_return();
        retval.Start = input.LT(1);
        int packageDeclaration_StartIndex = input.Index();
        object root_0 = null;

        IToken p = null;
        IToken l = null;
        IToken r = null;
        AS3_exParser.type_return type47 = null;

        AS3_exParser.packageElement_return packageElement48 = null;


        object p_tree = null;
        object l_tree = null;
        object r_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 30))
            {
                return retval;
            }
            // AS3_ex.g3:1503:2: (p= PACKAGE ( type )? l= LCURLY ( packageElement )* r= RCURLY )
            // AS3_ex.g3:1503:6: p= PACKAGE ( type )? l= LCURLY ( packageElement )* r= RCURLY
            {
                root_0 = (object)adaptor.GetNilNode();

                p = (IToken)Match(input, PACKAGE, FOLLOW_PACKAGE_in_packageDeclaration5983); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    p_tree = (object)adaptor.Create(p);
                    adaptor.AddChild(root_0, p_tree);
                }
                if (state.backtracking == 0)
                {
                    { InsertCR(false); } Emit((CommonToken)p); PushExpressionIndent();
                }
                // AS3_ex.g3:1503:82: ( type )?
                int alt32 = 2;
                int LA32_0 = input.LA(1);

                if ((LA32_0 == DEFAULT || LA32_0 == INTERNAL || LA32_0 == NATIVE || LA32_0 == TO || LA32_0 == VOID || (LA32_0 >= EACH && LA32_0 <= NAMESPACE) || (LA32_0 >= DYNAMIC && LA32_0 <= STATIC) || LA32_0 == STAR || LA32_0 == IDENTIFIER))
                {
                    alt32 = 1;
                }
                switch (alt32)
                {
                    case 1:
                        // AS3_ex.g3:1503:83: type
                        {
                            PushFollow(FOLLOW_type_in_packageDeclaration5988);
                            type47 = type();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, type47.Tree);

                        }
                        break;

                }

                if (state.backtracking == 0)
                {
                    PopIndent();
                }
                l = (IToken)Match(input, LCURLY, FOLLOW_LCURLY_in_packageDeclaration6002); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    l_tree = (object)adaptor.Create(l);
                    adaptor.AddChild(root_0, l_tree);
                }
                if (state.backtracking == 0)
                {

                    LeftCurlyNewlineHandler(false);
                    Emit((CommonToken)l);
                    if (mPrinter.IsIndentAtPackageLevel())
                        PushIndent(true);

                }
                // AS3_ex.g3:1511:6: ( packageElement )*
                do
                {
                    int alt33 = 2;
                    int LA33_0 = input.LA(1);

                    if (((LA33_0 >= AS && LA33_0 <= LCURLY) || LA33_0 == LPAREN || LA33_0 == LBRACK || LA33_0 == LT || (LA33_0 >= PLUS && LA33_0 <= STAR) || (LA33_0 >= INC && LA33_0 <= DEC) || (LA33_0 >= NOT && LA33_0 <= INV) || (LA33_0 >= XML_AT && LA33_0 <= XML_LS_STD) || (LA33_0 >= SINGLE_QUOTE_LITERAL && LA33_0 <= DOUBLE_QUOTE_LITERAL) || LA33_0 == REGULAR_EXPR_LITERAL || LA33_0 == HEX_NUMBER_LITERAL || LA33_0 == DEC_NUMBER_LITERAL || LA33_0 == IDENTIFIER || (LA33_0 >= XML_COMMENT && LA33_0 <= XML_PI)))
                    {
                        alt33 = 1;
                    }


                    switch (alt33)
                    {
                        case 1:
                            // AS3_ex.g3:0:0: packageElement
                            {
                                PushFollow(FOLLOW_packageElement_in_packageDeclaration6018);
                                packageElement48 = packageElement();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, packageElement48.Tree);

                            }
                            break;

                        default:
                            goto loop33;
                    }
                } while (true);

            loop33:
                ;	// Stops C# compiler whining that label 'loop33' has no statements

                if (state.backtracking == 0)
                {

                    if (mPrinter.IsIndentAtPackageLevel())
                        PopIndent();

                }
                r = (IToken)Match(input, RCURLY, FOLLOW_RCURLY_in_packageDeclaration6037); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    r_tree = (object)adaptor.Create(r);
                    adaptor.AddChild(root_0, r_tree);
                }
                if (state.backtracking == 0)
                {
                    InsertCR(false); Emit((CommonToken)r);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 30, packageDeclaration_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "packageDeclaration"

    public class mxmlEmbedded_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "mxmlEmbedded"
    // AS3_ex.g3:1522:1: mxmlEmbedded : ( ( propertyDeclaration | functionDeclaration | statement | directive | interfaceFunctionDeclaration )* | EOF );
    public AS3_exParser.mxmlEmbedded_return mxmlEmbedded() // throws RecognitionException [1]
    {
        AS3_exParser.mxmlEmbedded_return retval = new AS3_exParser.mxmlEmbedded_return();
        retval.Start = input.LT(1);
        int mxmlEmbedded_StartIndex = input.Index();
        object root_0 = null;

        IToken EOF54 = null;
        AS3_exParser.propertyDeclaration_return propertyDeclaration49 = null;

        AS3_exParser.functionDeclaration_return functionDeclaration50 = null;

        AS3_exParser.statement_return statement51 = null;

        AS3_exParser.directive_return directive52 = null;

        AS3_exParser.interfaceFunctionDeclaration_return interfaceFunctionDeclaration53 = null;


        object EOF54_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 31))
            {
                return retval;
            }
            // AS3_ex.g3:1523:2: ( ( propertyDeclaration | functionDeclaration | statement | directive | interfaceFunctionDeclaration )* | EOF )
            int alt35 = 2;
            int LA35_0 = input.LA(1);

            if (((LA35_0 >= AS && LA35_0 <= LCURLY) || LA35_0 == LPAREN || LA35_0 == LBRACK || LA35_0 == LT || (LA35_0 >= PLUS && LA35_0 <= STAR) || (LA35_0 >= INC && LA35_0 <= DEC) || (LA35_0 >= NOT && LA35_0 <= INV) || (LA35_0 >= XML_AT && LA35_0 <= XML_LS_STD) || (LA35_0 >= SINGLE_QUOTE_LITERAL && LA35_0 <= DOUBLE_QUOTE_LITERAL) || LA35_0 == REGULAR_EXPR_LITERAL || LA35_0 == HEX_NUMBER_LITERAL || LA35_0 == DEC_NUMBER_LITERAL || LA35_0 == IDENTIFIER || (LA35_0 >= XML_COMMENT && LA35_0 <= XML_PI)))
            {
                alt35 = 1;
            }
            else if ((LA35_0 == EOF))
            {
                int LA35_2 = input.LA(2);

                if ((LA35_2 == EOF))
                {
                    alt35 = 2;
                }
                else
                {
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    NoViableAltException nvae_d35s2 =
                        new NoViableAltException("", 35, 2, input);

                    throw nvae_d35s2;
                }
            }
            else
            {
                if (state.backtracking > 0) { state.failed = true; return retval; }
                NoViableAltException nvae_d35s0 =
                    new NoViableAltException("", 35, 0, input);

                throw nvae_d35s0;
            }
            switch (alt35)
            {
                case 1:
                    // AS3_ex.g3:1524:6: ( propertyDeclaration | functionDeclaration | statement | directive | interfaceFunctionDeclaration )*
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        // AS3_ex.g3:1524:6: ( propertyDeclaration | functionDeclaration | statement | directive | interfaceFunctionDeclaration )*
                        do
                        {
                            int alt34 = 6;
                            alt34 = dfa34.Predict(input);
                            switch (alt34)
                            {
                                case 1:
                                    // AS3_ex.g3:1524:7: propertyDeclaration
                                    {
                                        PushFollow(FOLLOW_propertyDeclaration_in_mxmlEmbedded6062);
                                        propertyDeclaration49 = propertyDeclaration();
                                        state.followingStackPointer--;
                                        if (state.failed) return retval;
                                        if (state.backtracking == 0) adaptor.AddChild(root_0, propertyDeclaration49.Tree);

                                    }
                                    break;
                                case 2:
                                    // AS3_ex.g3:1524:29: functionDeclaration
                                    {
                                        PushFollow(FOLLOW_functionDeclaration_in_mxmlEmbedded6066);
                                        functionDeclaration50 = functionDeclaration();
                                        state.followingStackPointer--;
                                        if (state.failed) return retval;
                                        if (state.backtracking == 0) adaptor.AddChild(root_0, functionDeclaration50.Tree);

                                    }
                                    break;
                                case 3:
                                    // AS3_ex.g3:1524:51: statement
                                    {
                                        PushFollow(FOLLOW_statement_in_mxmlEmbedded6070);
                                        statement51 = statement();
                                        state.followingStackPointer--;
                                        if (state.failed) return retval;
                                        if (state.backtracking == 0) adaptor.AddChild(root_0, statement51.Tree);

                                    }
                                    break;
                                case 4:
                                    // AS3_ex.g3:1524:63: directive
                                    {
                                        PushFollow(FOLLOW_directive_in_mxmlEmbedded6074);
                                        directive52 = directive();
                                        state.followingStackPointer--;
                                        if (state.failed) return retval;
                                        if (state.backtracking == 0) adaptor.AddChild(root_0, directive52.Tree);

                                    }
                                    break;
                                case 5:
                                    // AS3_ex.g3:1524:75: interfaceFunctionDeclaration
                                    {
                                        PushFollow(FOLLOW_interfaceFunctionDeclaration_in_mxmlEmbedded6078);
                                        interfaceFunctionDeclaration53 = interfaceFunctionDeclaration();
                                        state.followingStackPointer--;
                                        if (state.failed) return retval;
                                        if (state.backtracking == 0) adaptor.AddChild(root_0, interfaceFunctionDeclaration53.Tree);

                                    }
                                    break;

                                default:
                                    goto loop34;
                            }
                        } while (true);

                    loop34:
                        ;	// Stops C# compiler whining that label 'loop34' has no statements


                    }
                    break;
                case 2:
                    // AS3_ex.g3:1524:108: EOF
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        EOF54 = (IToken)Match(input, EOF, FOLLOW_EOF_in_mxmlEmbedded6084); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            EOF54_tree = (object)adaptor.Create(EOF54);
                            adaptor.AddChild(root_0, EOF54_tree);
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 31, mxmlEmbedded_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "mxmlEmbedded"

    public class packageElement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "packageElement"
    // AS3_ex.g3:1527:1: packageElement : ( classOrInterfaceDecl | propertyDeclaration | functionDeclaration | interfaceFunctionDeclaration | statement | directive );
    public AS3_exParser.packageElement_return packageElement() // throws RecognitionException [1]
    {
        AS3_exParser.packageElement_return retval = new AS3_exParser.packageElement_return();
        retval.Start = input.LT(1);
        int packageElement_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.classOrInterfaceDecl_return classOrInterfaceDecl55 = null;

        AS3_exParser.propertyDeclaration_return propertyDeclaration56 = null;

        AS3_exParser.functionDeclaration_return functionDeclaration57 = null;

        AS3_exParser.interfaceFunctionDeclaration_return interfaceFunctionDeclaration58 = null;

        AS3_exParser.statement_return statement59 = null;

        AS3_exParser.directive_return directive60 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 32))
            {
                return retval;
            }
            // AS3_ex.g3:1528:5: ( classOrInterfaceDecl | propertyDeclaration | functionDeclaration | interfaceFunctionDeclaration | statement | directive )
            int alt36 = 6;
            alt36 = dfa36.Predict(input);
            switch (alt36)
            {
                case 1:
                    // AS3_ex.g3:1528:9: classOrInterfaceDecl
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_classOrInterfaceDecl_in_packageElement6104);
                        classOrInterfaceDecl55 = classOrInterfaceDecl();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, classOrInterfaceDecl55.Tree);

                    }
                    break;
                case 2:
                    // AS3_ex.g3:1528:32: propertyDeclaration
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_propertyDeclaration_in_packageElement6108);
                        propertyDeclaration56 = propertyDeclaration();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, propertyDeclaration56.Tree);

                    }
                    break;
                case 3:
                    // AS3_ex.g3:1528:54: functionDeclaration
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_functionDeclaration_in_packageElement6112);
                        functionDeclaration57 = functionDeclaration();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, functionDeclaration57.Tree);

                    }
                    break;
                case 4:
                    // AS3_ex.g3:1528:76: interfaceFunctionDeclaration
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_interfaceFunctionDeclaration_in_packageElement6116);
                        interfaceFunctionDeclaration58 = interfaceFunctionDeclaration();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, interfaceFunctionDeclaration58.Tree);

                    }
                    break;
                case 5:
                    // AS3_ex.g3:1528:107: statement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_statement_in_packageElement6120);
                        statement59 = statement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, statement59.Tree);

                    }
                    break;
                case 6:
                    // AS3_ex.g3:1528:119: directive
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_directive_in_packageElement6124);
                        directive60 = directive();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, directive60.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 32, packageElement_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "packageElement"

    public class importDeclaration_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "importDeclaration"
    // AS3_ex.g3:1531:1: importDeclaration : i= IMPORT type (D= DOT S= STAR )? semic ;
    public AS3_exParser.importDeclaration_return importDeclaration() // throws RecognitionException [1]
    {
        AS3_exParser.importDeclaration_return retval = new AS3_exParser.importDeclaration_return();
        retval.Start = input.LT(1);
        int importDeclaration_StartIndex = input.Index();
        object root_0 = null;

        IToken i = null;
        IToken D = null;
        IToken S = null;
        AS3_exParser.type_return type61 = null;

        AS3_exParser.semic_return semic62 = null;


        object i_tree = null;
        object D_tree = null;
        object S_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 33))
            {
                return retval;
            }
            // AS3_ex.g3:1532:2: (i= IMPORT type (D= DOT S= STAR )? semic )
            // AS3_ex.g3:1532:6: i= IMPORT type (D= DOT S= STAR )? semic
            {
                root_0 = (object)adaptor.GetNilNode();

                if (state.backtracking == 0)
                {
                    InsertCR(false);
                }
                i = (IToken)Match(input, IMPORT, FOLLOW_IMPORT_in_importDeclaration6144); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    i_tree = (object)adaptor.Create(i);
                    adaptor.AddChild(root_0, i_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)i);
                }
                PushFollow(FOLLOW_type_in_importDeclaration6148);
                type61 = type();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, type61.Tree);
                // AS3_ex.g3:1532:64: (D= DOT S= STAR )?
                int alt37 = 2;
                int LA37_0 = input.LA(1);

                if ((LA37_0 == DOT))
                {
                    alt37 = 1;
                }
                switch (alt37)
                {
                    case 1:
                        // AS3_ex.g3:1532:65: D= DOT S= STAR
                        {
                            D = (IToken)Match(input, DOT, FOLLOW_DOT_in_importDeclaration6153); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                D_tree = (object)adaptor.Create(D);
                                adaptor.AddChild(root_0, D_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)D);
                            }
                            S = (IToken)Match(input, STAR, FOLLOW_STAR_in_importDeclaration6159); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                S_tree = (object)adaptor.Create(S);
                                adaptor.AddChild(root_0, S_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)S);
                            }

                        }
                        break;

                }

                PushFollow(FOLLOW_semic_in_importDeclaration6165);
                semic62 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, semic62.Tree);

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 33, importDeclaration_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "importDeclaration"

    public class classOrInterfaceDecl_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "classOrInterfaceDecl"
    // AS3_ex.g3:1535:1: classOrInterfaceDecl : ( conditionalDirAndBindingDecls )? ( memberModifiers )? ( interfaceDeclaration | classDeclaration ) ;
    public AS3_exParser.classOrInterfaceDecl_return classOrInterfaceDecl() // throws RecognitionException [1]
    {
        AS3_exParser.classOrInterfaceDecl_return retval = new AS3_exParser.classOrInterfaceDecl_return();
        retval.Start = input.LT(1);
        int classOrInterfaceDecl_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.conditionalDirAndBindingDecls_return conditionalDirAndBindingDecls63 = null;

        AS3_exParser.memberModifiers_return memberModifiers64 = null;

        AS3_exParser.interfaceDeclaration_return interfaceDeclaration65 = null;

        AS3_exParser.classDeclaration_return classDeclaration66 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 34))
            {
                return retval;
            }
            // AS3_ex.g3:1536:2: ( ( conditionalDirAndBindingDecls )? ( memberModifiers )? ( interfaceDeclaration | classDeclaration ) )
            // AS3_ex.g3:1536:6: ( conditionalDirAndBindingDecls )? ( memberModifiers )? ( interfaceDeclaration | classDeclaration )
            {
                root_0 = (object)adaptor.GetNilNode();

                // AS3_ex.g3:1536:6: ( conditionalDirAndBindingDecls )?
                int alt38 = 2;
                switch (input.LA(1))
                {
                    case IDENTIFIER:
                        {
                            int LA38_1 = input.LA(2);

                            if ((LA38_1 == XML_NS_OP))
                            {
                                alt38 = 1;
                            }
                        }
                        break;
                    case NATIVE:
                    case DYNAMIC:
                    case FINAL:
                    case OVERRIDE:
                    case STATIC:
                        {
                            int LA38_2 = input.LA(2);

                            if ((LA38_2 == XML_NS_OP))
                            {
                                alt38 = 1;
                            }
                        }
                        break;
                    case TO:
                    case EACH:
                    case GET:
                    case SET:
                    case NAMESPACE:
                        {
                            alt38 = 1;
                        }
                        break;
                }

                switch (alt38)
                {
                    case 1:
                        // AS3_ex.g3:1536:7: conditionalDirAndBindingDecls
                        {
                            PushFollow(FOLLOW_conditionalDirAndBindingDecls_in_classOrInterfaceDecl6180);
                            conditionalDirAndBindingDecls63 = conditionalDirAndBindingDecls();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, conditionalDirAndBindingDecls63.Tree);

                        }
                        break;

                }

                if (state.backtracking == 0)
                {
                    PushLazyIndent();
                }
                if (state.backtracking == 0)
                {
                    InsertCR(false);
                }
                if (state.backtracking == 0)
                {
                    InsertLines(mPrinter.GetBlankLinesBeforeClass(), false);
                }
                // AS3_ex.g3:1536:135: ( memberModifiers )?
                int alt39 = 2;
                int LA39_0 = input.LA(1);

                if ((LA39_0 == INTERNAL || LA39_0 == NATIVE || (LA39_0 >= PRIVATE && LA39_0 <= PUBLIC) || (LA39_0 >= DYNAMIC && LA39_0 <= STATIC) || LA39_0 == IDENTIFIER))
                {
                    alt39 = 1;
                }
                switch (alt39)
                {
                    case 1:
                        // AS3_ex.g3:0:0: memberModifiers
                        {
                            PushFollow(FOLLOW_memberModifiers_in_classOrInterfaceDecl6188);
                            memberModifiers64 = memberModifiers();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, memberModifiers64.Tree);

                        }
                        break;

                }

                // AS3_ex.g3:1536:152: ( interfaceDeclaration | classDeclaration )
                int alt40 = 2;
                int LA40_0 = input.LA(1);

                if ((LA40_0 == INTERFACE))
                {
                    alt40 = 1;
                }
                else if ((LA40_0 == CLASS))
                {
                    alt40 = 2;
                }
                else
                {
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    NoViableAltException nvae_d40s0 =
                        new NoViableAltException("", 40, 0, input);

                    throw nvae_d40s0;
                }
                switch (alt40)
                {
                    case 1:
                        // AS3_ex.g3:1536:153: interfaceDeclaration
                        {
                            PushFollow(FOLLOW_interfaceDeclaration_in_classOrInterfaceDecl6192);
                            interfaceDeclaration65 = interfaceDeclaration();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, interfaceDeclaration65.Tree);

                        }
                        break;
                    case 2:
                        // AS3_ex.g3:1536:176: classDeclaration
                        {
                            PushFollow(FOLLOW_classDeclaration_in_classOrInterfaceDecl6196);
                            classDeclaration66 = classDeclaration();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, classDeclaration66.Tree);

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 34, classOrInterfaceDecl_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "classOrInterfaceDecl"

    public class directive_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "directive"
    // AS3_ex.g3:1539:1: directive : ( bindingDecl | includeDirective | useNamespaceDirective | importDeclaration | defaultXMLNamespaceDirective ) ;
    public AS3_exParser.directive_return directive() // throws RecognitionException [1]
    {
        AS3_exParser.directive_return retval = new AS3_exParser.directive_return();
        retval.Start = input.LT(1);
        int directive_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.bindingDecl_return bindingDecl67 = null;

        AS3_exParser.includeDirective_return includeDirective68 = null;

        AS3_exParser.useNamespaceDirective_return useNamespaceDirective69 = null;

        AS3_exParser.importDeclaration_return importDeclaration70 = null;

        AS3_exParser.defaultXMLNamespaceDirective_return defaultXMLNamespaceDirective71 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 35))
            {
                return retval;
            }
            // AS3_ex.g3:1540:2: ( ( bindingDecl | includeDirective | useNamespaceDirective | importDeclaration | defaultXMLNamespaceDirective ) )
            // AS3_ex.g3:1540:4: ( bindingDecl | includeDirective | useNamespaceDirective | importDeclaration | defaultXMLNamespaceDirective )
            {
                root_0 = (object)adaptor.GetNilNode();

                if (state.backtracking == 0)
                {
                    PushLazyIndent();
                }
                if (state.backtracking == 0)
                {
                    InsertCR(false);
                }
                // AS3_ex.g3:1540:41: ( bindingDecl | includeDirective | useNamespaceDirective | importDeclaration | defaultXMLNamespaceDirective )
                int alt41 = 5;
                switch (input.LA(1))
                {
                    case LBRACK:
                        {
                            alt41 = 1;
                        }
                        break;
                    case INCLUDE:
                        {
                            alt41 = 2;
                        }
                        break;
                    case USE:
                        {
                            alt41 = 3;
                        }
                        break;
                    case IMPORT:
                        {
                            alt41 = 4;
                        }
                        break;
                    case DEFAULT:
                        {
                            alt41 = 5;
                        }
                        break;
                    default:
                        if (state.backtracking > 0) { state.failed = true; return retval; }
                        NoViableAltException nvae_d41s0 =
                            new NoViableAltException("", 41, 0, input);

                        throw nvae_d41s0;
                }

                switch (alt41)
                {
                    case 1:
                        // AS3_ex.g3:1540:42: bindingDecl
                        {
                            PushFollow(FOLLOW_bindingDecl_in_directive6212);
                            bindingDecl67 = bindingDecl();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, bindingDecl67.Tree);

                        }
                        break;
                    case 2:
                        // AS3_ex.g3:1540:56: includeDirective
                        {
                            PushFollow(FOLLOW_includeDirective_in_directive6216);
                            includeDirective68 = includeDirective();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, includeDirective68.Tree);

                        }
                        break;
                    case 3:
                        // AS3_ex.g3:1540:75: useNamespaceDirective
                        {
                            PushFollow(FOLLOW_useNamespaceDirective_in_directive6220);
                            useNamespaceDirective69 = useNamespaceDirective();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, useNamespaceDirective69.Tree);

                        }
                        break;
                    case 4:
                        // AS3_ex.g3:1540:99: importDeclaration
                        {
                            PushFollow(FOLLOW_importDeclaration_in_directive6224);
                            importDeclaration70 = importDeclaration();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, importDeclaration70.Tree);

                        }
                        break;
                    case 5:
                        // AS3_ex.g3:1540:144: defaultXMLNamespaceDirective
                        {
                            PushFollow(FOLLOW_defaultXMLNamespaceDirective_in_directive6230);
                            defaultXMLNamespaceDirective71 = defaultXMLNamespaceDirective();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, defaultXMLNamespaceDirective71.Tree);

                        }
                        break;

                }

                if (state.backtracking == 0)
                {
                    PopIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 35, directive_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "directive"

    public class conditionalDirAndBindingDecls_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "conditionalDirAndBindingDecls"
    // AS3_ex.g3:1543:1: conditionalDirAndBindingDecls : conditionalCompilerOption ( bindingDecl )* ;
    public AS3_exParser.conditionalDirAndBindingDecls_return conditionalDirAndBindingDecls() // throws RecognitionException [1]
    {
        AS3_exParser.conditionalDirAndBindingDecls_return retval = new AS3_exParser.conditionalDirAndBindingDecls_return();
        retval.Start = input.LT(1);
        int conditionalDirAndBindingDecls_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.conditionalCompilerOption_return conditionalCompilerOption72 = null;

        AS3_exParser.bindingDecl_return bindingDecl73 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 36))
            {
                return retval;
            }
            // AS3_ex.g3:1544:2: ( conditionalCompilerOption ( bindingDecl )* )
            // AS3_ex.g3:1544:4: conditionalCompilerOption ( bindingDecl )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if (state.backtracking == 0)
                {
                    InsertCR(false);
                }
                if (state.backtracking == 0)
                {
                    mPrinter.MarkBindablePos(true);
                }
                PushFollow(FOLLOW_conditionalCompilerOption_in_conditionalDirAndBindingDecls6256);
                conditionalCompilerOption72 = conditionalCompilerOption();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, conditionalCompilerOption72.Tree);
                if (state.backtracking == 0)
                {
                    mPrinter.SetBindableMode();
                }
                // AS3_ex.g3:1548:4: ( bindingDecl )*
                do
                {
                    int alt42 = 2;
                    int LA42_0 = input.LA(1);

                    if ((LA42_0 == LBRACK))
                    {
                        alt42 = 1;
                    }


                    switch (alt42)
                    {
                        case 1:
                            // AS3_ex.g3:1548:5: bindingDecl
                            {
                                if (state.backtracking == 0)
                                {
                                    InsertCR(false);
                                }
                                PushFollow(FOLLOW_bindingDecl_in_conditionalDirAndBindingDecls6273);
                                bindingDecl73 = bindingDecl();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, bindingDecl73.Tree);

                            }
                            break;

                        default:
                            goto loop42;
                    }
                } while (true);

            loop42:
                ;	// Stops C# compiler whining that label 'loop42' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 36, conditionalDirAndBindingDecls_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "conditionalDirAndBindingDecls"

    public class xmlKeyword_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "xmlKeyword"
    // AS3_ex.g3:1551:1: xmlKeyword : {...}?I= IDENTIFIER ;
    public AS3_exParser.xmlKeyword_return xmlKeyword() // throws RecognitionException [1]
    {
        AS3_exParser.xmlKeyword_return retval = new AS3_exParser.xmlKeyword_return();
        retval.Start = input.LT(1);
        int xmlKeyword_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;

        object I_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 37))
            {
                return retval;
            }
            // AS3_ex.g3:1552:2: ({...}?I= IDENTIFIER )
            // AS3_ex.g3:1552:4: {...}?I= IDENTIFIER
            {
                root_0 = (object)adaptor.GetNilNode();

                if (!((input.LT(1).Text.ToLower().Equals("xml"))))
                {
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    throw new FailedPredicateException(input, "xmlKeyword", "input.LT(1).Text.ToLower().Equals(\"xml\")");
                }
                I = (IToken)Match(input, IDENTIFIER, FOLLOW_IDENTIFIER_in_xmlKeyword6291); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    I_tree = (object)adaptor.Create(I);
                    adaptor.AddChild(root_0, I_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)I);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 37, xmlKeyword_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "xmlKeyword"

    public class conditionalCompilerOption_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "conditionalCompilerOption"
    // AS3_ex.g3:1555:1: conditionalCompilerOption : identifierLiteral x= XML_NS_OP identifierLiteral ;
    public AS3_exParser.conditionalCompilerOption_return conditionalCompilerOption() // throws RecognitionException [1]
    {
        AS3_exParser.conditionalCompilerOption_return retval = new AS3_exParser.conditionalCompilerOption_return();
        retval.Start = input.LT(1);
        int conditionalCompilerOption_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;
        AS3_exParser.identifierLiteral_return identifierLiteral74 = null;

        AS3_exParser.identifierLiteral_return identifierLiteral75 = null;


        object x_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 38))
            {
                return retval;
            }
            // AS3_ex.g3:1556:2: ( identifierLiteral x= XML_NS_OP identifierLiteral )
            // AS3_ex.g3:1557:2: identifierLiteral x= XML_NS_OP identifierLiteral
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_identifierLiteral_in_conditionalCompilerOption6307);
                identifierLiteral74 = identifierLiteral();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, identifierLiteral74.Tree);
                x = (IToken)Match(input, XML_NS_OP, FOLLOW_XML_NS_OP_in_conditionalCompilerOption6311); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    x_tree = (object)adaptor.Create(x);
                    adaptor.AddChild(root_0, x_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)x);
                }
                PushFollow(FOLLOW_identifierLiteral_in_conditionalCompilerOption6315);
                identifierLiteral75 = identifierLiteral();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, identifierLiteral75.Tree);

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 38, conditionalCompilerOption_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "conditionalCompilerOption"

    public class defaultXMLNamespaceDirective_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "defaultXMLNamespaceDirective"
    // AS3_ex.g3:1560:1: defaultXMLNamespaceDirective : D= DEFAULT xmlKeyword N= NAMESPACE A= ASSIGN I= IDENTIFIER semic ;
    public AS3_exParser.defaultXMLNamespaceDirective_return defaultXMLNamespaceDirective() // throws RecognitionException [1]
    {
        AS3_exParser.defaultXMLNamespaceDirective_return retval = new AS3_exParser.defaultXMLNamespaceDirective_return();
        retval.Start = input.LT(1);
        int defaultXMLNamespaceDirective_StartIndex = input.Index();
        object root_0 = null;

        IToken D = null;
        IToken N = null;
        IToken A = null;
        IToken I = null;
        AS3_exParser.xmlKeyword_return xmlKeyword76 = null;

        AS3_exParser.semic_return semic77 = null;


        object D_tree = null;
        object N_tree = null;
        object A_tree = null;
        object I_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 39))
            {
                return retval;
            }
            // AS3_ex.g3:1561:2: (D= DEFAULT xmlKeyword N= NAMESPACE A= ASSIGN I= IDENTIFIER semic )
            // AS3_ex.g3:1561:4: D= DEFAULT xmlKeyword N= NAMESPACE A= ASSIGN I= IDENTIFIER semic
            {
                root_0 = (object)adaptor.GetNilNode();

                D = (IToken)Match(input, DEFAULT, FOLLOW_DEFAULT_in_defaultXMLNamespaceDirective6329); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    D_tree = (object)adaptor.Create(D);
                    adaptor.AddChild(root_0, D_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)D);
                }
                PushFollow(FOLLOW_xmlKeyword_in_defaultXMLNamespaceDirective6333);
                xmlKeyword76 = xmlKeyword();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, xmlKeyword76.Tree);
                N = (IToken)Match(input, NAMESPACE, FOLLOW_NAMESPACE_in_defaultXMLNamespaceDirective6341); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    N_tree = (object)adaptor.Create(N);
                    adaptor.AddChild(root_0, N_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)N);
                }
                A = (IToken)Match(input, ASSIGN, FOLLOW_ASSIGN_in_defaultXMLNamespaceDirective6349); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    A_tree = (object)adaptor.Create(A);
                    adaptor.AddChild(root_0, A_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)A);
                }
                I = (IToken)Match(input, IDENTIFIER, FOLLOW_IDENTIFIER_in_defaultXMLNamespaceDirective6355); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    I_tree = (object)adaptor.Create(I);
                    adaptor.AddChild(root_0, I_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)I);
                }
                PushFollow(FOLLOW_semic_in_defaultXMLNamespaceDirective6359);
                semic77 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, semic77.Tree);

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 39, defaultXMLNamespaceDirective_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "defaultXMLNamespaceDirective"

    public class bindingDecl_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "bindingDecl"
    // AS3_ex.g3:1567:1: bindingDecl : L= LBRACK I= IDENTIFIER (L= LPAREN ( bindingDeclArg (C= COMMA bindingDeclArg )* )? R= RPAREN )? R= RBRACK (s= SEMI )? ;
    public AS3_exParser.bindingDecl_return bindingDecl() // throws RecognitionException [1]
    {
        AS3_exParser.bindingDecl_return retval = new AS3_exParser.bindingDecl_return();
        retval.Start = input.LT(1);
        int bindingDecl_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken I = null;
        IToken C = null;
        IToken R = null;
        IToken s = null;
        AS3_exParser.bindingDeclArg_return bindingDeclArg78 = null;

        AS3_exParser.bindingDeclArg_return bindingDeclArg79 = null;


        object L_tree = null;
        object I_tree = null;
        object C_tree = null;
        object R_tree = null;
        object s_tree = null;

        bool bindable = false;
        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 40))
            {
                return retval;
            }
            // AS3_ex.g3:1569:2: (L= LBRACK I= IDENTIFIER (L= LPAREN ( bindingDeclArg (C= COMMA bindingDeclArg )* )? R= RPAREN )? R= RBRACK (s= SEMI )? )
            // AS3_ex.g3:1569:4: L= LBRACK I= IDENTIFIER (L= LPAREN ( bindingDeclArg (C= COMMA bindingDeclArg )* )? R= RPAREN )? R= RBRACK (s= SEMI )?
            {
                root_0 = (object)adaptor.GetNilNode();

                L = (IToken)Match(input, LBRACK, FOLLOW_LBRACK_in_bindingDecl6379); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                I = (IToken)Match(input, IDENTIFIER, FOLLOW_IDENTIFIER_in_bindingDecl6389); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    I_tree = (object)adaptor.Create(I);
                    adaptor.AddChild(root_0, I_tree);
                }
                if (state.backtracking == 0)
                {

                    bindable = mPrinter.IsDirectiveForNextElement(I.Text);
                    if (bindable)
                        mPrinter.MarkBindablePos(false); //call this to mark position *before* we send any of the tokens to the printer
                    Emit((CommonToken)L);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)I);

                }
                // AS3_ex.g3:1578:5: (L= LPAREN ( bindingDeclArg (C= COMMA bindingDeclArg )* )? R= RPAREN )?
                int alt45 = 2;
                int LA45_0 = input.LA(1);

                if ((LA45_0 == LPAREN))
                {
                    alt45 = 1;
                }
                switch (alt45)
                {
                    case 1:
                        // AS3_ex.g3:1578:6: L= LPAREN ( bindingDeclArg (C= COMMA bindingDeclArg )* )? R= RPAREN
                        {
                            L = (IToken)Match(input, LPAREN, FOLLOW_LPAREN_in_bindingDecl6415); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                L_tree = (object)adaptor.Create(L);
                                adaptor.AddChild(root_0, L_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)L); InsertWS(mPrinter.GetAdvancedSpacesInsideParens());
                            }
                            // AS3_ex.g3:1579:8: ( bindingDeclArg (C= COMMA bindingDeclArg )* )?
                            int alt44 = 2;
                            int LA44_0 = input.LA(1);

                            if (((LA44_0 >= AS && LA44_0 <= STATIC) || LA44_0 == STAR || LA44_0 == XML_AT || (LA44_0 >= SINGLE_QUOTE_LITERAL && LA44_0 <= DOUBLE_QUOTE_LITERAL) || LA44_0 == HEX_NUMBER_LITERAL || LA44_0 == DEC_NUMBER_LITERAL || LA44_0 == IDENTIFIER))
                            {
                                alt44 = 1;
                            }
                            switch (alt44)
                            {
                                case 1:
                                    // AS3_ex.g3:1579:9: bindingDeclArg (C= COMMA bindingDeclArg )*
                                    {
                                        PushFollow(FOLLOW_bindingDeclArg_in_bindingDecl6428);
                                        bindingDeclArg78 = bindingDeclArg();
                                        state.followingStackPointer--;
                                        if (state.failed) return retval;
                                        if (state.backtracking == 0) adaptor.AddChild(root_0, bindingDeclArg78.Tree);
                                        // AS3_ex.g3:1579:24: (C= COMMA bindingDeclArg )*
                                        do
                                        {
                                            int alt43 = 2;
                                            int LA43_0 = input.LA(1);

                                            if ((LA43_0 == COMMA))
                                            {
                                                alt43 = 1;
                                            }


                                            switch (alt43)
                                            {
                                                case 1:
                                                    // AS3_ex.g3:1579:25: C= COMMA bindingDeclArg
                                                    {
                                                        C = (IToken)Match(input, COMMA, FOLLOW_COMMA_in_bindingDecl6433); if (state.failed) return retval;
                                                        if (state.backtracking == 0)
                                                        {
                                                            C_tree = (object)adaptor.Create(C);
                                                            adaptor.AddChild(root_0, C_tree);
                                                        }
                                                        if (state.backtracking == 0)
                                                        {
                                                            Emit((CommonToken)C);
                                                        }
                                                        PushFollow(FOLLOW_bindingDeclArg_in_bindingDecl6437);
                                                        bindingDeclArg79 = bindingDeclArg();
                                                        state.followingStackPointer--;
                                                        if (state.failed) return retval;
                                                        if (state.backtracking == 0) adaptor.AddChild(root_0, bindingDeclArg79.Tree);

                                                    }
                                                    break;

                                                default:
                                                    goto loop43;
                                            }
                                        } while (true);

                                    loop43:
                                        ;	// Stops C# compiler whining that label 'loop43' has no statements


                                    }
                                    break;

                            }

                            R = (IToken)Match(input, RPAREN, FOLLOW_RPAREN_in_bindingDecl6451); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                R_tree = (object)adaptor.Create(R);
                                adaptor.AddChild(root_0, R_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                InsertWS(mPrinter.GetAdvancedSpacesInsideParens()); Emit((CommonToken)R);
                            }

                        }
                        break;

                }

                R = (IToken)Match(input, RBRACK, FOLLOW_RBRACK_in_bindingDecl6473); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)R);
                }
                // AS3_ex.g3:1582:38: (s= SEMI )?
                int alt46 = 2;
                int LA46_0 = input.LA(1);

                if ((LA46_0 == SEMI))
                {
                    int LA46_1 = input.LA(2);

                    if ((synpred122_AS3_ex()))
                    {
                        alt46 = 1;
                    }
                }
                switch (alt46)
                {
                    case 1:
                        // AS3_ex.g3:1582:39: s= SEMI
                        {
                            s = (IToken)Match(input, SEMI, FOLLOW_SEMI_in_bindingDecl6479); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                s_tree = (object)adaptor.Create(s);
                                adaptor.AddChild(root_0, s_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)s);
                            }

                        }
                        break;

                }

                if (state.backtracking == 0)
                {

                    if (bindable)
                    {
                        mPrinter.SetBindableMode();
                    }

                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 40, bindingDecl_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "bindingDecl"

    public class includeDirective_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "includeDirective"
    // AS3_ex.g3:1591:1: includeDirective : I= INCLUDE stringLiteral semic ;
    public AS3_exParser.includeDirective_return includeDirective() // throws RecognitionException [1]
    {
        AS3_exParser.includeDirective_return retval = new AS3_exParser.includeDirective_return();
        retval.Start = input.LT(1);
        int includeDirective_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        AS3_exParser.stringLiteral_return stringLiteral80 = null;

        AS3_exParser.semic_return semic81 = null;


        object I_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 41))
            {
                return retval;
            }
            // AS3_ex.g3:1592:2: (I= INCLUDE stringLiteral semic )
            // AS3_ex.g3:1592:4: I= INCLUDE stringLiteral semic
            {
                root_0 = (object)adaptor.GetNilNode();

                I = (IToken)Match(input, INCLUDE, FOLLOW_INCLUDE_in_includeDirective6504); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    I_tree = (object)adaptor.Create(I);
                    adaptor.AddChild(root_0, I_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)I);
                }
                PushFollow(FOLLOW_stringLiteral_in_includeDirective6507);
                stringLiteral80 = stringLiteral();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, stringLiteral80.Tree);
                PushFollow(FOLLOW_semic_in_includeDirective6509);
                semic81 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, semic81.Tree);

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 41, includeDirective_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "includeDirective"

    public class bindingDeclArg_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "bindingDeclArg"
    // AS3_ex.g3:1595:1: bindingDeclArg : (I= IDENTIFIER E= ASSIGN )? ( stringLiteral | numericLiteral | eitherIdentifier ) ;
    public AS3_exParser.bindingDeclArg_return bindingDeclArg() // throws RecognitionException [1]
    {
        AS3_exParser.bindingDeclArg_return retval = new AS3_exParser.bindingDeclArg_return();
        retval.Start = input.LT(1);
        int bindingDeclArg_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        IToken E = null;
        AS3_exParser.stringLiteral_return stringLiteral82 = null;

        AS3_exParser.numericLiteral_return numericLiteral83 = null;

        AS3_exParser.eitherIdentifier_return eitherIdentifier84 = null;


        object I_tree = null;
        object E_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 42))
            {
                return retval;
            }
            // AS3_ex.g3:1596:2: ( (I= IDENTIFIER E= ASSIGN )? ( stringLiteral | numericLiteral | eitherIdentifier ) )
            // AS3_ex.g3:1603:5: (I= IDENTIFIER E= ASSIGN )? ( stringLiteral | numericLiteral | eitherIdentifier )
            {
                root_0 = (object)adaptor.GetNilNode();

                // AS3_ex.g3:1603:5: (I= IDENTIFIER E= ASSIGN )?
                int alt47 = 2;
                int LA47_0 = input.LA(1);

                if ((LA47_0 == IDENTIFIER))
                {
                    int LA47_1 = input.LA(2);

                    if ((LA47_1 == ASSIGN))
                    {
                        alt47 = 1;
                    }
                }
                switch (alt47)
                {
                    case 1:
                        // AS3_ex.g3:1603:6: I= IDENTIFIER E= ASSIGN
                        {
                            I = (IToken)Match(input, IDENTIFIER, FOLLOW_IDENTIFIER_in_bindingDeclArg6540); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                I_tree = (object)adaptor.Create(I);
                                adaptor.AddChild(root_0, I_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)I);
                            }
                            E = (IToken)Match(input, ASSIGN, FOLLOW_ASSIGN_in_bindingDeclArg6546); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                E_tree = (object)adaptor.Create(E);
                                adaptor.AddChild(root_0, E_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)E);
                            }

                        }
                        break;

                }

                // AS3_ex.g3:1604:2: ( stringLiteral | numericLiteral | eitherIdentifier )
                int alt48 = 3;
                switch (input.LA(1))
                {
                    case SINGLE_QUOTE_LITERAL:
                    case DOUBLE_QUOTE_LITERAL:
                        {
                            alt48 = 1;
                        }
                        break;
                    case HEX_NUMBER_LITERAL:
                    case DEC_NUMBER_LITERAL:
                        {
                            alt48 = 2;
                        }
                        break;
                    case AS:
                    case BREAK:
                    case CASE:
                    case CATCH:
                    case CLASS:
                    case CONST:
                    case CONTINUE:
                    case DEFAULT:
                    case DELETE:
                    case DO:
                    case ELSE:
                    case EXTENDS:
                    case FALSE:
                    case FINALLY:
                    case FOR:
                    case FUNCTION:
                    case IF:
                    case IMPLEMENTS:
                    case IMPORT:
                    case IN:
                    case INSTANCEOF:
                    case INTERFACE:
                    case INTERNAL:
                    case IS:
                    case NATIVE:
                    case NEW:
                    case NULL:
                    case PACKAGE:
                    case PRIVATE:
                    case PROTECTED:
                    case PUBLIC:
                    case RETURN:
                    case SUPER:
                    case SWITCH:
                    case THIS:
                    case THROW:
                    case TO:
                    case TRUE:
                    case TRY:
                    case TYPEOF:
                    case USE:
                    case VAR:
                    case VOID:
                    case WHILE:
                    case WITH:
                    case EACH:
                    case GET:
                    case SET:
                    case NAMESPACE:
                    case INCLUDE:
                    case DYNAMIC:
                    case FINAL:
                    case OVERRIDE:
                    case STATIC:
                    case STAR:
                    case XML_AT:
                    case IDENTIFIER:
                        {
                            alt48 = 3;
                        }
                        break;
                    default:
                        if (state.backtracking > 0) { state.failed = true; return retval; }
                        NoViableAltException nvae_d48s0 =
                            new NoViableAltException("", 48, 0, input);

                        throw nvae_d48s0;
                }

                switch (alt48)
                {
                    case 1:
                        // AS3_ex.g3:1605:3: stringLiteral
                        {
                            PushFollow(FOLLOW_stringLiteral_in_bindingDeclArg6559);
                            stringLiteral82 = stringLiteral();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, stringLiteral82.Tree);

                        }
                        break;
                    case 2:
                        // AS3_ex.g3:1605:19: numericLiteral
                        {
                            PushFollow(FOLLOW_numericLiteral_in_bindingDeclArg6563);
                            numericLiteral83 = numericLiteral();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, numericLiteral83.Tree);

                        }
                        break;
                    case 3:
                        // AS3_ex.g3:1605:36: eitherIdentifier
                        {
                            PushFollow(FOLLOW_eitherIdentifier_in_bindingDeclArg6567);
                            eitherIdentifier84 = eitherIdentifier();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, eitherIdentifier84.Tree);

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 42, bindingDeclArg_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "bindingDeclArg"

    public class interfaceDeclaration_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "interfaceDeclaration"
    // AS3_ex.g3:1612:1: interfaceDeclaration : i= INTERFACE type (e= EXTENDS typeList )? interfaceBody ;
    public AS3_exParser.interfaceDeclaration_return interfaceDeclaration() // throws RecognitionException [1]
    {
        AS3_exParser.interfaceDeclaration_return retval = new AS3_exParser.interfaceDeclaration_return();
        retval.Start = input.LT(1);
        int interfaceDeclaration_StartIndex = input.Index();
        object root_0 = null;

        IToken i = null;
        IToken e = null;
        AS3_exParser.type_return type85 = null;

        AS3_exParser.typeList_return typeList86 = null;

        AS3_exParser.interfaceBody_return interfaceBody87 = null;


        object i_tree = null;
        object e_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 43))
            {
                return retval;
            }
            // AS3_ex.g3:1613:2: (i= INTERFACE type (e= EXTENDS typeList )? interfaceBody )
            // AS3_ex.g3:1613:6: i= INTERFACE type (e= EXTENDS typeList )? interfaceBody
            {
                root_0 = (object)adaptor.GetNilNode();

                i = (IToken)Match(input, INTERFACE, FOLLOW_INTERFACE_in_interfaceDeclaration6589); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    i_tree = (object)adaptor.Create(i);
                    adaptor.AddChild(root_0, i_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)i);
                }
                PushFollow(FOLLOW_type_in_interfaceDeclaration6593);
                type85 = type();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, type85.Tree);
                // AS3_ex.g3:1613:48: (e= EXTENDS typeList )?
                int alt49 = 2;
                int LA49_0 = input.LA(1);

                if ((LA49_0 == EXTENDS))
                {
                    alt49 = 1;
                }
                switch (alt49)
                {
                    case 1:
                        // AS3_ex.g3:1613:49: e= EXTENDS typeList
                        {
                            e = (IToken)Match(input, EXTENDS, FOLLOW_EXTENDS_in_interfaceDeclaration6598); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                e_tree = (object)adaptor.Create(e);
                                adaptor.AddChild(root_0, e_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)e);
                            }
                            PushFollow(FOLLOW_typeList_in_interfaceDeclaration6602);
                            typeList86 = typeList();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, typeList86.Tree);

                        }
                        break;

                }

                if (state.backtracking == 0)
                {
                    PopIndent();
                }
                PushFollow(FOLLOW_interfaceBody_in_interfaceDeclaration6616);
                interfaceBody87 = interfaceBody();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, interfaceBody87.Tree);

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 43, interfaceDeclaration_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "interfaceDeclaration"

    public class interfaceBody_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "interfaceBody"
    // AS3_ex.g3:1617:1: interfaceBody : l= LCURLY ( interfaceElement )* r= RCURLY ;
    public AS3_exParser.interfaceBody_return interfaceBody() // throws RecognitionException [1]
    {
        AS3_exParser.interfaceBody_return retval = new AS3_exParser.interfaceBody_return();
        retval.Start = input.LT(1);
        int interfaceBody_StartIndex = input.Index();
        object root_0 = null;

        IToken l = null;
        IToken r = null;
        AS3_exParser.interfaceElement_return interfaceElement88 = null;


        object l_tree = null;
        object r_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 44))
            {
                return retval;
            }
            // AS3_ex.g3:1618:2: (l= LCURLY ( interfaceElement )* r= RCURLY )
            // AS3_ex.g3:1618:6: l= LCURLY ( interfaceElement )* r= RCURLY
            {
                root_0 = (object)adaptor.GetNilNode();

                l = (IToken)Match(input, LCURLY, FOLLOW_LCURLY_in_interfaceBody6632); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    l_tree = (object)adaptor.Create(l);
                    adaptor.AddChild(root_0, l_tree);
                }
                if (state.backtracking == 0)
                {

                    LeftCurlyNewlineHandler(false);
                    Emit((CommonToken)l); PushIndent(true);

                }
                // AS3_ex.g3:1623:6: ( interfaceElement )*
                do
                {
                    int alt50 = 2;
                    int LA50_0 = input.LA(1);

                    if (((LA50_0 >= AS && LA50_0 <= LCURLY) || LA50_0 == LPAREN || LA50_0 == LBRACK || LA50_0 == LT || (LA50_0 >= PLUS && LA50_0 <= STAR) || (LA50_0 >= INC && LA50_0 <= DEC) || (LA50_0 >= NOT && LA50_0 <= INV) || (LA50_0 >= XML_AT && LA50_0 <= XML_LS_STD) || (LA50_0 >= SINGLE_QUOTE_LITERAL && LA50_0 <= DOUBLE_QUOTE_LITERAL) || LA50_0 == REGULAR_EXPR_LITERAL || LA50_0 == HEX_NUMBER_LITERAL || LA50_0 == DEC_NUMBER_LITERAL || LA50_0 == IDENTIFIER || (LA50_0 >= XML_COMMENT && LA50_0 <= XML_PI)))
                    {
                        alt50 = 1;
                    }


                    switch (alt50)
                    {
                        case 1:
                            // AS3_ex.g3:0:0: interfaceElement
                            {
                                PushFollow(FOLLOW_interfaceElement_in_interfaceBody6648);
                                interfaceElement88 = interfaceElement();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, interfaceElement88.Tree);

                            }
                            break;

                        default:
                            goto loop50;
                    }
                } while (true);

            loop50:
                ;	// Stops C# compiler whining that label 'loop50' has no statements

                if (state.backtracking == 0)
                {
                    PopIndent();
                }
                r = (IToken)Match(input, RCURLY, FOLLOW_RCURLY_in_interfaceBody6667); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    r_tree = (object)adaptor.Create(r);
                    adaptor.AddChild(root_0, r_tree);
                }
                if (state.backtracking == 0)
                {
                    InsertCR(false); Emit((CommonToken)r);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 44, interfaceBody_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "interfaceBody"

    public class classDeclaration_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "classDeclaration"
    // AS3_ex.g3:1628:1: classDeclaration : c= CLASS type (E= EXTENDS type )? (I= IMPLEMENTS typeList )? classBody ;
    public AS3_exParser.classDeclaration_return classDeclaration() // throws RecognitionException [1]
    {
        AS3_exParser.classDeclaration_return retval = new AS3_exParser.classDeclaration_return();
        retval.Start = input.LT(1);
        int classDeclaration_StartIndex = input.Index();
        object root_0 = null;

        IToken c = null;
        IToken E = null;
        IToken I = null;
        AS3_exParser.type_return type89 = null;

        AS3_exParser.type_return type90 = null;

        AS3_exParser.typeList_return typeList91 = null;

        AS3_exParser.classBody_return classBody92 = null;


        object c_tree = null;
        object E_tree = null;
        object I_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 45))
            {
                return retval;
            }
            // AS3_ex.g3:1629:2: (c= CLASS type (E= EXTENDS type )? (I= IMPLEMENTS typeList )? classBody )
            // AS3_ex.g3:1629:6: c= CLASS type (E= EXTENDS type )? (I= IMPLEMENTS typeList )? classBody
            {
                root_0 = (object)adaptor.GetNilNode();

                c = (IToken)Match(input, CLASS, FOLLOW_CLASS_in_classDeclaration6685); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    c_tree = (object)adaptor.Create(c);
                    adaptor.AddChild(root_0, c_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)c);
                }
                PushFollow(FOLLOW_type_in_classDeclaration6689);
                type89 = type();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, type89.Tree);
                // AS3_ex.g3:1629:44: (E= EXTENDS type )?
                int alt51 = 2;
                int LA51_0 = input.LA(1);

                if ((LA51_0 == EXTENDS))
                {
                    alt51 = 1;
                }
                switch (alt51)
                {
                    case 1:
                        // AS3_ex.g3:1629:46: E= EXTENDS type
                        {
                            E = (IToken)Match(input, EXTENDS, FOLLOW_EXTENDS_in_classDeclaration6695); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                E_tree = (object)adaptor.Create(E);
                                adaptor.AddChild(root_0, E_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)E);
                            }
                            PushFollow(FOLLOW_type_in_classDeclaration6699);
                            type90 = type();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, type90.Tree);

                        }
                        break;

                }

                // AS3_ex.g3:1629:88: (I= IMPLEMENTS typeList )?
                int alt52 = 2;
                int LA52_0 = input.LA(1);

                if ((LA52_0 == IMPLEMENTS))
                {
                    alt52 = 1;
                }
                switch (alt52)
                {
                    case 1:
                        // AS3_ex.g3:1629:90: I= IMPLEMENTS typeList
                        {
                            I = (IToken)Match(input, IMPLEMENTS, FOLLOW_IMPLEMENTS_in_classDeclaration6707); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                I_tree = (object)adaptor.Create(I);
                                adaptor.AddChild(root_0, I_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)I);
                            }
                            PushFollow(FOLLOW_typeList_in_classDeclaration6711);
                            typeList91 = typeList();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, typeList91.Tree);

                        }
                        break;

                }

                if (state.backtracking == 0)
                {
                    PopIndent();
                }
                PushFollow(FOLLOW_classBody_in_classDeclaration6725);
                classBody92 = classBody();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, classBody92.Tree);

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 45, classDeclaration_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "classDeclaration"

    public class classBody_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "classBody"
    // AS3_ex.g3:1635:1: classBody : L= LCURLY ( classBodyElement )* R= RCURLY ;
    public AS3_exParser.classBody_return classBody() // throws RecognitionException [1]
    {
        AS3_exParser.classBody_return retval = new AS3_exParser.classBody_return();
        retval.Start = input.LT(1);
        int classBody_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        AS3_exParser.classBodyElement_return classBodyElement93 = null;


        object L_tree = null;
        object R_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 46))
            {
                return retval;
            }
            // AS3_ex.g3:1636:2: (L= LCURLY ( classBodyElement )* R= RCURLY )
            // AS3_ex.g3:1636:6: L= LCURLY ( classBodyElement )* R= RCURLY
            {
                root_0 = (object)adaptor.GetNilNode();

                L = (IToken)Match(input, LCURLY, FOLLOW_LCURLY_in_classBody6754); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if (state.backtracking == 0)
                {

                    LeftCurlyNewlineHandler(false);
                    Emit((CommonToken)L); PushIndent(true);

                }
                // AS3_ex.g3:1641:3: ( classBodyElement )*
                do
                {
                    int alt53 = 2;
                    int LA53_0 = input.LA(1);

                    if (((LA53_0 >= AS && LA53_0 <= LCURLY) || LA53_0 == LPAREN || LA53_0 == LBRACK || LA53_0 == LT || (LA53_0 >= PLUS && LA53_0 <= STAR) || (LA53_0 >= INC && LA53_0 <= DEC) || (LA53_0 >= NOT && LA53_0 <= INV) || (LA53_0 >= XML_AT && LA53_0 <= XML_LS_STD) || (LA53_0 >= SINGLE_QUOTE_LITERAL && LA53_0 <= DOUBLE_QUOTE_LITERAL) || LA53_0 == REGULAR_EXPR_LITERAL || LA53_0 == HEX_NUMBER_LITERAL || LA53_0 == DEC_NUMBER_LITERAL || LA53_0 == IDENTIFIER || (LA53_0 >= XML_COMMENT && LA53_0 <= XML_PI)))
                    {
                        alt53 = 1;
                    }


                    switch (alt53)
                    {
                        case 1:
                            // AS3_ex.g3:0:0: classBodyElement
                            {
                                PushFollow(FOLLOW_classBodyElement_in_classBody6764);
                                classBodyElement93 = classBodyElement();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, classBodyElement93.Tree);

                            }
                            break;

                        default:
                            goto loop53;
                    }
                } while (true);

            loop53:
                ;	// Stops C# compiler whining that label 'loop53' has no statements

                if (state.backtracking == 0)
                {
                    PopIndent();
                }
                R = (IToken)Match(input, RCURLY, FOLLOW_RCURLY_in_classBody6777); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if (state.backtracking == 0)
                {
                    InsertCR(false); Emit((CommonToken)R);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 46, classBody_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "classBody"

    public class classBodyElement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "classBodyElement"
    // AS3_ex.g3:1650:1: classBodyElement : ( propertyDeclaration | functionDeclaration | statement | directive );
    public AS3_exParser.classBodyElement_return classBodyElement() // throws RecognitionException [1]
    {
        AS3_exParser.classBodyElement_return retval = new AS3_exParser.classBodyElement_return();
        retval.Start = input.LT(1);
        int classBodyElement_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.propertyDeclaration_return propertyDeclaration94 = null;

        AS3_exParser.functionDeclaration_return functionDeclaration95 = null;

        AS3_exParser.statement_return statement96 = null;

        AS3_exParser.directive_return directive97 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 47))
            {
                return retval;
            }
            // AS3_ex.g3:1651:5: ( propertyDeclaration | functionDeclaration | statement | directive )
            int alt54 = 4;
            alt54 = dfa54.Predict(input);
            switch (alt54)
            {
                case 1:
                    // AS3_ex.g3:1651:9: propertyDeclaration
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_propertyDeclaration_in_classBodyElement6801);
                        propertyDeclaration94 = propertyDeclaration();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, propertyDeclaration94.Tree);

                    }
                    break;
                case 2:
                    // AS3_ex.g3:1651:31: functionDeclaration
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_functionDeclaration_in_classBodyElement6805);
                        functionDeclaration95 = functionDeclaration();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, functionDeclaration95.Tree);

                    }
                    break;
                case 3:
                    // AS3_ex.g3:1651:53: statement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_statement_in_classBodyElement6809);
                        statement96 = statement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, statement96.Tree);

                    }
                    break;
                case 4:
                    // AS3_ex.g3:1651:65: directive
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_directive_in_classBodyElement6813);
                        directive97 = directive();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, directive97.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 47, classBodyElement_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "classBodyElement"

    public class interfaceElement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "interfaceElement"
    // AS3_ex.g3:1654:1: interfaceElement : ( propertyDeclaration | interfaceFunctionDeclaration | statement | directive );
    public AS3_exParser.interfaceElement_return interfaceElement() // throws RecognitionException [1]
    {
        AS3_exParser.interfaceElement_return retval = new AS3_exParser.interfaceElement_return();
        retval.Start = input.LT(1);
        int interfaceElement_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.propertyDeclaration_return propertyDeclaration98 = null;

        AS3_exParser.interfaceFunctionDeclaration_return interfaceFunctionDeclaration99 = null;

        AS3_exParser.statement_return statement100 = null;

        AS3_exParser.directive_return directive101 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 48))
            {
                return retval;
            }
            // AS3_ex.g3:1655:5: ( propertyDeclaration | interfaceFunctionDeclaration | statement | directive )
            int alt55 = 4;
            alt55 = dfa55.Predict(input);
            switch (alt55)
            {
                case 1:
                    // AS3_ex.g3:1655:9: propertyDeclaration
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_propertyDeclaration_in_interfaceElement6830);
                        propertyDeclaration98 = propertyDeclaration();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, propertyDeclaration98.Tree);

                    }
                    break;
                case 2:
                    // AS3_ex.g3:1655:31: interfaceFunctionDeclaration
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_interfaceFunctionDeclaration_in_interfaceElement6834);
                        interfaceFunctionDeclaration99 = interfaceFunctionDeclaration();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, interfaceFunctionDeclaration99.Tree);

                    }
                    break;
                case 3:
                    // AS3_ex.g3:1655:62: statement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_statement_in_interfaceElement6838);
                        statement100 = statement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, statement100.Tree);

                    }
                    break;
                case 4:
                    // AS3_ex.g3:1655:73: directive
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_directive_in_interfaceElement6841);
                        directive101 = directive();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, directive101.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 48, interfaceElement_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "interfaceElement"

    public class interfaceFunctionDeclaration_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "interfaceFunctionDeclaration"
    // AS3_ex.g3:1664:1: interfaceFunctionDeclaration : ( conditionalDirAndBindingDecls )? ( memberModifiers )? F= FUNCTION (S= SET | G= GET )? (I= IDENTIFIER | notQuiteReservedWord ) formalParameterList (C= COLON type )? semic ;
    public AS3_exParser.interfaceFunctionDeclaration_return interfaceFunctionDeclaration() // throws RecognitionException [1]
    {
        AS3_exParser.interfaceFunctionDeclaration_return retval = new AS3_exParser.interfaceFunctionDeclaration_return();
        retval.Start = input.LT(1);
        int interfaceFunctionDeclaration_StartIndex = input.Index();
        object root_0 = null;

        IToken F = null;
        IToken S = null;
        IToken G = null;
        IToken I = null;
        IToken C = null;
        AS3_exParser.conditionalDirAndBindingDecls_return conditionalDirAndBindingDecls102 = null;

        AS3_exParser.memberModifiers_return memberModifiers103 = null;

        AS3_exParser.notQuiteReservedWord_return notQuiteReservedWord104 = null;

        AS3_exParser.formalParameterList_return formalParameterList105 = null;

        AS3_exParser.type_return type106 = null;

        AS3_exParser.semic_return semic107 = null;


        object F_tree = null;
        object S_tree = null;
        object G_tree = null;
        object I_tree = null;
        object C_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 49))
            {
                return retval;
            }
            // AS3_ex.g3:1665:5: ( ( conditionalDirAndBindingDecls )? ( memberModifiers )? F= FUNCTION (S= SET | G= GET )? (I= IDENTIFIER | notQuiteReservedWord ) formalParameterList (C= COLON type )? semic )
            // AS3_ex.g3:1665:10: ( conditionalDirAndBindingDecls )? ( memberModifiers )? F= FUNCTION (S= SET | G= GET )? (I= IDENTIFIER | notQuiteReservedWord ) formalParameterList (C= COLON type )? semic
            {
                root_0 = (object)adaptor.GetNilNode();

                // AS3_ex.g3:1665:10: ( conditionalDirAndBindingDecls )?
                int alt56 = 2;
                switch (input.LA(1))
                {
                    case IDENTIFIER:
                        {
                            int LA56_1 = input.LA(2);

                            if ((LA56_1 == XML_NS_OP))
                            {
                                alt56 = 1;
                            }
                        }
                        break;
                    case NATIVE:
                    case DYNAMIC:
                    case FINAL:
                    case OVERRIDE:
                    case STATIC:
                        {
                            int LA56_2 = input.LA(2);

                            if ((LA56_2 == XML_NS_OP))
                            {
                                alt56 = 1;
                            }
                        }
                        break;
                    case TO:
                    case EACH:
                    case GET:
                    case SET:
                    case NAMESPACE:
                        {
                            alt56 = 1;
                        }
                        break;
                }

                switch (alt56)
                {
                    case 1:
                        // AS3_ex.g3:1665:11: conditionalDirAndBindingDecls
                        {
                            PushFollow(FOLLOW_conditionalDirAndBindingDecls_in_interfaceFunctionDeclaration6871);
                            conditionalDirAndBindingDecls102 = conditionalDirAndBindingDecls();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, conditionalDirAndBindingDecls102.Tree);

                        }
                        break;

                }

                if (state.backtracking == 0)
                {
                    InsertCR(false);
                }
                // AS3_ex.g3:1665:62: ( memberModifiers )?
                int alt57 = 2;
                int LA57_0 = input.LA(1);

                if ((LA57_0 == INTERNAL || LA57_0 == NATIVE || (LA57_0 >= PRIVATE && LA57_0 <= PUBLIC) || (LA57_0 >= DYNAMIC && LA57_0 <= STATIC) || LA57_0 == IDENTIFIER))
                {
                    alt57 = 1;
                }
                switch (alt57)
                {
                    case 1:
                        // AS3_ex.g3:0:0: memberModifiers
                        {
                            PushFollow(FOLLOW_memberModifiers_in_interfaceFunctionDeclaration6877);
                            memberModifiers103 = memberModifiers();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, memberModifiers103.Tree);

                        }
                        break;

                }

                F = (IToken)Match(input, FUNCTION, FOLLOW_FUNCTION_in_interfaceFunctionDeclaration6882); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    F_tree = (object)adaptor.Create(F);
                    adaptor.AddChild(root_0, F_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)F);
                }
                // AS3_ex.g3:1667:5: (S= SET | G= GET )?
                int alt58 = 3;
                int LA58_0 = input.LA(1);

                if ((LA58_0 == SET))
                {
                    int LA58_1 = input.LA(2);

                    if ((LA58_1 == NATIVE || LA58_1 == TO || (LA58_1 >= EACH && LA58_1 <= NAMESPACE) || (LA58_1 >= DYNAMIC && LA58_1 <= STATIC) || LA58_1 == IDENTIFIER))
                    {
                        alt58 = 1;
                    }
                }
                else if ((LA58_0 == GET))
                {
                    int LA58_2 = input.LA(2);

                    if ((LA58_2 == NATIVE || LA58_2 == TO || (LA58_2 >= EACH && LA58_2 <= NAMESPACE) || (LA58_2 >= DYNAMIC && LA58_2 <= STATIC) || LA58_2 == IDENTIFIER))
                    {
                        alt58 = 2;
                    }
                }
                switch (alt58)
                {
                    case 1:
                        // AS3_ex.g3:1667:6: S= SET
                        {
                            S = (IToken)Match(input, SET, FOLLOW_SET_in_interfaceFunctionDeclaration6901); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                S_tree = (object)adaptor.Create(S);
                                adaptor.AddChild(root_0, S_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)S);
                            }

                        }
                        break;
                    case 2:
                        // AS3_ex.g3:1667:38: G= GET
                        {
                            G = (IToken)Match(input, GET, FOLLOW_GET_in_interfaceFunctionDeclaration6908); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                G_tree = (object)adaptor.Create(G);
                                adaptor.AddChild(root_0, G_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)G);
                            }

                        }
                        break;

                }

                // AS3_ex.g3:1668:5: (I= IDENTIFIER | notQuiteReservedWord )
                int alt59 = 2;
                int LA59_0 = input.LA(1);

                if ((LA59_0 == IDENTIFIER))
                {
                    alt59 = 1;
                }
                else if ((LA59_0 == NATIVE || LA59_0 == TO || (LA59_0 >= EACH && LA59_0 <= NAMESPACE) || (LA59_0 >= DYNAMIC && LA59_0 <= STATIC)))
                {
                    alt59 = 2;
                }
                else
                {
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    NoViableAltException nvae_d59s0 =
                        new NoViableAltException("", 59, 0, input);

                    throw nvae_d59s0;
                }
                switch (alt59)
                {
                    case 1:
                        // AS3_ex.g3:1668:6: I= IDENTIFIER
                        {
                            I = (IToken)Match(input, IDENTIFIER, FOLLOW_IDENTIFIER_in_interfaceFunctionDeclaration6922); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                I_tree = (object)adaptor.Create(I);
                                adaptor.AddChild(root_0, I_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)I);
                            }

                        }
                        break;
                    case 2:
                        // AS3_ex.g3:1668:46: notQuiteReservedWord
                        {
                            PushFollow(FOLLOW_notQuiteReservedWord_in_interfaceFunctionDeclaration6928);
                            notQuiteReservedWord104 = notQuiteReservedWord();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, notQuiteReservedWord104.Tree);

                        }
                        break;

                }

                PushFollow(FOLLOW_formalParameterList_in_interfaceFunctionDeclaration6931);
                formalParameterList105 = formalParameterList();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, formalParameterList105.Tree);
                // AS3_ex.g3:1668:88: (C= COLON type )?
                int alt60 = 2;
                int LA60_0 = input.LA(1);

                if ((LA60_0 == COLON))
                {
                    alt60 = 1;
                }
                switch (alt60)
                {
                    case 1:
                        // AS3_ex.g3:1668:89: C= COLON type
                        {
                            C = (IToken)Match(input, COLON, FOLLOW_COLON_in_interfaceFunctionDeclaration6936); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                C_tree = (object)adaptor.Create(C);
                                adaptor.AddChild(root_0, C_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                InsertWS(mPrinter.GetAdvancedSpacesBeforeColons()); Emit((CommonToken)C); InsertWS(mPrinter.GetAdvancedSpacesAfterColons());
                            }
                            PushFollow(FOLLOW_type_in_interfaceFunctionDeclaration6940);
                            type106 = type();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, type106.Tree);

                        }
                        break;

                }

                PushFollow(FOLLOW_semic_in_interfaceFunctionDeclaration6944);
                semic107 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, semic107.Tree);

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 49, interfaceFunctionDeclaration_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "interfaceFunctionDeclaration"

    public class propertyDeclaration_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "propertyDeclaration"
    // AS3_ex.g3:1675:1: propertyDeclaration : ( conditionalDirAndBindingDecls )? ( memberModifiers )? ( variableStatement | constantVarStatement | namespaceDirective ) ;
    public AS3_exParser.propertyDeclaration_return propertyDeclaration() // throws RecognitionException [1]
    {
        AS3_exParser.propertyDeclaration_return retval = new AS3_exParser.propertyDeclaration_return();
        retval.Start = input.LT(1);
        int propertyDeclaration_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.conditionalDirAndBindingDecls_return conditionalDirAndBindingDecls108 = null;

        AS3_exParser.memberModifiers_return memberModifiers109 = null;

        AS3_exParser.variableStatement_return variableStatement110 = null;

        AS3_exParser.constantVarStatement_return constantVarStatement111 = null;

        AS3_exParser.namespaceDirective_return namespaceDirective112 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 50))
            {
                return retval;
            }
            // AS3_ex.g3:1676:2: ( ( conditionalDirAndBindingDecls )? ( memberModifiers )? ( variableStatement | constantVarStatement | namespaceDirective ) )
            // AS3_ex.g3:1676:7: ( conditionalDirAndBindingDecls )? ( memberModifiers )? ( variableStatement | constantVarStatement | namespaceDirective )
            {
                root_0 = (object)adaptor.GetNilNode();

                if (state.backtracking == 0)
                {
                    InsertLines(mPrinter.GetBlankLinesBeforeProperties());
                }
                // AS3_ex.g3:1676:64: ( conditionalDirAndBindingDecls )?
                int alt61 = 2;
                switch (input.LA(1))
                {
                    case IDENTIFIER:
                        {
                            int LA61_1 = input.LA(2);

                            if ((LA61_1 == XML_NS_OP))
                            {
                                alt61 = 1;
                            }
                        }
                        break;
                    case NATIVE:
                    case DYNAMIC:
                    case FINAL:
                    case OVERRIDE:
                    case STATIC:
                        {
                            int LA61_2 = input.LA(2);

                            if ((LA61_2 == XML_NS_OP))
                            {
                                alt61 = 1;
                            }
                        }
                        break;
                    case NAMESPACE:
                        {
                            int LA61_3 = input.LA(2);

                            if ((LA61_3 == XML_NS_OP))
                            {
                                alt61 = 1;
                            }
                        }
                        break;
                    case TO:
                    case EACH:
                    case GET:
                    case SET:
                        {
                            alt61 = 1;
                        }
                        break;
                }

                switch (alt61)
                {
                    case 1:
                        // AS3_ex.g3:1676:65: conditionalDirAndBindingDecls
                        {
                            PushFollow(FOLLOW_conditionalDirAndBindingDecls_in_propertyDeclaration6968);
                            conditionalDirAndBindingDecls108 = conditionalDirAndBindingDecls();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, conditionalDirAndBindingDecls108.Tree);

                        }
                        break;

                }

                if (state.backtracking == 0)
                {
                    InsertCR(false);
                }
                if (state.backtracking == 0)
                {
                    PushLazyIndent();
                }
                // AS3_ex.g3:1676:135: ( memberModifiers )?
                int alt62 = 2;
                int LA62_0 = input.LA(1);

                if ((LA62_0 == IDENTIFIER))
                {
                    int LA62_1 = input.LA(2);

                    if ((synpred144_AS3_ex()))
                    {
                        alt62 = 1;
                    }
                }
                else if ((LA62_0 == INTERNAL || LA62_0 == NATIVE || (LA62_0 >= PRIVATE && LA62_0 <= PUBLIC) || (LA62_0 >= DYNAMIC && LA62_0 <= STATIC)))
                {
                    alt62 = 1;
                }
                switch (alt62)
                {
                    case 1:
                        // AS3_ex.g3:0:0: memberModifiers
                        {
                            PushFollow(FOLLOW_memberModifiers_in_propertyDeclaration6975);
                            memberModifiers109 = memberModifiers();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, memberModifiers109.Tree);

                        }
                        break;

                }

                // AS3_ex.g3:1676:152: ( variableStatement | constantVarStatement | namespaceDirective )
                int alt63 = 3;
                switch (input.LA(1))
                {
                    case VAR:
                    case IDENTIFIER:
                        {
                            alt63 = 1;
                        }
                        break;
                    case CONST:
                        {
                            alt63 = 2;
                        }
                        break;
                    case NAMESPACE:
                        {
                            alt63 = 3;
                        }
                        break;
                    default:
                        if (state.backtracking > 0) { state.failed = true; return retval; }
                        NoViableAltException nvae_d63s0 =
                            new NoViableAltException("", 63, 0, input);

                        throw nvae_d63s0;
                }

                switch (alt63)
                {
                    case 1:
                        // AS3_ex.g3:1676:153: variableStatement
                        {
                            PushFollow(FOLLOW_variableStatement_in_propertyDeclaration6979);
                            variableStatement110 = variableStatement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, variableStatement110.Tree);

                        }
                        break;
                    case 2:
                        // AS3_ex.g3:1676:173: constantVarStatement
                        {
                            PushFollow(FOLLOW_constantVarStatement_in_propertyDeclaration6983);
                            constantVarStatement111 = constantVarStatement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, constantVarStatement111.Tree);

                        }
                        break;
                    case 3:
                        // AS3_ex.g3:1676:196: namespaceDirective
                        {
                            PushFollow(FOLLOW_namespaceDirective_in_propertyDeclaration6987);
                            namespaceDirective112 = namespaceDirective();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, namespaceDirective112.Tree);

                        }
                        break;

                }

                if (state.backtracking == 0)
                {
                    PopIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 50, propertyDeclaration_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "propertyDeclaration"

    public class functionDeclaration_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "functionDeclaration"
    // AS3_ex.g3:1683:1: functionDeclaration : ( conditionalDirAndBindingDecls )? ( memberModifiers )? F= FUNCTION (funcType= ( SET | GET ) )? (I= IDENTIFIER | notQuiteReservedWord ) formalParameterList (C= COLON type )? functionBody ;
    public AS3_exParser.functionDeclaration_return functionDeclaration() // throws RecognitionException [1]
    {
        AS3_exParser.functionDeclaration_return retval = new AS3_exParser.functionDeclaration_return();
        retval.Start = input.LT(1);
        int functionDeclaration_StartIndex = input.Index();
        object root_0 = null;

        IToken F = null;
        IToken funcType = null;
        IToken I = null;
        IToken C = null;
        AS3_exParser.conditionalDirAndBindingDecls_return conditionalDirAndBindingDecls113 = null;

        AS3_exParser.memberModifiers_return memberModifiers114 = null;

        AS3_exParser.notQuiteReservedWord_return notQuiteReservedWord115 = null;

        AS3_exParser.formalParameterList_return formalParameterList116 = null;

        AS3_exParser.type_return type117 = null;

        AS3_exParser.functionBody_return functionBody118 = null;


        object F_tree = null;
        //object funcType_tree = null;
        object I_tree = null;
        object C_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 51))
            {
                return retval;
            }
            // AS3_ex.g3:1684:5: ( ( conditionalDirAndBindingDecls )? ( memberModifiers )? F= FUNCTION (funcType= ( SET | GET ) )? (I= IDENTIFIER | notQuiteReservedWord ) formalParameterList (C= COLON type )? functionBody )
            // AS3_ex.g3:1684:10: ( conditionalDirAndBindingDecls )? ( memberModifiers )? F= FUNCTION (funcType= ( SET | GET ) )? (I= IDENTIFIER | notQuiteReservedWord ) formalParameterList (C= COLON type )? functionBody
            {
                root_0 = (object)adaptor.GetNilNode();

                // AS3_ex.g3:1684:10: ( conditionalDirAndBindingDecls )?
                int alt64 = 2;
                switch (input.LA(1))
                {
                    case IDENTIFIER:
                        {
                            int LA64_1 = input.LA(2);

                            if ((LA64_1 == XML_NS_OP))
                            {
                                alt64 = 1;
                            }
                        }
                        break;
                    case NATIVE:
                    case DYNAMIC:
                    case FINAL:
                    case OVERRIDE:
                    case STATIC:
                        {
                            int LA64_2 = input.LA(2);

                            if ((LA64_2 == XML_NS_OP))
                            {
                                alt64 = 1;
                            }
                        }
                        break;
                    case TO:
                    case EACH:
                    case GET:
                    case SET:
                    case NAMESPACE:
                        {
                            alt64 = 1;
                        }
                        break;
                }

                switch (alt64)
                {
                    case 1:
                        // AS3_ex.g3:1684:11: conditionalDirAndBindingDecls
                        {
                            PushFollow(FOLLOW_conditionalDirAndBindingDecls_in_functionDeclaration7012);
                            conditionalDirAndBindingDecls113 = conditionalDirAndBindingDecls();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, conditionalDirAndBindingDecls113.Tree);

                        }
                        break;

                }

                if (state.backtracking == 0)
                {
                    PushLazyIndent();
                }
                if (state.backtracking == 0)
                {
                    InsertCR(false); InsertLines(mPrinter.GetBlankLinesBeforeFunction());
                }
                // AS3_ex.g3:1684:133: ( memberModifiers )?
                int alt65 = 2;
                int LA65_0 = input.LA(1);

                if ((LA65_0 == INTERNAL || LA65_0 == NATIVE || (LA65_0 >= PRIVATE && LA65_0 <= PUBLIC) || (LA65_0 >= DYNAMIC && LA65_0 <= STATIC) || LA65_0 == IDENTIFIER))
                {
                    alt65 = 1;
                }
                switch (alt65)
                {
                    case 1:
                        // AS3_ex.g3:0:0: memberModifiers
                        {
                            PushFollow(FOLLOW_memberModifiers_in_functionDeclaration7019);
                            memberModifiers114 = memberModifiers();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, memberModifiers114.Tree);

                        }
                        break;

                }

                F = (IToken)Match(input, FUNCTION, FOLLOW_FUNCTION_in_functionDeclaration7024); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    F_tree = (object)adaptor.Create(F);
                    adaptor.AddChild(root_0, F_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)F);
                }
                // AS3_ex.g3:1685:5: (funcType= ( SET | GET ) )?
                int alt66 = 2;
                int LA66_0 = input.LA(1);

                if (((LA66_0 >= GET && LA66_0 <= SET)))
                {
                    int LA66_1 = input.LA(2);

                    if ((LA66_1 == NATIVE || LA66_1 == TO || (LA66_1 >= EACH && LA66_1 <= NAMESPACE) || (LA66_1 >= DYNAMIC && LA66_1 <= STATIC) || LA66_1 == IDENTIFIER))
                    {
                        alt66 = 1;
                    }
                }
                switch (alt66)
                {
                    case 1:
                        // AS3_ex.g3:1685:6: funcType= ( SET | GET )
                        {
                            funcType = (IToken)input.LT(1);
                            if ((input.LA(1) >= GET && input.LA(1) <= SET))
                            {
                                input.Consume();
                                if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(funcType));
                                state.errorRecovery = false; state.failed = false;
                            }
                            else
                            {
                                if (state.backtracking > 0) { state.failed = true; return retval; }
                                MismatchedSetException mse = new MismatchedSetException(null, input);
                                throw mse;
                            }

                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)funcType);
                            }

                        }
                        break;

                }

                // AS3_ex.g3:1686:5: (I= IDENTIFIER | notQuiteReservedWord )
                int alt67 = 2;
                int LA67_0 = input.LA(1);

                if ((LA67_0 == IDENTIFIER))
                {
                    alt67 = 1;
                }
                else if ((LA67_0 == NATIVE || LA67_0 == TO || (LA67_0 >= EACH && LA67_0 <= NAMESPACE) || (LA67_0 >= DYNAMIC && LA67_0 <= STATIC)))
                {
                    alt67 = 2;
                }
                else
                {
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    NoViableAltException nvae_d67s0 =
                        new NoViableAltException("", 67, 0, input);

                    throw nvae_d67s0;
                }
                switch (alt67)
                {
                    case 1:
                        // AS3_ex.g3:1686:6: I= IDENTIFIER
                        {
                            I = (IToken)Match(input, IDENTIFIER, FOLLOW_IDENTIFIER_in_functionDeclaration7053); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                I_tree = (object)adaptor.Create(I);
                                adaptor.AddChild(root_0, I_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)I);
                            }

                        }
                        break;
                    case 2:
                        // AS3_ex.g3:1686:46: notQuiteReservedWord
                        {
                            PushFollow(FOLLOW_notQuiteReservedWord_in_functionDeclaration7059);
                            notQuiteReservedWord115 = notQuiteReservedWord();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, notQuiteReservedWord115.Tree);

                        }
                        break;

                }

                PushFollow(FOLLOW_formalParameterList_in_functionDeclaration7062);
                formalParameterList116 = formalParameterList();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, formalParameterList116.Tree);
                // AS3_ex.g3:1686:88: (C= COLON type )?
                int alt68 = 2;
                int LA68_0 = input.LA(1);

                if ((LA68_0 == COLON))
                {
                    alt68 = 1;
                }
                switch (alt68)
                {
                    case 1:
                        // AS3_ex.g3:1686:89: C= COLON type
                        {
                            C = (IToken)Match(input, COLON, FOLLOW_COLON_in_functionDeclaration7067); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                C_tree = (object)adaptor.Create(C);
                                adaptor.AddChild(root_0, C_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                InsertWS(mPrinter.GetAdvancedSpacesBeforeColons()); Emit((CommonToken)C); InsertWS(mPrinter.GetAdvancedSpacesAfterColons());
                            }
                            PushFollow(FOLLOW_type_in_functionDeclaration7071);
                            type117 = type();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, type117.Tree);

                        }
                        break;

                }

                if (state.backtracking == 0)
                {
                    PopIndent();
                }
                PushFollow(FOLLOW_functionBody_in_functionDeclaration7077);
                functionBody118 = functionBody();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, functionBody118.Tree);

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 51, functionDeclaration_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "functionDeclaration"

    public class functionExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "functionExpression"
    // AS3_ex.g3:1689:1: functionExpression : F= FUNCTION (I= IDENTIFIER )? formalParameterList (C= COLON type )? functionBody ;
    public AS3_exParser.functionExpression_return functionExpression() // throws RecognitionException [1]
    {
        AS3_exParser.functionExpression_return retval = new AS3_exParser.functionExpression_return();
        retval.Start = input.LT(1);
        int functionExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken F = null;
        IToken I = null;
        IToken C = null;
        AS3_exParser.formalParameterList_return formalParameterList119 = null;

        AS3_exParser.type_return type120 = null;

        AS3_exParser.functionBody_return functionBody121 = null;


        object F_tree = null;
        object I_tree = null;
        object C_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 52))
            {
                return retval;
            }
            // AS3_ex.g3:1692:5: (F= FUNCTION (I= IDENTIFIER )? formalParameterList (C= COLON type )? functionBody )
            // AS3_ex.g3:1692:9: F= FUNCTION (I= IDENTIFIER )? formalParameterList (C= COLON type )? functionBody
            {
                root_0 = (object)adaptor.GetNilNode();

                F = (IToken)Match(input, FUNCTION, FOLLOW_FUNCTION_in_functionExpression7105); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    F_tree = (object)adaptor.Create(F);
                    adaptor.AddChild(root_0, F_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)F);
                }
                // AS3_ex.g3:1692:45: (I= IDENTIFIER )?
                int alt69 = 2;
                int LA69_0 = input.LA(1);

                if ((LA69_0 == IDENTIFIER))
                {
                    alt69 = 1;
                }
                switch (alt69)
                {
                    case 1:
                        // AS3_ex.g3:1692:46: I= IDENTIFIER
                        {
                            I = (IToken)Match(input, IDENTIFIER, FOLLOW_IDENTIFIER_in_functionExpression7112); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                I_tree = (object)adaptor.Create(I);
                                adaptor.AddChild(root_0, I_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)I);
                            }

                        }
                        break;

                }

                PushFollow(FOLLOW_formalParameterList_in_functionExpression7117);
                formalParameterList119 = formalParameterList();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, formalParameterList119.Tree);
                // AS3_ex.g3:1692:105: (C= COLON type )?
                int alt70 = 2;
                int LA70_0 = input.LA(1);

                if ((LA70_0 == COLON))
                {
                    alt70 = 1;
                }
                switch (alt70)
                {
                    case 1:
                        // AS3_ex.g3:1692:106: C= COLON type
                        {
                            C = (IToken)Match(input, COLON, FOLLOW_COLON_in_functionExpression7122); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                C_tree = (object)adaptor.Create(C);
                                adaptor.AddChild(root_0, C_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                InsertWS(mPrinter.GetAdvancedSpacesBeforeColons()); Emit((CommonToken)C); InsertWS(mPrinter.GetAdvancedSpacesAfterColons());
                            }
                            PushFollow(FOLLOW_type_in_functionExpression7126);
                            type120 = type();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, type120.Tree);

                        }
                        break;

                }

                if (state.backtracking == 0)
                {
                    PopIndent();
                }
                PushFollow(FOLLOW_functionBody_in_functionExpression7132);
                functionBody121 = functionBody();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, functionBody121.Tree);
                if (state.backtracking == 0)
                {
                    PushExpressionIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 52, functionExpression_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "functionExpression"

    public class formalParameterList_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "formalParameterList"
    // AS3_ex.g3:1696:1: formalParameterList : L= LPAREN ( ( variableDeclaration (C= COMMA variableDeclaration )* (C= COMMA formalEllipsisParameter )? ) | formalEllipsisParameter )? R= RPAREN ;
    public AS3_exParser.formalParameterList_return formalParameterList() // throws RecognitionException [1]
    {
        AS3_exParser.formalParameterList_return retval = new AS3_exParser.formalParameterList_return();
        retval.Start = input.LT(1);
        int formalParameterList_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken C = null;
        IToken R = null;
        AS3_exParser.variableDeclaration_return variableDeclaration122 = null;

        AS3_exParser.variableDeclaration_return variableDeclaration123 = null;

        AS3_exParser.formalEllipsisParameter_return formalEllipsisParameter124 = null;

        AS3_exParser.formalEllipsisParameter_return formalEllipsisParameter125 = null;


        object L_tree = null;
        object C_tree = null;
        object R_tree = null;


        WrapOptions options = mPrinter.GetMethodDeclWrapOptions();
        bool pushedFormat = false;
        bool pushedIndent = false;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 53))
            {
                return retval;
            }
            // AS3_ex.g3:1703:5: (L= LPAREN ( ( variableDeclaration (C= COMMA variableDeclaration )* (C= COMMA formalEllipsisParameter )? ) | formalEllipsisParameter )? R= RPAREN )
            // AS3_ex.g3:1704:3: L= LPAREN ( ( variableDeclaration (C= COMMA variableDeclaration )* (C= COMMA formalEllipsisParameter )? ) | formalEllipsisParameter )? R= RPAREN
            {
                root_0 = (object)adaptor.GetNilNode();

                if (state.backtracking == 0)
                {

                    pushedFormat = PushFormatType(options, false);
                    mPrinter.SetInParameterDecl(true);

                }
                L = (IToken)Match(input, LPAREN, FOLLOW_LPAREN_in_formalParameterList7175); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)L); InsertWS(mPrinter.GetAdvancedSpacesInsideParens());
                }
                // AS3_ex.g3:1709:9: ( ( variableDeclaration (C= COMMA variableDeclaration )* (C= COMMA formalEllipsisParameter )? ) | formalEllipsisParameter )?
                int alt73 = 3;
                int LA73_0 = input.LA(1);

                if ((LA73_0 == NATIVE || LA73_0 == TO || (LA73_0 >= EACH && LA73_0 <= NAMESPACE) || (LA73_0 >= DYNAMIC && LA73_0 <= STATIC) || LA73_0 == IDENTIFIER))
                {
                    alt73 = 1;
                }
                else if ((LA73_0 == ELLIPSIS))
                {
                    alt73 = 2;
                }
                switch (alt73)
                {
                    case 1:
                        // AS3_ex.g3:1709:11: ( variableDeclaration (C= COMMA variableDeclaration )* (C= COMMA formalEllipsisParameter )? )
                        {
                            // AS3_ex.g3:1709:11: ( variableDeclaration (C= COMMA variableDeclaration )* (C= COMMA formalEllipsisParameter )? )
                            // AS3_ex.g3:1709:13: variableDeclaration (C= COMMA variableDeclaration )* (C= COMMA formalEllipsisParameter )?
                            {
                                if (state.backtracking == 0)
                                {
                                    pushedIndent = PushLazyParmIndent(pushedIndent, options.IndentStyle);
                                }
                                PushFollow(FOLLOW_variableDeclaration_in_formalParameterList7194);
                                variableDeclaration122 = variableDeclaration();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclaration122.Tree);
                                // AS3_ex.g3:1710:13: (C= COMMA variableDeclaration )*
                                do
                                {
                                    int alt71 = 2;
                                    int LA71_0 = input.LA(1);

                                    if ((LA71_0 == COMMA))
                                    {
                                        int LA71_1 = input.LA(2);

                                        if ((LA71_1 == NATIVE || LA71_1 == TO || (LA71_1 >= EACH && LA71_1 <= NAMESPACE) || (LA71_1 >= DYNAMIC && LA71_1 <= STATIC) || LA71_1 == IDENTIFIER))
                                        {
                                            alt71 = 1;
                                        }


                                    }


                                    switch (alt71)
                                    {
                                        case 1:
                                            // AS3_ex.g3:1711:16: C= COMMA variableDeclaration
                                            {
                                                C = (IToken)Match(input, COMMA, FOLLOW_COMMA_in_formalParameterList7229); if (state.failed) return retval;
                                                if (state.backtracking == 0)
                                                {
                                                    C_tree = (object)adaptor.Create(C);
                                                    adaptor.AddChild(root_0, C_tree);
                                                }
                                                if (state.backtracking == 0)
                                                {
                                                    pushedIndent = EmitCommaWithSpacingAndCRs(options, (CommonToken)C, pushedIndent);
                                                }
                                                PushFollow(FOLLOW_variableDeclaration_in_formalParameterList7264);
                                                variableDeclaration123 = variableDeclaration();
                                                state.followingStackPointer--;
                                                if (state.failed) return retval;
                                                if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclaration123.Tree);

                                            }
                                            break;

                                        default:
                                            goto loop71;
                                    }
                                } while (true);

                            loop71:
                                ;	// Stops C# compiler whining that label 'loop71' has no statements

                                // AS3_ex.g3:1715:13: (C= COMMA formalEllipsisParameter )?
                                int alt72 = 2;
                                int LA72_0 = input.LA(1);

                                if ((LA72_0 == COMMA))
                                {
                                    alt72 = 1;
                                }
                                switch (alt72)
                                {
                                    case 1:
                                        // AS3_ex.g3:1715:15: C= COMMA formalEllipsisParameter
                                        {
                                            if (state.backtracking == 0)
                                            {
                                                InsertWS(mPrinter.GetSpacesBeforeComma());
                                            }
                                            C = (IToken)Match(input, COMMA, FOLLOW_COMMA_in_formalParameterList7301); if (state.failed) return retval;
                                            if (state.backtracking == 0)
                                            {
                                                C_tree = (object)adaptor.Create(C);
                                                adaptor.AddChild(root_0, C_tree);
                                            }
                                            if (state.backtracking == 0)
                                            {
                                                Emit((CommonToken)C);
                                            }
                                            if (state.backtracking == 0)
                                            {
                                                InsertWS(mPrinter.GetSpacesAfterComma());
                                            }
                                            PushFollow(FOLLOW_formalEllipsisParameter_in_formalParameterList7307);
                                            formalEllipsisParameter124 = formalEllipsisParameter();
                                            state.followingStackPointer--;
                                            if (state.failed) return retval;
                                            if (state.backtracking == 0) adaptor.AddChild(root_0, formalEllipsisParameter124.Tree);

                                        }
                                        break;

                                }


                            }


                        }
                        break;
                    case 2:
                        // AS3_ex.g3:1717:14: formalEllipsisParameter
                        {
                            if (state.backtracking == 0)
                            {
                                pushedIndent = PushLazyParmIndent(pushedIndent, options.IndentStyle);
                            }
                            PushFollow(FOLLOW_formalEllipsisParameter_in_formalParameterList7339);
                            formalEllipsisParameter125 = formalEllipsisParameter();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, formalEllipsisParameter125.Tree);

                        }
                        break;

                }

                R = (IToken)Match(input, RPAREN, FOLLOW_RPAREN_in_formalParameterList7363); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if (state.backtracking == 0)
                {
                    InsertWS(mPrinter.GetAdvancedSpacesInsideParens()); Emit((CommonToken)R);
                }
                if (state.backtracking == 0)
                {

                    mPrinter.SetInParameterDecl(false);
                    if (pushedIndent)
                        PopIndent();
                    if (pushedFormat)
                        mPrinter.PopFormatMode();

                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 53, formalParameterList_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "formalParameterList"

    public class formalEllipsisParameter_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "formalEllipsisParameter"
    // AS3_ex.g3:1730:1: formalEllipsisParameter : E= ELLIPSIS variableIdentifierDecl ;
    public AS3_exParser.formalEllipsisParameter_return formalEllipsisParameter() // throws RecognitionException [1]
    {
        AS3_exParser.formalEllipsisParameter_return retval = new AS3_exParser.formalEllipsisParameter_return();
        retval.Start = input.LT(1);
        int formalEllipsisParameter_StartIndex = input.Index();
        object root_0 = null;

        IToken E = null;
        AS3_exParser.variableIdentifierDecl_return variableIdentifierDecl126 = null;


        object E_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 54))
            {
                return retval;
            }
            // AS3_ex.g3:1731:5: (E= ELLIPSIS variableIdentifierDecl )
            // AS3_ex.g3:1731:9: E= ELLIPSIS variableIdentifierDecl
            {
                root_0 = (object)adaptor.GetNilNode();

                E = (IToken)Match(input, ELLIPSIS, FOLLOW_ELLIPSIS_in_formalEllipsisParameter7410); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    E_tree = (object)adaptor.Create(E);
                    adaptor.AddChild(root_0, E_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)E); InsertWS(1);
                }
                PushFollow(FOLLOW_variableIdentifierDecl_in_formalEllipsisParameter7415);
                variableIdentifierDecl126 = variableIdentifierDecl();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, variableIdentifierDecl126.Tree);

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 54, formalEllipsisParameter_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "formalEllipsisParameter"

    public class functionBody_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "functionBody"
    // AS3_ex.g3:1734:1: functionBody : L= LCURLY ( statement | functionDeclaration )* R= RCURLY ;
    public AS3_exParser.functionBody_return functionBody() // throws RecognitionException [1]
    {
        AS3_exParser.functionBody_return retval = new AS3_exParser.functionBody_return();
        retval.Start = input.LT(1);
        int functionBody_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        AS3_exParser.statement_return statement127 = null;

        AS3_exParser.functionDeclaration_return functionDeclaration128 = null;


        object L_tree = null;
        object R_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 55))
            {
                return retval;
            }
            // AS3_ex.g3:1735:5: (L= LCURLY ( statement | functionDeclaration )* R= RCURLY )
            // AS3_ex.g3:1735:9: L= LCURLY ( statement | functionDeclaration )* R= RCURLY
            {
                root_0 = (object)adaptor.GetNilNode();

                L = (IToken)Match(input, LCURLY, FOLLOW_LCURLY_in_functionBody7439); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if (state.backtracking == 0)
                {

                    LeftCurlyNewlineHandler(false);
                    Emit((CommonToken)L); PushIndent(true);

                }
                // AS3_ex.g3:1740:7: ( statement | functionDeclaration )*
                do
                {
                    int alt74 = 3;
                    alt74 = dfa74.Predict(input);
                    switch (alt74)
                    {
                        case 1:
                            // AS3_ex.g3:1740:8: statement
                            {
                                PushFollow(FOLLOW_statement_in_functionBody7457);
                                statement127 = statement();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, statement127.Tree);

                            }
                            break;
                        case 2:
                            // AS3_ex.g3:1740:18: functionDeclaration
                            {
                                PushFollow(FOLLOW_functionDeclaration_in_functionBody7459);
                                functionDeclaration128 = functionDeclaration();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, functionDeclaration128.Tree);

                            }
                            break;

                        default:
                            goto loop74;
                    }
                } while (true);

            loop74:
                ;	// Stops C# compiler whining that label 'loop74' has no statements

                if (state.backtracking == 0)
                {
                    PopIndent();
                }
                R = (IToken)Match(input, RCURLY, FOLLOW_RCURLY_in_functionBody7473); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if (state.backtracking == 0)
                {
                    InsertCR(false); Emit((CommonToken)R);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 55, functionBody_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "functionBody"

    public class memberModifiers_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "memberModifiers"
    // AS3_ex.g3:1748:1: memberModifiers : ( memberModifier )+ ;
    public AS3_exParser.memberModifiers_return memberModifiers() // throws RecognitionException [1]
    {
        AS3_exParser.memberModifiers_return retval = new AS3_exParser.memberModifiers_return();
        retval.Start = input.LT(1);
        int memberModifiers_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.memberModifier_return memberModifier129 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 56))
            {
                return retval;
            }
            // AS3_ex.g3:1749:5: ( ( memberModifier )+ )
            // AS3_ex.g3:1749:9: ( memberModifier )+
            {
                root_0 = (object)adaptor.GetNilNode();

                // AS3_ex.g3:1749:9: ( memberModifier )+
                int cnt75 = 0;
                do
                {
                    int alt75 = 2;
                    int LA75_0 = input.LA(1);

                    if ((LA75_0 == IDENTIFIER))
                    {
                        int LA75_2 = input.LA(2);

                        if ((synpred161_AS3_ex()))
                        {
                            alt75 = 1;
                        }


                    }
                    else if ((LA75_0 == INTERNAL || LA75_0 == NATIVE || (LA75_0 >= PRIVATE && LA75_0 <= PUBLIC) || (LA75_0 >= DYNAMIC && LA75_0 <= STATIC)))
                    {
                        alt75 = 1;
                    }


                    switch (alt75)
                    {
                        case 1:
                            // AS3_ex.g3:0:0: memberModifier
                            {
                                PushFollow(FOLLOW_memberModifier_in_memberModifiers7501);
                                memberModifier129 = memberModifier();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, memberModifier129.Tree);

                            }
                            break;

                        default:
                            if (cnt75 >= 1) goto loop75;
                            if (state.backtracking > 0) { state.failed = true; return retval; }
                            EarlyExitException eee =
                                new EarlyExitException(75, input);
                            throw eee;
                    }
                    cnt75++;
                } while (true);

            loop75:
                ;	// Stops C# compiler whinging that label 'loop75' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 56, memberModifiers_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "memberModifiers"

    public class memberModifier_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "memberModifier"
    // AS3_ex.g3:1756:1: memberModifier : x= ( DYNAMIC | FINAL | INTERNAL | NATIVE | OVERRIDE | PRIVATE | PROTECTED | PUBLIC | STATIC | IDENTIFIER ) ;
    public AS3_exParser.memberModifier_return memberModifier() // throws RecognitionException [1]
    {
        AS3_exParser.memberModifier_return retval = new AS3_exParser.memberModifier_return();
        retval.Start = input.LT(1);
        int memberModifier_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;

        //object x_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 57))
            {
                return retval;
            }
            // AS3_ex.g3:1757:5: (x= ( DYNAMIC | FINAL | INTERNAL | NATIVE | OVERRIDE | PRIVATE | PROTECTED | PUBLIC | STATIC | IDENTIFIER ) )
            // AS3_ex.g3:1757:9: x= ( DYNAMIC | FINAL | INTERNAL | NATIVE | OVERRIDE | PRIVATE | PROTECTED | PUBLIC | STATIC | IDENTIFIER )
            {
                root_0 = (object)adaptor.GetNilNode();

                x = (IToken)input.LT(1);
                if (input.LA(1) == INTERNAL || input.LA(1) == NATIVE || (input.LA(1) >= PRIVATE && input.LA(1) <= PUBLIC) || (input.LA(1) >= DYNAMIC && input.LA(1) <= STATIC) || input.LA(1) == IDENTIFIER)
                {
                    input.Consume();
                    if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(x));
                    state.errorRecovery = false; state.failed = false;
                }
                else
                {
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    MismatchedSetException mse = new MismatchedSetException(null, input);
                    throw mse;
                }

                if (state.backtracking == 0)
                {
                    Emit((CommonToken)x);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 57, memberModifier_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "memberModifier"

    public class statement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "statement"
    // AS3_ex.g3:1778:1: statement : ( blockStatement | directive | namespaceDirective | expression semic | constantVarStatement | tryStatement | labelledStatement | switchStatement | withStatement | returnStatement | breakStatement | continueStatement | forStatement | forInStatement | forEachInStatement | doWhileStatement | whileStatement | ifStatement | emptyStatement | variableStatement | throwStatement );
    public AS3_exParser.statement_return statement() // throws RecognitionException [1]
    {
        AS3_exParser.statement_return retval = new AS3_exParser.statement_return();
        retval.Start = input.LT(1);
        int statement_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.blockStatement_return blockStatement130 = null;

        AS3_exParser.directive_return directive131 = null;

        AS3_exParser.namespaceDirective_return namespaceDirective132 = null;

        AS3_exParser.expression_return expression133 = null;

        AS3_exParser.semic_return semic134 = null;

        AS3_exParser.constantVarStatement_return constantVarStatement135 = null;

        AS3_exParser.tryStatement_return tryStatement136 = null;

        AS3_exParser.labelledStatement_return labelledStatement137 = null;

        AS3_exParser.switchStatement_return switchStatement138 = null;

        AS3_exParser.withStatement_return withStatement139 = null;

        AS3_exParser.returnStatement_return returnStatement140 = null;

        AS3_exParser.breakStatement_return breakStatement141 = null;

        AS3_exParser.continueStatement_return continueStatement142 = null;

        AS3_exParser.forStatement_return forStatement143 = null;

        AS3_exParser.forInStatement_return forInStatement144 = null;

        AS3_exParser.forEachInStatement_return forEachInStatement145 = null;

        AS3_exParser.doWhileStatement_return doWhileStatement146 = null;

        AS3_exParser.whileStatement_return whileStatement147 = null;

        AS3_exParser.ifStatement_return ifStatement148 = null;

        AS3_exParser.emptyStatement_return emptyStatement149 = null;

        AS3_exParser.variableStatement_return variableStatement150 = null;

        AS3_exParser.throwStatement_return throwStatement151 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 58))
            {
                return retval;
            }
            // AS3_ex.g3:1779:5: ( blockStatement | directive | namespaceDirective | expression semic | constantVarStatement | tryStatement | labelledStatement | switchStatement | withStatement | returnStatement | breakStatement | continueStatement | forStatement | forInStatement | forEachInStatement | doWhileStatement | whileStatement | ifStatement | emptyStatement | variableStatement | throwStatement )
            int alt76 = 21;
            alt76 = dfa76.Predict(input);
            switch (alt76)
            {
                case 1:
                    // AS3_ex.g3:1780:6: blockStatement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if (state.backtracking == 0)
                        {
                            SetBlockFlag(true);
                        }
                        PushFollow(FOLLOW_blockStatement_in_statement7668);
                        blockStatement130 = blockStatement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, blockStatement130.Tree);

                    }
                    break;
                case 2:
                    // AS3_ex.g3:1781:9: directive
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if (state.backtracking == 0)
                        {
                            InsertStatementCR();
                        }
                        PushFollow(FOLLOW_directive_in_statement7679);
                        directive131 = directive();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, directive131.Tree);

                    }
                    break;
                case 3:
                    // AS3_ex.g3:1782:9: namespaceDirective
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if (state.backtracking == 0)
                        {
                            InsertStatementCR();
                        }
                        PushFollow(FOLLOW_namespaceDirective_in_statement7690);
                        namespaceDirective132 = namespaceDirective();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, namespaceDirective132.Tree);

                    }
                    break;
                case 4:
                    // AS3_ex.g3:1783:9: expression semic
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if (state.backtracking == 0)
                        {
                            InsertStatementCR();
                        }
                        if (state.backtracking == 0)
                        {
                            PushLazyIndent();
                        }
                        PushFollow(FOLLOW_expression_in_statement7703);
                        expression133 = expression();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, expression133.Tree);
                        PushFollow(FOLLOW_semic_in_statement7705);
                        semic134 = semic();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, semic134.Tree);
                        if (state.backtracking == 0)
                        {
                            PopIndent();
                        }

                    }
                    break;
                case 5:
                    // AS3_ex.g3:1784:9: constantVarStatement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if (state.backtracking == 0)
                        {
                            InsertStatementCR();
                        }
                        if (state.backtracking == 0)
                        {
                            PushLazyIndent();
                        }
                        PushFollow(FOLLOW_constantVarStatement_in_statement7720);
                        constantVarStatement135 = constantVarStatement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, constantVarStatement135.Tree);
                        if (state.backtracking == 0)
                        {
                            PopIndent();
                        }

                    }
                    break;
                case 6:
                    // AS3_ex.g3:1785:9: tryStatement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if (state.backtracking == 0)
                        {
                            MarkBlockFlag(); InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
                        }
                        PushFollow(FOLLOW_tryStatement_in_statement7733);
                        tryStatement136 = tryStatement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, tryStatement136.Tree);

                    }
                    break;
                case 7:
                    // AS3_ex.g3:1786:9: labelledStatement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if (state.backtracking == 0)
                        {
                            InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
                        }
                        if (state.backtracking == 0)
                        {
                            InsertStatementCR();
                        }
                        PushFollow(FOLLOW_labelledStatement_in_statement7745);
                        labelledStatement137 = labelledStatement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, labelledStatement137.Tree);

                    }
                    break;
                case 8:
                    // AS3_ex.g3:1787:9: switchStatement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if (state.backtracking == 0)
                        {
                            MarkBlockFlag();
                        }
                        PushFollow(FOLLOW_switchStatement_in_statement7758);
                        switchStatement138 = switchStatement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, switchStatement138.Tree);

                    }
                    break;
                case 9:
                    // AS3_ex.g3:1788:9: withStatement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if (state.backtracking == 0)
                        {
                            MarkBlockFlag(); InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
                        }
                        if (state.backtracking == 0)
                        {
                            InsertStatementCR();
                        }
                        PushFollow(FOLLOW_withStatement_in_statement7770);
                        withStatement139 = withStatement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, withStatement139.Tree);

                    }
                    break;
                case 10:
                    // AS3_ex.g3:1789:9: returnStatement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if (state.backtracking == 0)
                        {
                            InsertStatementCR();
                        }
                        if (state.backtracking == 0)
                        {
                            PushLazyIndent();
                        }
                        PushFollow(FOLLOW_returnStatement_in_statement7784);
                        returnStatement140 = returnStatement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, returnStatement140.Tree);
                        if (state.backtracking == 0)
                        {
                            PopIndent();
                        }

                    }
                    break;
                case 11:
                    // AS3_ex.g3:1790:9: breakStatement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if (state.backtracking == 0)
                        {
                            InsertStatementCR();
                        }
                        if (state.backtracking == 0)
                        {
                            PushLazyIndent();
                        }
                        PushFollow(FOLLOW_breakStatement_in_statement7800);
                        breakStatement141 = breakStatement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, breakStatement141.Tree);
                        if (state.backtracking == 0)
                        {
                            PopIndent();
                        }

                    }
                    break;
                case 12:
                    // AS3_ex.g3:1791:9: continueStatement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if (state.backtracking == 0)
                        {
                            InsertStatementCR();
                        }
                        if (state.backtracking == 0)
                        {
                            PushLazyIndent();
                        }
                        PushFollow(FOLLOW_continueStatement_in_statement7816);
                        continueStatement142 = continueStatement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, continueStatement142.Tree);
                        if (state.backtracking == 0)
                        {
                            PopIndent();
                        }

                    }
                    break;
                case 13:
                    // AS3_ex.g3:1792:9: forStatement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if (state.backtracking == 0)
                        {
                            MarkBlockFlag(); InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
                        }
                        if (state.backtracking == 0)
                        {
                            InsertStatementCR();
                        }
                        PushFollow(FOLLOW_forStatement_in_statement7830);
                        forStatement143 = forStatement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, forStatement143.Tree);

                    }
                    break;
                case 14:
                    // AS3_ex.g3:1793:9: forInStatement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if (state.backtracking == 0)
                        {
                            MarkBlockFlag(); InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
                        }
                        if (state.backtracking == 0)
                        {
                            InsertStatementCR();
                        }
                        PushFollow(FOLLOW_forInStatement_in_statement7842);
                        forInStatement144 = forInStatement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, forInStatement144.Tree);

                    }
                    break;
                case 15:
                    // AS3_ex.g3:1794:9: forEachInStatement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if (state.backtracking == 0)
                        {
                            MarkBlockFlag(); InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
                        }
                        if (state.backtracking == 0)
                        {
                            InsertStatementCR();
                        }
                        PushFollow(FOLLOW_forEachInStatement_in_statement7854);
                        forEachInStatement145 = forEachInStatement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, forEachInStatement145.Tree);

                    }
                    break;
                case 16:
                    // AS3_ex.g3:1795:9: doWhileStatement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if (state.backtracking == 0)
                        {
                            MarkBlockFlag(); InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
                        }
                        if (state.backtracking == 0)
                        {
                            InsertStatementCR();
                        }
                        PushFollow(FOLLOW_doWhileStatement_in_statement7866);
                        doWhileStatement146 = doWhileStatement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, doWhileStatement146.Tree);

                    }
                    break;
                case 17:
                    // AS3_ex.g3:1796:9: whileStatement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if (state.backtracking == 0)
                        {
                            MarkBlockFlag(); InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
                        }
                        if (state.backtracking == 0)
                        {
                            InsertStatementCR();
                        }
                        PushFollow(FOLLOW_whileStatement_in_statement7878);
                        whileStatement147 = whileStatement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, whileStatement147.Tree);

                    }
                    break;
                case 18:
                    // AS3_ex.g3:1797:9: ifStatement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if (state.backtracking == 0)
                        {
                            InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
                        }
                        PushFollow(FOLLOW_ifStatement_in_statement7889);
                        ifStatement148 = ifStatement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, ifStatement148.Tree);

                    }
                    break;
                case 19:
                    // AS3_ex.g3:1798:9: emptyStatement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if (state.backtracking == 0)
                        {
                            if (mPrinter.IsEmptyStatementsOnNewLine()) InsertStatementCR();
                        }
                        PushFollow(FOLLOW_emptyStatement_in_statement7900);
                        emptyStatement149 = emptyStatement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, emptyStatement149.Tree);

                    }
                    break;
                case 20:
                    // AS3_ex.g3:1799:9: variableStatement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if (state.backtracking == 0)
                        {
                            InsertStatementCR();
                        }
                        if (state.backtracking == 0)
                        {
                            PushLazyIndent();
                        }
                        PushFollow(FOLLOW_variableStatement_in_statement7914);
                        variableStatement150 = variableStatement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, variableStatement150.Tree);
                        if (state.backtracking == 0)
                        {
                            PopIndent();
                        }

                    }
                    break;
                case 21:
                    // AS3_ex.g3:1800:9: throwStatement
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        if (state.backtracking == 0)
                        {
                            InsertStatementCR();
                        }
                        if (state.backtracking == 0)
                        {
                            PushLazyIndent();
                        }
                        PushFollow(FOLLOW_throwStatement_in_statement7930);
                        throwStatement151 = throwStatement();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, throwStatement151.Tree);
                        if (state.backtracking == 0)
                        {
                            PopIndent();
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 58, statement_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "statement"

    public class blockStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "blockStatement"
    // AS3_ex.g3:1808:1: blockStatement : (conditionalToken= conditionalCompilerOption )? L= LCURLY ( statement )* R= RCURLY ;
    public AS3_exParser.blockStatement_return blockStatement() // throws RecognitionException [1]
    {
        AS3_exParser.blockStatement_return retval = new AS3_exParser.blockStatement_return();
        retval.Start = input.LT(1);
        int blockStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        AS3_exParser.conditionalCompilerOption_return conditionalToken = null;

        AS3_exParser.statement_return statement152 = null;


        object L_tree = null;
        object R_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 59))
            {
                return retval;
            }
            // AS3_ex.g3:1809:5: ( (conditionalToken= conditionalCompilerOption )? L= LCURLY ( statement )* R= RCURLY )
            // AS3_ex.g3:1809:9: (conditionalToken= conditionalCompilerOption )? L= LCURLY ( statement )* R= RCURLY
            {
                root_0 = (object)adaptor.GetNilNode();

                // AS3_ex.g3:1809:9: (conditionalToken= conditionalCompilerOption )?
                int alt77 = 2;
                int LA77_0 = input.LA(1);

                if ((LA77_0 == NATIVE || LA77_0 == TO || (LA77_0 >= EACH && LA77_0 <= NAMESPACE) || (LA77_0 >= DYNAMIC && LA77_0 <= STATIC) || LA77_0 == IDENTIFIER))
                {
                    alt77 = 1;
                }
                switch (alt77)
                {
                    case 1:
                        // AS3_ex.g3:1809:10: conditionalToken= conditionalCompilerOption
                        {
                            if (state.backtracking == 0)
                            {
                                InsertCR(false);
                            }
                            PushFollow(FOLLOW_conditionalCompilerOption_in_blockStatement7961);
                            conditionalToken = conditionalCompilerOption();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, conditionalToken.Tree);

                        }
                        break;

                }

                L = (IToken)Match(input, LCURLY, FOLLOW_LCURLY_in_blockStatement7967); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if (state.backtracking == 0)
                {

                    LeftCurlyNewlineHandler(conditionalToken == null); //if we have a conditional setting, then we want to have the option of keeping the brace on the same line
                    Emit((CommonToken)L);
                }
                if (state.backtracking == 0)
                {
                    PushIndent(true);

                }
                // AS3_ex.g3:1814:6: ( statement )*
                do
                {
                    int alt78 = 2;
                    int LA78_0 = input.LA(1);

                    if (((LA78_0 >= AS && LA78_0 <= NATIVE) || (LA78_0 >= NEW && LA78_0 <= TO) || (LA78_0 >= TRUE && LA78_0 <= LCURLY) || LA78_0 == LPAREN || LA78_0 == LBRACK || LA78_0 == LT || (LA78_0 >= PLUS && LA78_0 <= STAR) || (LA78_0 >= INC && LA78_0 <= DEC) || (LA78_0 >= NOT && LA78_0 <= INV) || (LA78_0 >= XML_AT && LA78_0 <= XML_LS_STD) || (LA78_0 >= SINGLE_QUOTE_LITERAL && LA78_0 <= DOUBLE_QUOTE_LITERAL) || LA78_0 == REGULAR_EXPR_LITERAL || LA78_0 == HEX_NUMBER_LITERAL || LA78_0 == DEC_NUMBER_LITERAL || LA78_0 == IDENTIFIER || (LA78_0 >= XML_COMMENT && LA78_0 <= XML_PI)))
                    {
                        alt78 = 1;
                    }


                    switch (alt78)
                    {
                        case 1:
                            // AS3_ex.g3:0:0: statement
                            {
                                PushFollow(FOLLOW_statement_in_blockStatement7984);
                                statement152 = statement();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, statement152.Tree);

                            }
                            break;

                        default:
                            goto loop78;
                    }
                } while (true);

            loop78:
                ;	// Stops C# compiler whining that label 'loop78' has no statements

                if (state.backtracking == 0)
                {
                    PopIndent();
                }
                R = (IToken)Match(input, RCURLY, FOLLOW_RCURLY_in_blockStatement7997); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if (state.backtracking == 0)
                {
                    InsertCR(false); Emit((CommonToken)R);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 59, blockStatement_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "blockStatement"

    public class throwStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "throwStatement"
    // AS3_ex.g3:1820:1: throwStatement : T= THROW expression semic ;
    public AS3_exParser.throwStatement_return throwStatement() // throws RecognitionException [1]
    {
        AS3_exParser.throwStatement_return retval = new AS3_exParser.throwStatement_return();
        retval.Start = input.LT(1);
        int throwStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken T = null;
        AS3_exParser.expression_return expression153 = null;

        AS3_exParser.semic_return semic154 = null;


        object T_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 60))
            {
                return retval;
            }
            // AS3_ex.g3:1821:2: (T= THROW expression semic )
            // AS3_ex.g3:1821:5: T= THROW expression semic
            {
                root_0 = (object)adaptor.GetNilNode();

                T = (IToken)Match(input, THROW, FOLLOW_THROW_in_throwStatement8018); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    T_tree = (object)adaptor.Create(T);
                    adaptor.AddChild(root_0, T_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)T);
                }
                PushFollow(FOLLOW_expression_in_throwStatement8022);
                expression153 = expression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, expression153.Tree);
                PushFollow(FOLLOW_semic_in_throwStatement8024);
                semic154 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, semic154.Tree);

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 60, throwStatement_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "throwStatement"

    public class constantVarStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "constantVarStatement"
    // AS3_ex.g3:1826:1: constantVarStatement : C= CONST variableDeclarationList (S= SEMI )? ;
    public AS3_exParser.constantVarStatement_return constantVarStatement() // throws RecognitionException [1]
    {
        AS3_exParser.constantVarStatement_return retval = new AS3_exParser.constantVarStatement_return();
        retval.Start = input.LT(1);
        int constantVarStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        IToken S = null;
        AS3_exParser.variableDeclarationList_return variableDeclarationList155 = null;


        object C_tree = null;
        object S_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 61))
            {
                return retval;
            }
            // AS3_ex.g3:1827:5: (C= CONST variableDeclarationList (S= SEMI )? )
            // AS3_ex.g3:1827:9: C= CONST variableDeclarationList (S= SEMI )?
            {
                root_0 = (object)adaptor.GetNilNode();

                C = (IToken)Match(input, CONST, FOLLOW_CONST_in_constantVarStatement8044); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    C_tree = (object)adaptor.Create(C);
                    adaptor.AddChild(root_0, C_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)C);
                }
                PushFollow(FOLLOW_variableDeclarationList_in_constantVarStatement8049);
                variableDeclarationList155 = variableDeclarationList();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclarationList155.Tree);
                // AS3_ex.g3:1827:67: (S= SEMI )?
                int alt79 = 2;
                int LA79_0 = input.LA(1);

                if ((LA79_0 == SEMI))
                {
                    int LA79_1 = input.LA(2);

                    if ((synpred193_AS3_ex()))
                    {
                        alt79 = 1;
                    }
                }
                switch (alt79)
                {
                    case 1:
                        // AS3_ex.g3:1827:68: S= SEMI
                        {
                            S = (IToken)Match(input, SEMI, FOLLOW_SEMI_in_constantVarStatement8054); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                S_tree = (object)adaptor.Create(S);
                                adaptor.AddChild(root_0, S_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)S);
                            }

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 61, constantVarStatement_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "constantVarStatement"

    public class useNamespaceDirective_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "useNamespaceDirective"
    // AS3_ex.g3:1832:1: useNamespaceDirective : U= USE N= NAMESPACE qualifiedIdentifier (C= COMMA qualifiedIdentifier )* semic ;
    public AS3_exParser.useNamespaceDirective_return useNamespaceDirective() // throws RecognitionException [1]
    {
        AS3_exParser.useNamespaceDirective_return retval = new AS3_exParser.useNamespaceDirective_return();
        retval.Start = input.LT(1);
        int useNamespaceDirective_StartIndex = input.Index();
        object root_0 = null;

        IToken U = null;
        IToken N = null;
        IToken C = null;
        AS3_exParser.qualifiedIdentifier_return qualifiedIdentifier156 = null;

        AS3_exParser.qualifiedIdentifier_return qualifiedIdentifier157 = null;

        AS3_exParser.semic_return semic158 = null;


        object U_tree = null;
        object N_tree = null;
        object C_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 62))
            {
                return retval;
            }
            // AS3_ex.g3:1833:2: (U= USE N= NAMESPACE qualifiedIdentifier (C= COMMA qualifiedIdentifier )* semic )
            // AS3_ex.g3:1834:2: U= USE N= NAMESPACE qualifiedIdentifier (C= COMMA qualifiedIdentifier )* semic
            {
                root_0 = (object)adaptor.GetNilNode();

                U = (IToken)Match(input, USE, FOLLOW_USE_in_useNamespaceDirective8156); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    U_tree = (object)adaptor.Create(U);
                    adaptor.AddChild(root_0, U_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)U);
                }
                N = (IToken)Match(input, NAMESPACE, FOLLOW_NAMESPACE_in_useNamespaceDirective8165); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    N_tree = (object)adaptor.Create(N);
                    adaptor.AddChild(root_0, N_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)N);
                }
                PushFollow(FOLLOW_qualifiedIdentifier_in_useNamespaceDirective8172);
                qualifiedIdentifier156 = qualifiedIdentifier();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, qualifiedIdentifier156.Tree);
                // AS3_ex.g3:1836:22: (C= COMMA qualifiedIdentifier )*
                do
                {
                    int alt80 = 2;
                    int LA80_0 = input.LA(1);

                    if ((LA80_0 == COMMA))
                    {
                        alt80 = 1;
                    }


                    switch (alt80)
                    {
                        case 1:
                            // AS3_ex.g3:1836:23: C= COMMA qualifiedIdentifier
                            {
                                C = (IToken)Match(input, COMMA, FOLLOW_COMMA_in_useNamespaceDirective8177); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    C_tree = (object)adaptor.Create(C);
                                    adaptor.AddChild(root_0, C_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    Emit((CommonToken)C);
                                }
                                PushFollow(FOLLOW_qualifiedIdentifier_in_useNamespaceDirective8181);
                                qualifiedIdentifier157 = qualifiedIdentifier();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, qualifiedIdentifier157.Tree);

                            }
                            break;

                        default:
                            goto loop80;
                    }
                } while (true);

            loop80:
                ;	// Stops C# compiler whining that label 'loop80' has no statements

                PushFollow(FOLLOW_semic_in_useNamespaceDirective8185);
                semic158 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, semic158.Tree);

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 62, useNamespaceDirective_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "useNamespaceDirective"

    public class namespaceDirective_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "namespaceDirective"
    // AS3_ex.g3:1842:1: namespaceDirective : N= NAMESPACE qualifiedIdentifier (A= ASSIGN stringLiteral )? semic ;
    public AS3_exParser.namespaceDirective_return namespaceDirective() // throws RecognitionException [1]
    {
        AS3_exParser.namespaceDirective_return retval = new AS3_exParser.namespaceDirective_return();
        retval.Start = input.LT(1);
        int namespaceDirective_StartIndex = input.Index();
        object root_0 = null;

        IToken N = null;
        IToken A = null;
        AS3_exParser.qualifiedIdentifier_return qualifiedIdentifier159 = null;

        AS3_exParser.stringLiteral_return stringLiteral160 = null;

        AS3_exParser.semic_return semic161 = null;


        object N_tree = null;
        object A_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 63))
            {
                return retval;
            }
            // AS3_ex.g3:1843:5: (N= NAMESPACE qualifiedIdentifier (A= ASSIGN stringLiteral )? semic )
            // AS3_ex.g3:1844:5: N= NAMESPACE qualifiedIdentifier (A= ASSIGN stringLiteral )? semic
            {
                root_0 = (object)adaptor.GetNilNode();

                N = (IToken)Match(input, NAMESPACE, FOLLOW_NAMESPACE_in_namespaceDirective8215); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    N_tree = (object)adaptor.Create(N);
                    adaptor.AddChild(root_0, N_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)N);
                }
                if (state.backtracking == 0)
                {
                    PushExpressionIndent();
                }
                PushFollow(FOLLOW_qualifiedIdentifier_in_namespaceDirective8226);
                qualifiedIdentifier159 = qualifiedIdentifier();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, qualifiedIdentifier159.Tree);
                // AS3_ex.g3:1845:25: (A= ASSIGN stringLiteral )?
                int alt81 = 2;
                int LA81_0 = input.LA(1);

                if ((LA81_0 == ASSIGN))
                {
                    alt81 = 1;
                }
                switch (alt81)
                {
                    case 1:
                        // AS3_ex.g3:1845:27: A= ASSIGN stringLiteral
                        {
                            A = (IToken)Match(input, ASSIGN, FOLLOW_ASSIGN_in_namespaceDirective8232); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                A_tree = (object)adaptor.Create(A);
                                adaptor.AddChild(root_0, A_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                InsertWS(mPrinter.GetSpacesAroundAssignment()); Emit((CommonToken)A); InsertWS(mPrinter.GetSpacesAroundAssignment());
                            }
                            PushFollow(FOLLOW_stringLiteral_in_namespaceDirective8237);
                            stringLiteral160 = stringLiteral();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, stringLiteral160.Tree);

                        }
                        break;

                }

                PushFollow(FOLLOW_semic_in_namespaceDirective8242);
                semic161 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, semic161.Tree);
                if (state.backtracking == 0)
                {
                    PopIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 63, namespaceDirective_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "namespaceDirective"

    public class tryStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "tryStatement"
    // AS3_ex.g3:1853:1: tryStatement : T= TRY blockStatement ( ( catchClause )+ finallyClause | ( catchClause )+ | finallyClause ) ;
    public AS3_exParser.tryStatement_return tryStatement() // throws RecognitionException [1]
    {
        AS3_exParser.tryStatement_return retval = new AS3_exParser.tryStatement_return();
        retval.Start = input.LT(1);
        int tryStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken T = null;
        AS3_exParser.blockStatement_return blockStatement162 = null;

        AS3_exParser.catchClause_return catchClause163 = null;

        AS3_exParser.finallyClause_return finallyClause164 = null;

        AS3_exParser.catchClause_return catchClause165 = null;

        AS3_exParser.finallyClause_return finallyClause166 = null;


        object T_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 64))
            {
                return retval;
            }
            // AS3_ex.g3:1854:5: (T= TRY blockStatement ( ( catchClause )+ finallyClause | ( catchClause )+ | finallyClause ) )
            // AS3_ex.g3:1854:7: T= TRY blockStatement ( ( catchClause )+ finallyClause | ( catchClause )+ | finallyClause )
            {
                root_0 = (object)adaptor.GetNilNode();

                if (state.backtracking == 0)
                {
                    InsertStatementCR();
                }
                T = (IToken)Match(input, TRY, FOLLOW_TRY_in_tryStatement8270); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    T_tree = (object)adaptor.Create(T);
                    adaptor.AddChild(root_0, T_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)T);
                }
                if (state.backtracking == 0)
                {
                    PushIndent(false);
                }
                PushFollow(FOLLOW_blockStatement_in_tryStatement8276);
                blockStatement162 = blockStatement();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, blockStatement162.Tree);
                if (state.backtracking == 0)
                {
                    PopIndent();
                }
                // AS3_ex.g3:1855:9: ( ( catchClause )+ finallyClause | ( catchClause )+ | finallyClause )
                int alt84 = 3;
                int LA84_0 = input.LA(1);

                if ((LA84_0 == CATCH))
                {
                    int LA84_1 = input.LA(2);

                    if ((synpred197_AS3_ex()))
                    {
                        alt84 = 1;
                    }
                    else if ((synpred199_AS3_ex()))
                    {
                        alt84 = 2;
                    }
                    else
                    {
                        if (state.backtracking > 0) { state.failed = true; return retval; }
                        NoViableAltException nvae_d84s1 =
                            new NoViableAltException("", 84, 1, input);

                        throw nvae_d84s1;
                    }
                }
                else if ((LA84_0 == FINALLY))
                {
                    alt84 = 3;
                }
                else
                {
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    NoViableAltException nvae_d84s0 =
                        new NoViableAltException("", 84, 0, input);

                    throw nvae_d84s0;
                }
                switch (alt84)
                {
                    case 1:
                        // AS3_ex.g3:1855:11: ( catchClause )+ finallyClause
                        {
                            // AS3_ex.g3:1855:11: ( catchClause )+
                            int cnt82 = 0;
                            do
                            {
                                int alt82 = 2;
                                int LA82_0 = input.LA(1);

                                if ((LA82_0 == CATCH))
                                {
                                    alt82 = 1;
                                }


                                switch (alt82)
                                {
                                    case 1:
                                        // AS3_ex.g3:0:0: catchClause
                                        {
                                            PushFollow(FOLLOW_catchClause_in_tryStatement8290);
                                            catchClause163 = catchClause();
                                            state.followingStackPointer--;
                                            if (state.failed) return retval;
                                            if (state.backtracking == 0) adaptor.AddChild(root_0, catchClause163.Tree);

                                        }
                                        break;

                                    default:
                                        if (cnt82 >= 1) goto loop82;
                                        if (state.backtracking > 0) { state.failed = true; return retval; }
                                        EarlyExitException eee =
                                            new EarlyExitException(82, input);
                                        throw eee;
                                }
                                cnt82++;
                            } while (true);

                        loop82:
                            ;	// Stops C# compiler whinging that label 'loop82' has no statements

                            PushFollow(FOLLOW_finallyClause_in_tryStatement8293);
                            finallyClause164 = finallyClause();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, finallyClause164.Tree);

                        }
                        break;
                    case 2:
                        // AS3_ex.g3:1856:11: ( catchClause )+
                        {
                            // AS3_ex.g3:1856:11: ( catchClause )+
                            int cnt83 = 0;
                            do
                            {
                                int alt83 = 2;
                                int LA83_0 = input.LA(1);

                                if ((LA83_0 == CATCH))
                                {
                                    int LA83_2 = input.LA(2);

                                    if ((LA83_2 == LPAREN))
                                    {
                                        alt83 = 1;
                                    }


                                }


                                switch (alt83)
                                {
                                    case 1:
                                        // AS3_ex.g3:0:0: catchClause
                                        {
                                            PushFollow(FOLLOW_catchClause_in_tryStatement8305);
                                            catchClause165 = catchClause();
                                            state.followingStackPointer--;
                                            if (state.failed) return retval;
                                            if (state.backtracking == 0) adaptor.AddChild(root_0, catchClause165.Tree);

                                        }
                                        break;

                                    default:
                                        if (cnt83 >= 1) goto loop83;
                                        if (state.backtracking > 0) { state.failed = true; return retval; }
                                        EarlyExitException eee =
                                            new EarlyExitException(83, input);
                                        throw eee;
                                }
                                cnt83++;
                            } while (true);

                        loop83:
                            ;	// Stops C# compiler whinging that label 'loop83' has no statements


                        }
                        break;
                    case 3:
                        // AS3_ex.g3:1857:11: finallyClause
                        {
                            PushFollow(FOLLOW_finallyClause_in_tryStatement8318);
                            finallyClause166 = finallyClause();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, finallyClause166.Tree);

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 64, tryStatement_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "tryStatement"

    public class catchClause_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "catchClause"
    // AS3_ex.g3:1861:1: catchClause : C= CATCH L= LPAREN variableIdentifierDecl R= RPAREN blockStatement ;
    public AS3_exParser.catchClause_return catchClause() // throws RecognitionException [1]
    {
        AS3_exParser.catchClause_return retval = new AS3_exParser.catchClause_return();
        retval.Start = input.LT(1);
        int catchClause_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        IToken L = null;
        IToken R = null;
        AS3_exParser.variableIdentifierDecl_return variableIdentifierDecl167 = null;

        AS3_exParser.blockStatement_return blockStatement168 = null;


        object C_tree = null;
        object L_tree = null;
        object R_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 65))
            {
                return retval;
            }
            // AS3_ex.g3:1862:5: (C= CATCH L= LPAREN variableIdentifierDecl R= RPAREN blockStatement )
            // AS3_ex.g3:1862:7: C= CATCH L= LPAREN variableIdentifierDecl R= RPAREN blockStatement
            {
                root_0 = (object)adaptor.GetNilNode();

                if (state.backtracking == 0)
                {
                    if (mPrinter.IsCRBeforeCatch()) InsertCR(false);
                }
                if (state.backtracking == 0)
                {
                    InsertWS(1);
                }
                C = (IToken)Match(input, CATCH, FOLLOW_CATCH_in_catchClause8350); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    C_tree = (object)adaptor.Create(C);
                    adaptor.AddChild(root_0, C_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)C); InsertWS(mPrinter.GetSpacesBetweenControlKeywordsAndParens());
                }
                if (state.backtracking == 0)
                {
                    PushIndent(false);
                }
                L = (IToken)Match(input, LPAREN, FOLLOW_LPAREN_in_catchClause8357); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)L); InsertWS(mPrinter.GetAdvancedSpacesInsideParens());
                }
                PushFollow(FOLLOW_variableIdentifierDecl_in_catchClause8361);
                variableIdentifierDecl167 = variableIdentifierDecl();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, variableIdentifierDecl167.Tree);
                R = (IToken)Match(input, RPAREN, FOLLOW_RPAREN_in_catchClause8365); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if (state.backtracking == 0)
                {
                    InsertWS(mPrinter.GetAdvancedSpacesInsideParens()); Emit((CommonToken)R);
                }
                PushFollow(FOLLOW_blockStatement_in_catchClause8369);
                blockStatement168 = blockStatement();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, blockStatement168.Tree);
                if (state.backtracking == 0)
                {
                    PopIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 65, catchClause_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "catchClause"

    public class finallyClause_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "finallyClause"
    // AS3_ex.g3:1865:1: finallyClause : F= FINALLY blockStatement ;
    public AS3_exParser.finallyClause_return finallyClause() // throws RecognitionException [1]
    {
        AS3_exParser.finallyClause_return retval = new AS3_exParser.finallyClause_return();
        retval.Start = input.LT(1);
        int finallyClause_StartIndex = input.Index();
        object root_0 = null;

        IToken F = null;
        AS3_exParser.blockStatement_return blockStatement169 = null;


        object F_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 66))
            {
                return retval;
            }
            // AS3_ex.g3:1866:5: (F= FINALLY blockStatement )
            // AS3_ex.g3:1866:7: F= FINALLY blockStatement
            {
                root_0 = (object)adaptor.GetNilNode();

                if (state.backtracking == 0)
                {
                    if (mPrinter.IsCRBeforeCatch()) InsertCR(false);
                }
                if (state.backtracking == 0)
                {
                    InsertWS(1);
                }
                F = (IToken)Match(input, FINALLY, FOLLOW_FINALLY_in_finallyClause8393); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    F_tree = (object)adaptor.Create(F);
                    adaptor.AddChild(root_0, F_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)F);
                }
                if (state.backtracking == 0)
                {
                    PushIndent(false);
                }
                PushFollow(FOLLOW_blockStatement_in_finallyClause8398);
                blockStatement169 = blockStatement();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, blockStatement169.Tree);
                if (state.backtracking == 0)
                {
                    PopIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 66, finallyClause_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "finallyClause"

    public class labelledStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "labelledStatement"
    // AS3_ex.g3:1873:1: labelledStatement : I= IDENTIFIER C= COLON statement ;
    public AS3_exParser.labelledStatement_return labelledStatement() // throws RecognitionException [1]
    {
        AS3_exParser.labelledStatement_return retval = new AS3_exParser.labelledStatement_return();
        retval.Start = input.LT(1);
        int labelledStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        IToken C = null;
        AS3_exParser.statement_return statement170 = null;


        object I_tree = null;
        object C_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 67))
            {
                return retval;
            }
            // AS3_ex.g3:1874:5: (I= IDENTIFIER C= COLON statement )
            // AS3_ex.g3:1874:8: I= IDENTIFIER C= COLON statement
            {
                root_0 = (object)adaptor.GetNilNode();

                I = (IToken)Match(input, IDENTIFIER, FOLLOW_IDENTIFIER_in_labelledStatement8424); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    I_tree = (object)adaptor.Create(I);
                    adaptor.AddChild(root_0, I_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)I);
                }
                if (state.backtracking == 0)
                {
                    PushLabeledIndent();
                }
                C = (IToken)Match(input, COLON, FOLLOW_COLON_in_labelledStatement8437); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    C_tree = (object)adaptor.Create(C);
                    adaptor.AddChild(root_0, C_tree);
                }
                if (state.backtracking == 0)
                {

                    Emit((CommonToken)C);
                    InsertWS(mPrinter.GetSpacesAfterLabel());

                }
                PushFollow(FOLLOW_statement_in_labelledStatement8453);
                statement170 = statement();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, statement170.Tree);
                if (state.backtracking == 0)
                {
                    PopIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 67, labelledStatement_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "labelledStatement"

    public class switchStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "switchStatement"
    // AS3_ex.g3:1888:1: switchStatement : S= SWITCH parExpression L= LCURLY ( switchBlockStatementGroup )* R= RCURLY ;
    public AS3_exParser.switchStatement_return switchStatement() // throws RecognitionException [1]
    {
        AS3_exParser.switchStatement_return retval = new AS3_exParser.switchStatement_return();
        retval.Start = input.LT(1);
        int switchStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken S = null;
        IToken L = null;
        IToken R = null;
        AS3_exParser.parExpression_return parExpression171 = null;

        AS3_exParser.switchBlockStatementGroup_return switchBlockStatementGroup172 = null;


        object S_tree = null;
        object L_tree = null;
        object R_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 68))
            {
                return retval;
            }
            // AS3_ex.g3:1889:5: (S= SWITCH parExpression L= LCURLY ( switchBlockStatementGroup )* R= RCURLY )
            // AS3_ex.g3:1889:8: S= SWITCH parExpression L= LCURLY ( switchBlockStatementGroup )* R= RCURLY
            {
                root_0 = (object)adaptor.GetNilNode();

                if (state.backtracking == 0)
                {
                    InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
                }
                if (state.backtracking == 0)
                {
                    InsertStatementCR();
                }
                S = (IToken)Match(input, SWITCH, FOLLOW_SWITCH_in_switchStatement8488); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    S_tree = (object)adaptor.Create(S);
                    adaptor.AddChild(root_0, S_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)S); InsertWS(mPrinter.GetSpacesBetweenControlKeywordsAndParens());
                }
                if (state.backtracking == 0)
                {
                    PushExpressionIndent();
                }
                PushFollow(FOLLOW_parExpression_in_switchStatement8493);
                parExpression171 = parExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, parExpression171.Tree);
                if (state.backtracking == 0)
                {
                    PopIndent();
                }
                L = (IToken)Match(input, LCURLY, FOLLOW_LCURLY_in_switchStatement8505); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if (state.backtracking == 0)
                {

                    LeftCurlyNewlineHandler(false);
                    Emit((CommonToken)L); PushIndent(true);

                }
                // AS3_ex.g3:1895:6: ( switchBlockStatementGroup )*
                do
                {
                    int alt85 = 2;
                    int LA85_0 = input.LA(1);

                    if ((LA85_0 == CASE || LA85_0 == DEFAULT))
                    {
                        alt85 = 1;
                    }


                    switch (alt85)
                    {
                        case 1:
                            // AS3_ex.g3:0:0: switchBlockStatementGroup
                            {
                                PushFollow(FOLLOW_switchBlockStatementGroup_in_switchStatement8521);
                                switchBlockStatementGroup172 = switchBlockStatementGroup();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, switchBlockStatementGroup172.Tree);

                            }
                            break;

                        default:
                            goto loop85;
                    }
                } while (true);

            loop85:
                ;	// Stops C# compiler whining that label 'loop85' has no statements

                if (state.backtracking == 0)
                {
                    PopIndent();
                }
                R = (IToken)Match(input, RCURLY, FOLLOW_RCURLY_in_switchStatement8534); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if (state.backtracking == 0)
                {
                    InsertCR(false); Emit((CommonToken)R);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 68, switchStatement_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "switchStatement"

    public class switchBlockStatementGroup_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "switchBlockStatementGroup"
    // AS3_ex.g3:1903:1: switchBlockStatementGroup : switchLabel ( statement )* ( breakStatement )? ;
    public AS3_exParser.switchBlockStatementGroup_return switchBlockStatementGroup() // throws RecognitionException [1]
    {
        AS3_exParser.switchBlockStatementGroup_return retval = new AS3_exParser.switchBlockStatementGroup_return();
        retval.Start = input.LT(1);
        int switchBlockStatementGroup_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.switchLabel_return switchLabel173 = null;

        AS3_exParser.statement_return statement174 = null;

        AS3_exParser.breakStatement_return breakStatement175 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 69))
            {
                return retval;
            }
            // AS3_ex.g3:1904:5: ( switchLabel ( statement )* ( breakStatement )? )
            // AS3_ex.g3:1904:9: switchLabel ( statement )* ( breakStatement )?
            {
                root_0 = (object)adaptor.GetNilNode();

                if (state.backtracking == 0)
                {
                    InsertCR(false);
                }
                PushFollow(FOLLOW_switchLabel_in_switchBlockStatementGroup8567);
                switchLabel173 = switchLabel();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, switchLabel173.Tree);
                if (state.backtracking == 0)
                {
                    PushIndent(false);
                }
                // AS3_ex.g3:1904:61: ( statement )*
                do
                {
                    int alt86 = 2;
                    alt86 = dfa86.Predict(input);
                    switch (alt86)
                    {
                        case 1:
                            // AS3_ex.g3:0:0: statement
                            {
                                PushFollow(FOLLOW_statement_in_switchBlockStatementGroup8571);
                                statement174 = statement();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, statement174.Tree);

                            }
                            break;

                        default:
                            goto loop86;
                    }
                } while (true);

            loop86:
                ;	// Stops C# compiler whining that label 'loop86' has no statements

                if (state.backtracking == 0)
                {
                    PopIndent();
                }
                if (state.backtracking == 0)
                {
                    InsertCR(false);
                }
                // AS3_ex.g3:1904:105: ( breakStatement )?
                int alt87 = 2;
                int LA87_0 = input.LA(1);

                if ((LA87_0 == BREAK))
                {
                    alt87 = 1;
                }
                switch (alt87)
                {
                    case 1:
                        // AS3_ex.g3:0:0: breakStatement
                        {
                            PushFollow(FOLLOW_breakStatement_in_switchBlockStatementGroup8577);
                            breakStatement175 = breakStatement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, breakStatement175.Tree);

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 69, switchBlockStatementGroup_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "switchBlockStatementGroup"

    public class switchLabel_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "switchLabel"
    // AS3_ex.g3:1907:1: switchLabel : (C= CASE expression C= COLON | D= DEFAULT C= COLON );
    public AS3_exParser.switchLabel_return switchLabel() // throws RecognitionException [1]
    {
        AS3_exParser.switchLabel_return retval = new AS3_exParser.switchLabel_return();
        retval.Start = input.LT(1);
        int switchLabel_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        IToken D = null;
        AS3_exParser.expression_return expression176 = null;


        object C_tree = null;
        object D_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 70))
            {
                return retval;
            }
            // AS3_ex.g3:1908:5: (C= CASE expression C= COLON | D= DEFAULT C= COLON )
            int alt88 = 2;
            int LA88_0 = input.LA(1);

            if ((LA88_0 == CASE))
            {
                alt88 = 1;
            }
            else if ((LA88_0 == DEFAULT))
            {
                alt88 = 2;
            }
            else
            {
                if (state.backtracking > 0) { state.failed = true; return retval; }
                NoViableAltException nvae_d88s0 =
                    new NoViableAltException("", 88, 0, input);

                throw nvae_d88s0;
            }
            switch (alt88)
            {
                case 1:
                    // AS3_ex.g3:1908:9: C= CASE expression C= COLON
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        C = (IToken)Match(input, CASE, FOLLOW_CASE_in_switchLabel8603); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            C_tree = (object)adaptor.Create(C);
                            adaptor.AddChild(root_0, C_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)C);
                        }
                        PushFollow(FOLLOW_expression_in_switchLabel8607);
                        expression176 = expression();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, expression176.Tree);
                        C = (IToken)Match(input, COLON, FOLLOW_COLON_in_switchLabel8611); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            C_tree = (object)adaptor.Create(C);
                            adaptor.AddChild(root_0, C_tree);
                        }
                        if (state.backtracking == 0)
                        {

                            Emit((CommonToken)C);
                            InsertWS(mPrinter.GetSpacesAfterLabel());

                        }

                    }
                    break;
                case 2:
                    // AS3_ex.g3:1913:9: D= DEFAULT C= COLON
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        D = (IToken)Match(input, DEFAULT, FOLLOW_DEFAULT_in_switchLabel8632); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            D_tree = (object)adaptor.Create(D);
                            adaptor.AddChild(root_0, D_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)D);
                        }
                        C = (IToken)Match(input, COLON, FOLLOW_COLON_in_switchLabel8638); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            C_tree = (object)adaptor.Create(C);
                            adaptor.AddChild(root_0, C_tree);
                        }
                        if (state.backtracking == 0)
                        {

                            Emit((CommonToken)C);
                            InsertWS(mPrinter.GetSpacesAfterLabel());

                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 70, switchLabel_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "switchLabel"

    public class withStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "withStatement"
    // AS3_ex.g3:1924:1: withStatement : W= WITH L= LPAREN expression R= RPAREN statement ;
    public AS3_exParser.withStatement_return withStatement() // throws RecognitionException [1]
    {
        AS3_exParser.withStatement_return retval = new AS3_exParser.withStatement_return();
        retval.Start = input.LT(1);
        int withStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken W = null;
        IToken L = null;
        IToken R = null;
        AS3_exParser.expression_return expression177 = null;

        AS3_exParser.statement_return statement178 = null;


        object W_tree = null;
        object L_tree = null;
        object R_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 71))
            {
                return retval;
            }
            // AS3_ex.g3:1925:5: (W= WITH L= LPAREN expression R= RPAREN statement )
            // AS3_ex.g3:1925:9: W= WITH L= LPAREN expression R= RPAREN statement
            {
                root_0 = (object)adaptor.GetNilNode();

                W = (IToken)Match(input, WITH, FOLLOW_WITH_in_withStatement8672); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    W_tree = (object)adaptor.Create(W);
                    adaptor.AddChild(root_0, W_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)W); InsertWS(mPrinter.GetSpacesBetweenControlKeywordsAndParens());
                }
                if (state.backtracking == 0)
                {
                    PushExpressionIndent();
                }
                L = (IToken)Match(input, LPAREN, FOLLOW_LPAREN_in_withStatement8680); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)L); InsertWS(mPrinter.GetAdvancedSpacesInsideParens());
                }
                PushFollow(FOLLOW_expression_in_withStatement8685);
                expression177 = expression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, expression177.Tree);
                R = (IToken)Match(input, RPAREN, FOLLOW_RPAREN_in_withStatement8690); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if (state.backtracking == 0)
                {
                    InsertWS(mPrinter.GetAdvancedSpacesInsideParens()); Emit((CommonToken)R);
                }
                if (state.backtracking == 0)
                {
                    PopIndent();
                }
                if (state.backtracking == 0)
                {
                    PushIndent(false);
                }
                PushFollow(FOLLOW_statement_in_withStatement8698);
                statement178 = statement();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, statement178.Tree);
                if (state.backtracking == 0)
                {
                    PopIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 71, withStatement_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "withStatement"

    public class returnStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "returnStatement"
    // AS3_ex.g3:1932:1: returnStatement : R= RETURN ( expression )? semic ;
    public AS3_exParser.returnStatement_return returnStatement() // throws RecognitionException [1]
    {
        AS3_exParser.returnStatement_return retval = new AS3_exParser.returnStatement_return();
        retval.Start = input.LT(1);
        int returnStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken R = null;
        AS3_exParser.expression_return expression179 = null;

        AS3_exParser.semic_return semic180 = null;


        object R_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 72))
            {
                return retval;
            }
            // AS3_ex.g3:1933:5: (R= RETURN ( expression )? semic )
            // AS3_ex.g3:1933:9: R= RETURN ( expression )? semic
            {
                root_0 = (object)adaptor.GetNilNode();

                R = (IToken)Match(input, RETURN, FOLLOW_RETURN_in_returnStatement8725); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)R);
                }
                // AS3_ex.g3:1933:43: ( expression )?
                int alt89 = 2;
                int LA89_0 = input.LA(1);

                if (((LA89_0 >= AS && LA89_0 <= STATIC) || LA89_0 == VOID || LA89_0 == LCURLY || LA89_0 == LPAREN || LA89_0 == LBRACK || LA89_0 == LT || (LA89_0 >= PLUS && LA89_0 <= STAR) || (LA89_0 >= INC && LA89_0 <= DEC) || (LA89_0 >= NOT && LA89_0 <= INV) || (LA89_0 >= XML_AT && LA89_0 <= XML_LS_STD) || (LA89_0 >= SINGLE_QUOTE_LITERAL && LA89_0 <= DOUBLE_QUOTE_LITERAL) || LA89_0 == REGULAR_EXPR_LITERAL || LA89_0 == HEX_NUMBER_LITERAL || LA89_0 == DEC_NUMBER_LITERAL || LA89_0 == IDENTIFIER || (LA89_0 >= XML_COMMENT && LA89_0 <= XML_PI)))
                {
                    alt89 = 1;
                }
                switch (alt89)
                {
                    case 1:
                        // AS3_ex.g3:1933:45: expression
                        {
                            if (state.backtracking == 0)
                            {
                                InsertWS(mPrinter.GetSpacesBetweenControlKeywordsAndParens());
                            }
                            PushFollow(FOLLOW_expression_in_returnStatement8733);
                            expression179 = expression();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, expression179.Tree);

                        }
                        break;

                }

                PushFollow(FOLLOW_semic_in_returnStatement8737);
                semic180 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, semic180.Tree);

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 72, returnStatement_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "returnStatement"

    public class breakStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "breakStatement"
    // AS3_ex.g3:1941:1: breakStatement : B= BREAK (I= IDENTIFIER )? semic ;
    public AS3_exParser.breakStatement_return breakStatement() // throws RecognitionException [1]
    {
        AS3_exParser.breakStatement_return retval = new AS3_exParser.breakStatement_return();
        retval.Start = input.LT(1);
        int breakStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken B = null;
        IToken I = null;
        AS3_exParser.semic_return semic181 = null;


        object B_tree = null;
        object I_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 73))
            {
                return retval;
            }
            // AS3_ex.g3:1942:5: (B= BREAK (I= IDENTIFIER )? semic )
            // AS3_ex.g3:1942:9: B= BREAK (I= IDENTIFIER )? semic
            {
                root_0 = (object)adaptor.GetNilNode();

                B = (IToken)Match(input, BREAK, FOLLOW_BREAK_in_breakStatement8764); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    B_tree = (object)adaptor.Create(B);
                    adaptor.AddChild(root_0, B_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)B);
                }
                // AS3_ex.g3:1942:45: (I= IDENTIFIER )?
                int alt90 = 2;
                int LA90_0 = input.LA(1);

                if ((LA90_0 == IDENTIFIER))
                {
                    alt90 = 1;
                }
                switch (alt90)
                {
                    case 1:
                        // AS3_ex.g3:1942:46: I= IDENTIFIER
                        {
                            I = (IToken)Match(input, IDENTIFIER, FOLLOW_IDENTIFIER_in_breakStatement8774); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                I_tree = (object)adaptor.Create(I);
                                adaptor.AddChild(root_0, I_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)I);
                            }

                        }
                        break;

                }

                PushFollow(FOLLOW_semic_in_breakStatement8779);
                semic181 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, semic181.Tree);

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 73, breakStatement_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "breakStatement"

    public class continueStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "continueStatement"
    // AS3_ex.g3:1950:1: continueStatement : C= CONTINUE (I= IDENTIFIER )? semic ;
    public AS3_exParser.continueStatement_return continueStatement() // throws RecognitionException [1]
    {
        AS3_exParser.continueStatement_return retval = new AS3_exParser.continueStatement_return();
        retval.Start = input.LT(1);
        int continueStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        IToken I = null;
        AS3_exParser.semic_return semic182 = null;


        object C_tree = null;
        object I_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 74))
            {
                return retval;
            }
            // AS3_ex.g3:1951:5: (C= CONTINUE (I= IDENTIFIER )? semic )
            // AS3_ex.g3:1951:9: C= CONTINUE (I= IDENTIFIER )? semic
            {
                root_0 = (object)adaptor.GetNilNode();

                C = (IToken)Match(input, CONTINUE, FOLLOW_CONTINUE_in_continueStatement8805); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    C_tree = (object)adaptor.Create(C);
                    adaptor.AddChild(root_0, C_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)C);
                }
                // AS3_ex.g3:1951:45: (I= IDENTIFIER )?
                int alt91 = 2;
                int LA91_0 = input.LA(1);

                if ((LA91_0 == IDENTIFIER))
                {
                    alt91 = 1;
                }
                switch (alt91)
                {
                    case 1:
                        // AS3_ex.g3:1951:46: I= IDENTIFIER
                        {
                            I = (IToken)Match(input, IDENTIFIER, FOLLOW_IDENTIFIER_in_continueStatement8812); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                I_tree = (object)adaptor.Create(I);
                                adaptor.AddChild(root_0, I_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)I);
                            }

                        }
                        break;

                }

                PushFollow(FOLLOW_semic_in_continueStatement8817);
                semic182 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, semic182.Tree);

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 74, continueStatement_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "continueStatement"

    public class forStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "forStatement"
    // AS3_ex.g3:1959:1: forStatement : F= FOR L= LPAREN forControl R= RPAREN statement ;
    public AS3_exParser.forStatement_return forStatement() // throws RecognitionException [1]
    {
        AS3_exParser.forStatement_return retval = new AS3_exParser.forStatement_return();
        retval.Start = input.LT(1);
        int forStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken F = null;
        IToken L = null;
        IToken R = null;
        AS3_exParser.forControl_return forControl183 = null;

        AS3_exParser.statement_return statement184 = null;


        object F_tree = null;
        object L_tree = null;
        object R_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 75))
            {
                return retval;
            }
            // AS3_ex.g3:1960:5: (F= FOR L= LPAREN forControl R= RPAREN statement )
            // AS3_ex.g3:1960:9: F= FOR L= LPAREN forControl R= RPAREN statement
            {
                root_0 = (object)adaptor.GetNilNode();

                F = (IToken)Match(input, FOR, FOLLOW_FOR_in_forStatement8843); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    F_tree = (object)adaptor.Create(F);
                    adaptor.AddChild(root_0, F_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)F); InsertWS(mPrinter.GetSpacesBetweenControlKeywordsAndParens());
                }
                if (state.backtracking == 0)
                {
                    PushExpressionIndent();
                }
                L = (IToken)Match(input, LPAREN, FOLLOW_LPAREN_in_forStatement8851); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)L); InsertWS(mPrinter.GetAdvancedSpacesInsideParens());
                }
                PushFollow(FOLLOW_forControl_in_forStatement8855);
                forControl183 = forControl();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, forControl183.Tree);
                R = (IToken)Match(input, RPAREN, FOLLOW_RPAREN_in_forStatement8859); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if (state.backtracking == 0)
                {
                    InsertWS(mPrinter.GetAdvancedSpacesInsideParens()); Emit((CommonToken)R);
                }
                if (state.backtracking == 0)
                {
                    PopIndent();
                }
                if (state.backtracking == 0)
                {
                    PushIndent(false);
                }
                PushFollow(FOLLOW_statement_in_forStatement8865);
                statement184 = statement();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, statement184.Tree);
                if (state.backtracking == 0)
                {
                    PopIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 75, forStatement_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "forStatement"

    public class forInStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "forInStatement"
    // AS3_ex.g3:1963:1: forInStatement : F= FOR L= LPAREN forInControl R= RPAREN statement ;
    public AS3_exParser.forInStatement_return forInStatement() // throws RecognitionException [1]
    {
        AS3_exParser.forInStatement_return retval = new AS3_exParser.forInStatement_return();
        retval.Start = input.LT(1);
        int forInStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken F = null;
        IToken L = null;
        IToken R = null;
        AS3_exParser.forInControl_return forInControl185 = null;

        AS3_exParser.statement_return statement186 = null;


        object F_tree = null;
        object L_tree = null;
        object R_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 76))
            {
                return retval;
            }
            // AS3_ex.g3:1964:5: (F= FOR L= LPAREN forInControl R= RPAREN statement )
            // AS3_ex.g3:1964:9: F= FOR L= LPAREN forInControl R= RPAREN statement
            {
                root_0 = (object)adaptor.GetNilNode();

                F = (IToken)Match(input, FOR, FOLLOW_FOR_in_forInStatement8892); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    F_tree = (object)adaptor.Create(F);
                    adaptor.AddChild(root_0, F_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)F); InsertWS(mPrinter.GetSpacesBetweenControlKeywordsAndParens());
                }
                if (state.backtracking == 0)
                {
                    PushExpressionIndent();
                }
                L = (IToken)Match(input, LPAREN, FOLLOW_LPAREN_in_forInStatement8900); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)L); InsertWS(mPrinter.GetAdvancedSpacesInsideParens());
                }
                PushFollow(FOLLOW_forInControl_in_forInStatement8904);
                forInControl185 = forInControl();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, forInControl185.Tree);
                R = (IToken)Match(input, RPAREN, FOLLOW_RPAREN_in_forInStatement8908); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if (state.backtracking == 0)
                {
                    InsertWS(mPrinter.GetAdvancedSpacesInsideParens()); Emit((CommonToken)R);
                }
                if (state.backtracking == 0)
                {
                    PopIndent();
                }
                if (state.backtracking == 0)
                {
                    PushIndent(false);
                }
                PushFollow(FOLLOW_statement_in_forInStatement8916);
                statement186 = statement();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, statement186.Tree);
                if (state.backtracking == 0)
                {
                    PopIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 76, forInStatement_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "forInStatement"

    public class forEachInStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "forEachInStatement"
    // AS3_ex.g3:1967:1: forEachInStatement : F= FOR E= EACH L= LPAREN forInControl R= RPAREN statement ;
    public AS3_exParser.forEachInStatement_return forEachInStatement() // throws RecognitionException [1]
    {
        AS3_exParser.forEachInStatement_return retval = new AS3_exParser.forEachInStatement_return();
        retval.Start = input.LT(1);
        int forEachInStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken F = null;
        IToken E = null;
        IToken L = null;
        IToken R = null;
        AS3_exParser.forInControl_return forInControl187 = null;

        AS3_exParser.statement_return statement188 = null;


        object F_tree = null;
        object E_tree = null;
        object L_tree = null;
        object R_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 77))
            {
                return retval;
            }
            // AS3_ex.g3:1968:5: (F= FOR E= EACH L= LPAREN forInControl R= RPAREN statement )
            // AS3_ex.g3:1968:9: F= FOR E= EACH L= LPAREN forInControl R= RPAREN statement
            {
                root_0 = (object)adaptor.GetNilNode();

                F = (IToken)Match(input, FOR, FOLLOW_FOR_in_forEachInStatement8945); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    F_tree = (object)adaptor.Create(F);
                    adaptor.AddChild(root_0, F_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)F);
                }
                if (state.backtracking == 0)
                {
                    PushExpressionIndent();
                }
                E = (IToken)Match(input, EACH, FOLLOW_EACH_in_forEachInStatement8963); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    E_tree = (object)adaptor.Create(E);
                    adaptor.AddChild(root_0, E_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)E); InsertWS(mPrinter.GetSpacesBetweenControlKeywordsAndParens());
                }
                L = (IToken)Match(input, LPAREN, FOLLOW_LPAREN_in_forEachInStatement8974); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)L); InsertWS(mPrinter.GetAdvancedSpacesInsideParens());
                }
                PushFollow(FOLLOW_forInControl_in_forEachInStatement8978);
                forInControl187 = forInControl();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, forInControl187.Tree);
                R = (IToken)Match(input, RPAREN, FOLLOW_RPAREN_in_forEachInStatement8982); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if (state.backtracking == 0)
                {
                    InsertWS(mPrinter.GetAdvancedSpacesInsideParens()); Emit((CommonToken)R);
                }
                if (state.backtracking == 0)
                {
                    PopIndent();
                }
                if (state.backtracking == 0)
                {
                    PushIndent(false);
                }
                PushFollow(FOLLOW_statement_in_forEachInStatement8988);
                statement188 = statement();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, statement188.Tree);
                if (state.backtracking == 0)
                {
                    PopIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 77, forEachInStatement_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "forEachInStatement"

    public class forControl_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "forControl"
    // AS3_ex.g3:1973:1: forControl options {k=3; } : ( forInit )? semic ( expression )? semic ( forUpdate )? ;
    public AS3_exParser.forControl_return forControl() // throws RecognitionException [1]
    {
        AS3_exParser.forControl_return retval = new AS3_exParser.forControl_return();
        retval.Start = input.LT(1);
        int forControl_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.forInit_return forInit189 = null;

        AS3_exParser.semic_return semic190 = null;

        AS3_exParser.expression_return expression191 = null;

        AS3_exParser.semic_return semic192 = null;

        AS3_exParser.forUpdate_return forUpdate193 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 78))
            {
                return retval;
            }
            // AS3_ex.g3:1975:5: ( ( forInit )? semic ( expression )? semic ( forUpdate )? )
            // AS3_ex.g3:1975:9: ( forInit )? semic ( expression )? semic ( forUpdate )?
            {
                root_0 = (object)adaptor.GetNilNode();

                // AS3_ex.g3:1975:9: ( forInit )?
                int alt92 = 2;
                int LA92_0 = input.LA(1);

                if (((LA92_0 >= AS && LA92_0 <= STATIC) || LA92_0 == LCURLY || LA92_0 == LPAREN || LA92_0 == LBRACK || LA92_0 == LT || (LA92_0 >= PLUS && LA92_0 <= STAR) || (LA92_0 >= INC && LA92_0 <= DEC) || (LA92_0 >= NOT && LA92_0 <= INV) || (LA92_0 >= XML_AT && LA92_0 <= XML_LS_STD) || (LA92_0 >= SINGLE_QUOTE_LITERAL && LA92_0 <= DOUBLE_QUOTE_LITERAL) || LA92_0 == REGULAR_EXPR_LITERAL || LA92_0 == HEX_NUMBER_LITERAL || LA92_0 == DEC_NUMBER_LITERAL || LA92_0 == IDENTIFIER || (LA92_0 >= XML_COMMENT && LA92_0 <= XML_PI)))
                {
                    alt92 = 1;
                }
                switch (alt92)
                {
                    case 1:
                        // AS3_ex.g3:0:0: forInit
                        {
                            PushFollow(FOLLOW_forInit_in_forControl9018);
                            forInit189 = forInit();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, forInit189.Tree);

                        }
                        break;

                }

                if (state.backtracking == 0)
                {
                    InsertWS(mPrinter.GetSpacesBeforeComma());
                }
                PushFollow(FOLLOW_semic_in_forControl9023);
                semic190 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, semic190.Tree);
                if (state.backtracking == 0)
                {
                    InsertWS(mPrinter.GetSpacesAfterComma());
                }
                // AS3_ex.g3:1975:114: ( expression )?
                int alt93 = 2;
                int LA93_0 = input.LA(1);

                if (((LA93_0 >= AS && LA93_0 <= STATIC) || LA93_0 == VOID || LA93_0 == LCURLY || LA93_0 == LPAREN || LA93_0 == LBRACK || LA93_0 == LT || (LA93_0 >= PLUS && LA93_0 <= STAR) || (LA93_0 >= INC && LA93_0 <= DEC) || (LA93_0 >= NOT && LA93_0 <= INV) || (LA93_0 >= XML_AT && LA93_0 <= XML_LS_STD) || (LA93_0 >= SINGLE_QUOTE_LITERAL && LA93_0 <= DOUBLE_QUOTE_LITERAL) || LA93_0 == REGULAR_EXPR_LITERAL || LA93_0 == HEX_NUMBER_LITERAL || LA93_0 == DEC_NUMBER_LITERAL || LA93_0 == IDENTIFIER || (LA93_0 >= XML_COMMENT && LA93_0 <= XML_PI)))
                {
                    alt93 = 1;
                }
                switch (alt93)
                {
                    case 1:
                        // AS3_ex.g3:0:0: expression
                        {
                            PushFollow(FOLLOW_expression_in_forControl9028);
                            expression191 = expression();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, expression191.Tree);

                        }
                        break;

                }

                if (state.backtracking == 0)
                {
                    InsertWS(mPrinter.GetSpacesBeforeComma());
                }
                PushFollow(FOLLOW_semic_in_forControl9032);
                semic192 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, semic192.Tree);
                if (state.backtracking == 0)
                {
                    InsertWS(mPrinter.GetSpacesAfterComma());
                }
                // AS3_ex.g3:1975:220: ( forUpdate )?
                int alt94 = 2;
                int LA94_0 = input.LA(1);

                if (((LA94_0 >= AS && LA94_0 <= STATIC) || LA94_0 == VOID || LA94_0 == LCURLY || LA94_0 == LPAREN || LA94_0 == LBRACK || LA94_0 == LT || (LA94_0 >= PLUS && LA94_0 <= STAR) || (LA94_0 >= INC && LA94_0 <= DEC) || (LA94_0 >= NOT && LA94_0 <= INV) || (LA94_0 >= XML_AT && LA94_0 <= XML_LS_STD) || (LA94_0 >= SINGLE_QUOTE_LITERAL && LA94_0 <= DOUBLE_QUOTE_LITERAL) || LA94_0 == REGULAR_EXPR_LITERAL || LA94_0 == HEX_NUMBER_LITERAL || LA94_0 == DEC_NUMBER_LITERAL || LA94_0 == IDENTIFIER || (LA94_0 >= XML_COMMENT && LA94_0 <= XML_PI)))
                {
                    alt94 = 1;
                }
                switch (alt94)
                {
                    case 1:
                        // AS3_ex.g3:0:0: forUpdate
                        {
                            PushFollow(FOLLOW_forUpdate_in_forControl9036);
                            forUpdate193 = forUpdate();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, forUpdate193.Tree);

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 78, forControl_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "forControl"

    public class forInControl_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "forInControl"
    // AS3_ex.g3:1978:1: forInControl options {k=3; } : forInDecl I= IN expression ;
    public AS3_exParser.forInControl_return forInControl() // throws RecognitionException [1]
    {
        AS3_exParser.forInControl_return retval = new AS3_exParser.forInControl_return();
        retval.Start = input.LT(1);
        int forInControl_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        AS3_exParser.forInDecl_return forInDecl194 = null;

        AS3_exParser.expression_return expression195 = null;


        object I_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 79))
            {
                return retval;
            }
            // AS3_ex.g3:1980:5: ( forInDecl I= IN expression )
            // AS3_ex.g3:1980:9: forInDecl I= IN expression
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_forInDecl_in_forInControl9064);
                forInDecl194 = forInDecl();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, forInDecl194.Tree);
                I = (IToken)Match(input, IN, FOLLOW_IN_in_forInControl9068); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    I_tree = (object)adaptor.Create(I);
                    adaptor.AddChild(root_0, I_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)I);
                }
                PushFollow(FOLLOW_expression_in_forInControl9072);
                expression195 = expression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, expression195.Tree);

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 79, forInControl_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "forInControl"

    public class forInDecl_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "forInDecl"
    // AS3_ex.g3:1983:1: forInDecl : ( leftHandSideExpression | V= VAR variableDeclarationNoIn );
    public AS3_exParser.forInDecl_return forInDecl() // throws RecognitionException [1]
    {
        AS3_exParser.forInDecl_return retval = new AS3_exParser.forInDecl_return();
        retval.Start = input.LT(1);
        int forInDecl_StartIndex = input.Index();
        object root_0 = null;

        IToken V = null;
        AS3_exParser.leftHandSideExpression_return leftHandSideExpression196 = null;

        AS3_exParser.variableDeclarationNoIn_return variableDeclarationNoIn197 = null;


        object V_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 80))
            {
                return retval;
            }
            // AS3_ex.g3:1984:5: ( leftHandSideExpression | V= VAR variableDeclarationNoIn )
            int alt95 = 2;
            int LA95_0 = input.LA(1);

            if (((LA95_0 >= AS && LA95_0 <= USE) || (LA95_0 >= VOID && LA95_0 <= STATIC) || LA95_0 == LCURLY || LA95_0 == LPAREN || LA95_0 == LBRACK || LA95_0 == LT || LA95_0 == STAR || (LA95_0 >= XML_AT && LA95_0 <= XML_LS_STD) || (LA95_0 >= SINGLE_QUOTE_LITERAL && LA95_0 <= DOUBLE_QUOTE_LITERAL) || LA95_0 == REGULAR_EXPR_LITERAL || LA95_0 == HEX_NUMBER_LITERAL || LA95_0 == DEC_NUMBER_LITERAL || LA95_0 == IDENTIFIER || (LA95_0 >= XML_COMMENT && LA95_0 <= XML_PI)))
            {
                alt95 = 1;
            }
            else if ((LA95_0 == VAR))
            {
                int LA95_2 = input.LA(2);

                if ((LA95_2 == NATIVE || LA95_2 == TO || (LA95_2 >= EACH && LA95_2 <= NAMESPACE) || (LA95_2 >= DYNAMIC && LA95_2 <= STATIC) || LA95_2 == IDENTIFIER))
                {
                    alt95 = 2;
                }
                else if ((LA95_2 == DOT || LA95_2 == SUB || LA95_2 == COLON || LA95_2 == XML_NS_OP))
                {
                    alt95 = 1;
                }
                else
                {
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    NoViableAltException nvae_d95s2 =
                        new NoViableAltException("", 95, 2, input);

                    throw nvae_d95s2;
                }
            }
            else
            {
                if (state.backtracking > 0) { state.failed = true; return retval; }
                NoViableAltException nvae_d95s0 =
                    new NoViableAltException("", 95, 0, input);

                throw nvae_d95s0;
            }
            switch (alt95)
            {
                case 1:
                    // AS3_ex.g3:1984:9: leftHandSideExpression
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_leftHandSideExpression_in_forInDecl9091);
                        leftHandSideExpression196 = leftHandSideExpression();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, leftHandSideExpression196.Tree);

                    }
                    break;
                case 2:
                    // AS3_ex.g3:1985:9: V= VAR variableDeclarationNoIn
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        V = (IToken)Match(input, VAR, FOLLOW_VAR_in_forInDecl9103); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            V_tree = (object)adaptor.Create(V);
                            adaptor.AddChild(root_0, V_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)V);
                        }
                        PushFollow(FOLLOW_variableDeclarationNoIn_in_forInDecl9107);
                        variableDeclarationNoIn197 = variableDeclarationNoIn();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclarationNoIn197.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 80, forInDecl_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "forInDecl"

    public class forInit_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "forInit"
    // AS3_ex.g3:1988:1: forInit : ( variableDeclarationNoInList | expressionNoIn );
    public AS3_exParser.forInit_return forInit() // throws RecognitionException [1]
    {
        AS3_exParser.forInit_return retval = new AS3_exParser.forInit_return();
        retval.Start = input.LT(1);
        int forInit_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.variableDeclarationNoInList_return variableDeclarationNoInList198 = null;

        AS3_exParser.expressionNoIn_return expressionNoIn199 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 81))
            {
                return retval;
            }
            // AS3_ex.g3:1989:5: ( variableDeclarationNoInList | expressionNoIn )
            int alt96 = 2;
            switch (input.LA(1))
            {
                case VAR:
                    {
                        int LA96_1 = input.LA(2);

                        if ((LA96_1 == DOT || LA96_1 == SUB || LA96_1 == COLON || LA96_1 == XML_NS_OP))
                        {
                            alt96 = 2;
                        }
                        else if ((LA96_1 == NATIVE || LA96_1 == TO || (LA96_1 >= EACH && LA96_1 <= NAMESPACE) || (LA96_1 >= DYNAMIC && LA96_1 <= STATIC) || LA96_1 == IDENTIFIER))
                        {
                            alt96 = 1;
                        }
                        else
                        {
                            if (state.backtracking > 0) { state.failed = true; return retval; }
                            NoViableAltException nvae_d96s1 =
                                new NoViableAltException("", 96, 1, input);

                            throw nvae_d96s1;
                        }
                    }
                    break;
                case IDENTIFIER:
                    {
                        int LA96_2 = input.LA(2);

                        if ((synpred211_AS3_ex()))
                        {
                            alt96 = 1;
                        }
                        else if ((true))
                        {
                            alt96 = 2;
                        }
                        /*else
                        {
                            if (state.backtracking > 0) { state.failed = true; return retval; }
                            NoViableAltException nvae_d96s2 =
                                new NoViableAltException("", 96, 2, input);

                            throw nvae_d96s2;
                        }*/
                    }
                    break;
                case NATIVE:
                case TO:
                case EACH:
                case GET:
                case SET:
                case NAMESPACE:
                case DYNAMIC:
                case FINAL:
                case OVERRIDE:
                case STATIC:
                    {
                        int LA96_3 = input.LA(2);

                        if ((synpred211_AS3_ex()))
                        {
                            alt96 = 1;
                        }
                        else if ((true))
                        {
                            alt96 = 2;
                        }
                        /*else
                        {
                            if (state.backtracking > 0) { state.failed = true; return retval; }
                            NoViableAltException nvae_d96s3 =
                                new NoViableAltException("", 96, 3, input);

                            throw nvae_d96s3;
                        }*/
                    }
                    break;
                case AS:
                case BREAK:
                case CASE:
                case CATCH:
                case CLASS:
                case CONST:
                case CONTINUE:
                case DEFAULT:
                case DELETE:
                case DO:
                case ELSE:
                case EXTENDS:
                case FALSE:
                case FINALLY:
                case FOR:
                case FUNCTION:
                case IF:
                case IMPLEMENTS:
                case IMPORT:
                case IN:
                case INSTANCEOF:
                case INTERFACE:
                case INTERNAL:
                case IS:
                case NEW:
                case NULL:
                case PACKAGE:
                case PRIVATE:
                case PROTECTED:
                case PUBLIC:
                case RETURN:
                case SUPER:
                case SWITCH:
                case THIS:
                case THROW:
                case TRUE:
                case TRY:
                case TYPEOF:
                case USE:
                case VOID:
                case WHILE:
                case WITH:
                case INCLUDE:
                case LCURLY:
                case LPAREN:
                case LBRACK:
                case LT:
                case PLUS:
                case SUB:
                case STAR:
                case INC:
                case DEC:
                case NOT:
                case INV:
                case XML_AT:
                case XML_LS_STD:
                case SINGLE_QUOTE_LITERAL:
                case DOUBLE_QUOTE_LITERAL:
                case REGULAR_EXPR_LITERAL:
                case HEX_NUMBER_LITERAL:
                case DEC_NUMBER_LITERAL:
                case XML_COMMENT:
                case XML_CDATA:
                case XML_PI:
                    {
                        alt96 = 2;
                    }
                    break;
                default:
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    NoViableAltException nvae_d96s0 =
                        new NoViableAltException("", 96, 0, input);

                    throw nvae_d96s0;
            }

            switch (alt96)
            {
                case 1:
                    // AS3_ex.g3:1989:9: variableDeclarationNoInList
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_variableDeclarationNoInList_in_forInit9126);
                        variableDeclarationNoInList198 = variableDeclarationNoInList();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclarationNoInList198.Tree);

                    }
                    break;
                case 2:
                    // AS3_ex.g3:1990:9: expressionNoIn
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_expressionNoIn_in_forInit9136);
                        expressionNoIn199 = expressionNoIn();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, expressionNoIn199.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 81, forInit_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "forInit"

    public class forUpdate_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "forUpdate"
    // AS3_ex.g3:1993:1: forUpdate : expression ;
    public AS3_exParser.forUpdate_return forUpdate() // throws RecognitionException [1]
    {
        AS3_exParser.forUpdate_return retval = new AS3_exParser.forUpdate_return();
        retval.Start = input.LT(1);
        int forUpdate_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.expression_return expression200 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 82))
            {
                return retval;
            }
            // AS3_ex.g3:1994:5: ( expression )
            // AS3_ex.g3:1994:9: expression
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_expression_in_forUpdate9155);
                expression200 = expression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, expression200.Tree);

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 82, forUpdate_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "forUpdate"

    public class doWhileStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "doWhileStatement"
    // AS3_ex.g3:2002:1: doWhileStatement : D= DO statement W= WHILE parExpression semic (S= SEMI )? ;
    public AS3_exParser.doWhileStatement_return doWhileStatement() // throws RecognitionException [1]
    {
        AS3_exParser.doWhileStatement_return retval = new AS3_exParser.doWhileStatement_return();
        retval.Start = input.LT(1);
        int doWhileStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken D = null;
        IToken W = null;
        IToken S = null;
        AS3_exParser.statement_return statement201 = null;

        AS3_exParser.parExpression_return parExpression202 = null;

        AS3_exParser.semic_return semic203 = null;


        object D_tree = null;
        object W_tree = null;
        object S_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 83))
            {
                return retval;
            }
            // AS3_ex.g3:2003:5: (D= DO statement W= WHILE parExpression semic (S= SEMI )? )
            // AS3_ex.g3:2003:9: D= DO statement W= WHILE parExpression semic (S= SEMI )?
            {
                root_0 = (object)adaptor.GetNilNode();

                D = (IToken)Match(input, DO, FOLLOW_DO_in_doWhileStatement9181); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    D_tree = (object)adaptor.Create(D);
                    adaptor.AddChild(root_0, D_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)D);
                }
                if (state.backtracking == 0)
                {
                    PushIndent(false);
                }
                PushFollow(FOLLOW_statement_in_doWhileStatement9187);
                statement201 = statement();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, statement201.Tree);
                if (state.backtracking == 0)
                {
                    PopIndent();
                }
                if (state.backtracking == 0)
                {
                    InsertWS(1);
                }
                if (state.backtracking == 0)
                {
                    PushExpressionIndent();
                }
                W = (IToken)Match(input, WHILE, FOLLOW_WHILE_in_doWhileStatement9196); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    W_tree = (object)adaptor.Create(W);
                    adaptor.AddChild(root_0, W_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)W); InsertWS(mPrinter.GetSpacesBetweenControlKeywordsAndParens());
                }
                PushFollow(FOLLOW_parExpression_in_doWhileStatement9200);
                parExpression202 = parExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, parExpression202.Tree);
                PushFollow(FOLLOW_semic_in_doWhileStatement9202);
                semic203 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, semic203.Tree);
                // AS3_ex.g3:2003:240: (S= SEMI )?
                int alt97 = 2;
                int LA97_0 = input.LA(1);

                if ((LA97_0 == SEMI))
                {
                    int LA97_1 = input.LA(2);

                    if ((synpred212_AS3_ex()))
                    {
                        alt97 = 1;
                    }
                }
                switch (alt97)
                {
                    case 1:
                        // AS3_ex.g3:2003:241: S= SEMI
                        {
                            S = (IToken)Match(input, SEMI, FOLLOW_SEMI_in_doWhileStatement9207); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                S_tree = (object)adaptor.Create(S);
                                adaptor.AddChild(root_0, S_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)S);
                            }

                        }
                        break;

                }

                if (state.backtracking == 0)
                {
                    PopIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 83, doWhileStatement_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "doWhileStatement"

    public class whileStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "whileStatement"
    // AS3_ex.g3:2010:1: whileStatement : W= WHILE parExpression statement ;
    public AS3_exParser.whileStatement_return whileStatement() // throws RecognitionException [1]
    {
        AS3_exParser.whileStatement_return retval = new AS3_exParser.whileStatement_return();
        retval.Start = input.LT(1);
        int whileStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken W = null;
        AS3_exParser.parExpression_return parExpression204 = null;

        AS3_exParser.statement_return statement205 = null;


        object W_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 84))
            {
                return retval;
            }
            // AS3_ex.g3:2011:5: (W= WHILE parExpression statement )
            // AS3_ex.g3:2011:9: W= WHILE parExpression statement
            {
                root_0 = (object)adaptor.GetNilNode();

                W = (IToken)Match(input, WHILE, FOLLOW_WHILE_in_whileStatement9237); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    W_tree = (object)adaptor.Create(W);
                    adaptor.AddChild(root_0, W_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)W); InsertWS(mPrinter.GetSpacesBetweenControlKeywordsAndParens());
                }
                if (state.backtracking == 0)
                {
                    PushExpressionIndent();
                }
                PushFollow(FOLLOW_parExpression_in_whileStatement9242);
                parExpression204 = parExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, parExpression204.Tree);
                if (state.backtracking == 0)
                {
                    PopIndent();
                }
                if (state.backtracking == 0)
                {
                    PushIndent(false);
                }
                PushFollow(FOLLOW_statement_in_whileStatement9248);
                statement205 = statement();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, statement205.Tree);
                if (state.backtracking == 0)
                {
                    PopIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 84, whileStatement_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "whileStatement"

    public class ifStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "ifStatement"
    // AS3_ex.g3:2020:1: ifStatement : I= IF parExpression statement ( options {k=1; } : E= ELSE statement )? ;
    public AS3_exParser.ifStatement_return ifStatement() // throws RecognitionException [1]
    {
        AS3_exParser.ifStatement_return retval = new AS3_exParser.ifStatement_return();
        retval.Start = input.LT(1);
        int ifStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        IToken E = null;
        AS3_exParser.parExpression_return parExpression206 = null;

        AS3_exParser.statement_return statement207 = null;

        AS3_exParser.statement_return statement208 = null;


        object I_tree = null;
        object E_tree = null;


        CommonToken tok = null;
        bool ifOnSameLine = false;
        bool wasBlock = false;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 85))
            {
                return retval;
            }
            // AS3_ex.g3:2027:5: (I= IF parExpression statement ( options {k=1; } : E= ELSE statement )? )
            // AS3_ex.g3:2028:9: I= IF parExpression statement ( options {k=1; } : E= ELSE statement )?
            {
                root_0 = (object)adaptor.GetNilNode();

                if (state.backtracking == 0)
                {

                    tok = mPrinter.GetLastToken();
                    //if the previous token was not an else, then insert a CR.  Also if it is an 'else' but the setting says to put the 'if' on a new line
                    if (!mPrinter.IsKeepElseIfOnSameLine() || (tok == null) || !tok.Text.Equals("else"))
                    {
                        InsertStatementCR();
                    }

                    if (tok != null && tok.Text.Equals("else"))
                    {
                        mPrinter.SetElseIfState();
                    }

                }
                I = (IToken)Match(input, IF, FOLLOW_IF_in_ifStatement9311); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    I_tree = (object)adaptor.Create(I);
                    adaptor.AddChild(root_0, I_tree);
                }
                if (state.backtracking == 0)
                {

                    Emit((CommonToken)I);
                    ifOnSameLine = mPrinter.GetElseIfNeedToLoseIndent();
                    if (ifOnSameLine)
                        PopIndent();
                    InsertWS(mPrinter.GetSpacesBetweenControlKeywordsAndParens());

                }
                if (state.backtracking == 0)
                {
                    PushExpressionIndent();
                }
                PushFollow(FOLLOW_parExpression_in_ifStatement9346);
                parExpression206 = parExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, parExpression206.Tree);
                if (state.backtracking == 0)
                {
                    PopIndent();
                }
                if (state.backtracking == 0)
                {
                    PushIndent(false);
                }
                if (state.backtracking == 0)
                {
                    AddIfElseBlockTracker(); SetBlockFlag(false); ClearBlockFlag();
                }
                PushFollow(FOLLOW_statement_in_ifStatement9391);
                statement207 = statement();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, statement207.Tree);
                if (state.backtracking == 0)
                {
                    wasBlock = IsBlockFlag(); PopIfElseBlockTracker();
                }
                if (state.backtracking == 0)
                {
                    PopIndent();
                }
                // AS3_ex.g3:2058:10: ( options {k=1; } : E= ELSE statement )?
                int alt98 = 2;
                int LA98_0 = input.LA(1);

                if ((LA98_0 == ELSE))
                {
                    int LA98_2 = input.LA(2);

                    if ((synpred213_AS3_ex()))
                    {
                        alt98 = 1;
                    }
                }
                switch (alt98)
                {
                    case 1:
                        // AS3_ex.g3:2058:26: E= ELSE statement
                        {
                            E = (IToken)Match(input, ELSE, FOLLOW_ELSE_in_ifStatement9446); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                E_tree = (object)adaptor.Create(E);
                                adaptor.AddChild(root_0, E_tree);
                            }
                            if (state.backtracking == 0)
                            {

                                CommonToken tempTok = (CommonToken)mPrinter.GetLastToken();
                                if (mPrinter.IsCRBeforeElse() || !wasBlock)//tempTok==null || !tempTok.Text.Equals("}")) 
                                    InsertCR(false);

                            }
                            if (state.backtracking == 0)
                            {
                                InsertWS(1);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)E);
                            }
                            if (state.backtracking == 0)
                            {
                                PushIndent(false);
                            }
                            PushFollow(FOLLOW_statement_in_ifStatement9487);
                            statement208 = statement();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, statement208.Tree);
                            if (state.backtracking == 0)
                            {
                                PopIndent();
                            }

                        }
                        break;

                }

                if (state.backtracking == 0)
                {
                    if (ifOnSameLine)
                        PushIndent(false);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 85, ifStatement_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "ifStatement"

    public class emptyStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "emptyStatement"
    // AS3_ex.g3:2076:1: emptyStatement : S= SEMI ;
    public AS3_exParser.emptyStatement_return emptyStatement() // throws RecognitionException [1]
    {
        AS3_exParser.emptyStatement_return retval = new AS3_exParser.emptyStatement_return();
        retval.Start = input.LT(1);
        int emptyStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken S = null;

        object S_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 86))
            {
                return retval;
            }
            // AS3_ex.g3:2077:5: (S= SEMI )
            // AS3_ex.g3:2077:11: S= SEMI
            {
                root_0 = (object)adaptor.GetNilNode();

                S = (IToken)Match(input, SEMI, FOLLOW_SEMI_in_emptyStatement9545); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    S_tree = (object)adaptor.Create(S);
                    adaptor.AddChild(root_0, S_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)S);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 86, emptyStatement_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "emptyStatement"

    public class variableStatement_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "variableStatement"
    // AS3_ex.g3:2085:1: variableStatement : (I= IDENTIFIER )? V= VAR variableDeclaration (C= COMMA variableDeclaration )* semic ;
    public AS3_exParser.variableStatement_return variableStatement() // throws RecognitionException [1]
    {
        AS3_exParser.variableStatement_return retval = new AS3_exParser.variableStatement_return();
        retval.Start = input.LT(1);
        int variableStatement_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        IToken V = null;
        IToken C = null;
        AS3_exParser.variableDeclaration_return variableDeclaration209 = null;

        AS3_exParser.variableDeclaration_return variableDeclaration210 = null;

        AS3_exParser.semic_return semic211 = null;


        object I_tree = null;
        object V_tree = null;
        object C_tree = null;


        WrapOptions options = mPrinter.GetExpressionWrapOptions();
        bool pushedFormat = false;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 87))
            {
                return retval;
            }
            // AS3_ex.g3:2090:5: ( (I= IDENTIFIER )? V= VAR variableDeclaration (C= COMMA variableDeclaration )* semic )
            // AS3_ex.g3:2091:6: (I= IDENTIFIER )? V= VAR variableDeclaration (C= COMMA variableDeclaration )* semic
            {
                root_0 = (object)adaptor.GetNilNode();

                if (state.backtracking == 0)
                {
                    pushedFormat = PushFormatType(options, false);
                }
                // AS3_ex.g3:2092:9: (I= IDENTIFIER )?
                int alt99 = 2;
                int LA99_0 = input.LA(1);

                if ((LA99_0 == IDENTIFIER))
                {
                    alt99 = 1;
                }
                switch (alt99)
                {
                    case 1:
                        // AS3_ex.g3:2092:10: I= IDENTIFIER
                        {
                            I = (IToken)Match(input, IDENTIFIER, FOLLOW_IDENTIFIER_in_variableStatement9592); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                I_tree = (object)adaptor.Create(I);
                                adaptor.AddChild(root_0, I_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)I);
                            }

                        }
                        break;

                }

                V = (IToken)Match(input, VAR, FOLLOW_VAR_in_variableStatement9600); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    V_tree = (object)adaptor.Create(V);
                    adaptor.AddChild(root_0, V_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)V);
                }
                PushFollow(FOLLOW_variableDeclaration_in_variableStatement9604);
                variableDeclaration209 = variableDeclaration();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclaration209.Tree);
                // AS3_ex.g3:2092:101: (C= COMMA variableDeclaration )*
                do
                {
                    int alt100 = 2;
                    int LA100_0 = input.LA(1);

                    if ((LA100_0 == COMMA))
                    {
                        alt100 = 1;
                    }


                    switch (alt100)
                    {
                        case 1:
                            // AS3_ex.g3:2092:103: C= COMMA variableDeclaration
                            {
                                if (state.backtracking == 0)
                                {
                                    InsertWS(mPrinter.GetSpacesBeforeComma());
                                }
                                C = (IToken)Match(input, COMMA, FOLLOW_COMMA_in_variableStatement9611); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    C_tree = (object)adaptor.Create(C);
                                    adaptor.AddChild(root_0, C_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    Emit((CommonToken)C);
                                }
                                if (state.backtracking == 0)
                                {
                                    InsertWS(mPrinter.GetSpacesAfterComma());
                                }
                                PushFollow(FOLLOW_variableDeclaration_in_variableStatement9616);
                                variableDeclaration210 = variableDeclaration();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclaration210.Tree);

                            }
                            break;

                        default:
                            goto loop100;
                    }
                } while (true);

            loop100:
                ;	// Stops C# compiler whining that label 'loop100' has no statements

                PushFollow(FOLLOW_semic_in_variableStatement9621);
                semic211 = semic();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, semic211.Tree);
                if (state.backtracking == 0)
                {

                    if (pushedFormat)
                        mPrinter.PopFormatMode();

                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 87, variableStatement_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "variableStatement"

    public class variableDeclarationList_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "variableDeclarationList"
    // AS3_ex.g3:2100:1: variableDeclarationList : variableDeclaration (C= COMMA variableDeclaration )* ;
    public AS3_exParser.variableDeclarationList_return variableDeclarationList() // throws RecognitionException [1]
    {
        AS3_exParser.variableDeclarationList_return retval = new AS3_exParser.variableDeclarationList_return();
        retval.Start = input.LT(1);
        int variableDeclarationList_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        AS3_exParser.variableDeclaration_return variableDeclaration212 = null;

        AS3_exParser.variableDeclaration_return variableDeclaration213 = null;


        object C_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 88))
            {
                return retval;
            }
            // AS3_ex.g3:2101:5: ( variableDeclaration (C= COMMA variableDeclaration )* )
            // AS3_ex.g3:2101:11: variableDeclaration (C= COMMA variableDeclaration )*
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_variableDeclaration_in_variableDeclarationList9663);
                variableDeclaration212 = variableDeclaration();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclaration212.Tree);
                // AS3_ex.g3:2101:31: (C= COMMA variableDeclaration )*
                do
                {
                    int alt101 = 2;
                    int LA101_0 = input.LA(1);

                    if ((LA101_0 == COMMA))
                    {
                        alt101 = 1;
                    }


                    switch (alt101)
                    {
                        case 1:
                            // AS3_ex.g3:2101:33: C= COMMA variableDeclaration
                            {
                                if (state.backtracking == 0)
                                {
                                    InsertWS(mPrinter.GetSpacesBeforeComma());
                                }
                                C = (IToken)Match(input, COMMA, FOLLOW_COMMA_in_variableDeclarationList9671); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    C_tree = (object)adaptor.Create(C);
                                    adaptor.AddChild(root_0, C_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    Emit((CommonToken)C);
                                }
                                if (state.backtracking == 0)
                                {
                                    InsertWS(mPrinter.GetSpacesAfterComma());
                                }
                                PushFollow(FOLLOW_variableDeclaration_in_variableDeclarationList9676);
                                variableDeclaration213 = variableDeclaration();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclaration213.Tree);

                            }
                            break;

                        default:
                            goto loop101;
                    }
                } while (true);

            loop101:
                ;	// Stops C# compiler whining that label 'loop101' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 88, variableDeclarationList_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "variableDeclarationList"

    public class variableDeclarationNoInList_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "variableDeclarationNoInList"
    // AS3_ex.g3:2104:1: variableDeclarationNoInList : (V= VAR )? variableDeclarationNoIn (C= COMMA variableDeclarationNoIn )* ;
    public AS3_exParser.variableDeclarationNoInList_return variableDeclarationNoInList() // throws RecognitionException [1]
    {
        AS3_exParser.variableDeclarationNoInList_return retval = new AS3_exParser.variableDeclarationNoInList_return();
        retval.Start = input.LT(1);
        int variableDeclarationNoInList_StartIndex = input.Index();
        object root_0 = null;

        IToken V = null;
        IToken C = null;
        AS3_exParser.variableDeclarationNoIn_return variableDeclarationNoIn214 = null;

        AS3_exParser.variableDeclarationNoIn_return variableDeclarationNoIn215 = null;


        object V_tree = null;
        object C_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 89))
            {
                return retval;
            }
            // AS3_ex.g3:2105:5: ( (V= VAR )? variableDeclarationNoIn (C= COMMA variableDeclarationNoIn )* )
            // AS3_ex.g3:2105:10: (V= VAR )? variableDeclarationNoIn (C= COMMA variableDeclarationNoIn )*
            {
                root_0 = (object)adaptor.GetNilNode();

                // AS3_ex.g3:2105:10: (V= VAR )?
                int alt102 = 2;
                int LA102_0 = input.LA(1);

                if ((LA102_0 == VAR))
                {
                    alt102 = 1;
                }
                switch (alt102)
                {
                    case 1:
                        // AS3_ex.g3:2105:11: V= VAR
                        {
                            V = (IToken)Match(input, VAR, FOLLOW_VAR_in_variableDeclarationNoInList9705); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                V_tree = (object)adaptor.Create(V);
                                adaptor.AddChild(root_0, V_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)V);
                            }

                        }
                        break;

                }

                PushFollow(FOLLOW_variableDeclarationNoIn_in_variableDeclarationNoInList9711);
                variableDeclarationNoIn214 = variableDeclarationNoIn();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclarationNoIn214.Tree);
                // AS3_ex.g3:2105:68: (C= COMMA variableDeclarationNoIn )*
                do
                {
                    int alt103 = 2;
                    int LA103_0 = input.LA(1);

                    if ((LA103_0 == COMMA))
                    {
                        alt103 = 1;
                    }


                    switch (alt103)
                    {
                        case 1:
                            // AS3_ex.g3:2105:70: C= COMMA variableDeclarationNoIn
                            {
                                if (state.backtracking == 0)
                                {
                                    InsertWS(mPrinter.GetSpacesBeforeComma());
                                }
                                C = (IToken)Match(input, COMMA, FOLLOW_COMMA_in_variableDeclarationNoInList9719); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    C_tree = (object)adaptor.Create(C);
                                    adaptor.AddChild(root_0, C_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    Emit((CommonToken)C);
                                }
                                if (state.backtracking == 0)
                                {
                                    InsertWS(mPrinter.GetSpacesAfterComma());
                                }
                                PushFollow(FOLLOW_variableDeclarationNoIn_in_variableDeclarationNoInList9724);
                                variableDeclarationNoIn215 = variableDeclarationNoIn();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclarationNoIn215.Tree);

                            }
                            break;

                        default:
                            goto loop103;
                    }
                } while (true);

            loop103:
                ;	// Stops C# compiler whining that label 'loop103' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 89, variableDeclarationNoInList_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "variableDeclarationNoInList"

    public class variableDeclaration_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "variableDeclaration"
    // AS3_ex.g3:2108:1: variableDeclaration : variableIdentifierDecl (A= ASSIGN assignmentExpression )? ;
    public AS3_exParser.variableDeclaration_return variableDeclaration() // throws RecognitionException [1]
    {
        AS3_exParser.variableDeclaration_return retval = new AS3_exParser.variableDeclaration_return();
        retval.Start = input.LT(1);
        int variableDeclaration_StartIndex = input.Index();
        object root_0 = null;

        IToken A = null;
        AS3_exParser.variableIdentifierDecl_return variableIdentifierDecl216 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression217 = null;


        object A_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 90))
            {
                return retval;
            }
            // AS3_ex.g3:2109:5: ( variableIdentifierDecl (A= ASSIGN assignmentExpression )? )
            // AS3_ex.g3:2109:9: variableIdentifierDecl (A= ASSIGN assignmentExpression )?
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_variableIdentifierDecl_in_variableDeclaration9749);
                variableIdentifierDecl216 = variableIdentifierDecl();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, variableIdentifierDecl216.Tree);
                // AS3_ex.g3:2109:32: (A= ASSIGN assignmentExpression )?
                int alt104 = 2;
                int LA104_0 = input.LA(1);

                if ((LA104_0 == ASSIGN))
                {
                    alt104 = 1;
                }
                switch (alt104)
                {
                    case 1:
                        // AS3_ex.g3:2109:34: A= ASSIGN assignmentExpression
                        {
                            A = (IToken)Match(input, ASSIGN, FOLLOW_ASSIGN_in_variableDeclaration9755); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                A_tree = (object)adaptor.Create(A);
                                adaptor.AddChild(root_0, A_tree);
                            }
                            if (state.backtracking == 0)
                            {

                                InsertVariableDeclAssignmentWhitespace((CommonToken)A, true);
                                //InsertWS(mPrinter.isInParameterDecl() ? mPrinter.getAdvancedSpacesAroundAssignmentInOptionalParameters() : mPrinter.getSpacesAroundAssignment());
                                Emit((CommonToken)A);
                                InsertVariableDeclAssignmentWhitespace((CommonToken)A, false);
                                //InsertWS(mPrinter.isInParameterDecl() ? mPrinter.getAdvancedSpacesAroundAssignmentInOptionalParameters() : mPrinter.getSpacesAroundAssignment());

                            }
                            PushFollow(FOLLOW_assignmentExpression_in_variableDeclaration9771);
                            assignmentExpression217 = assignmentExpression();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression217.Tree);

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 90, variableDeclaration_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "variableDeclaration"

    public class variableDeclarationNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "variableDeclarationNoIn"
    // AS3_ex.g3:2120:1: variableDeclarationNoIn : variableIdentifierDecl (A= ASSIGN assignmentExpressionNoIn )? ;
    public AS3_exParser.variableDeclarationNoIn_return variableDeclarationNoIn() // throws RecognitionException [1]
    {
        AS3_exParser.variableDeclarationNoIn_return retval = new AS3_exParser.variableDeclarationNoIn_return();
        retval.Start = input.LT(1);
        int variableDeclarationNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken A = null;
        AS3_exParser.variableIdentifierDecl_return variableIdentifierDecl218 = null;

        AS3_exParser.assignmentExpressionNoIn_return assignmentExpressionNoIn219 = null;


        object A_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 91))
            {
                return retval;
            }
            // AS3_ex.g3:2121:5: ( variableIdentifierDecl (A= ASSIGN assignmentExpressionNoIn )? )
            // AS3_ex.g3:2121:10: variableIdentifierDecl (A= ASSIGN assignmentExpressionNoIn )?
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_variableIdentifierDecl_in_variableDeclarationNoIn9794);
                variableIdentifierDecl218 = variableIdentifierDecl();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, variableIdentifierDecl218.Tree);
                // AS3_ex.g3:2121:33: (A= ASSIGN assignmentExpressionNoIn )?
                int alt105 = 2;
                int LA105_0 = input.LA(1);

                if ((LA105_0 == ASSIGN))
                {
                    alt105 = 1;
                }
                switch (alt105)
                {
                    case 1:
                        // AS3_ex.g3:2121:35: A= ASSIGN assignmentExpressionNoIn
                        {
                            A = (IToken)Match(input, ASSIGN, FOLLOW_ASSIGN_in_variableDeclarationNoIn9800); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                A_tree = (object)adaptor.Create(A);
                                adaptor.AddChild(root_0, A_tree);
                            }
                            if (state.backtracking == 0)
                            {

                                InsertVariableDeclAssignmentWhitespace((CommonToken)A, true);
                                //InsertWS(mPrinter.getSpacesAroundAssignment());
                                Emit((CommonToken)A);
                                InsertVariableDeclAssignmentWhitespace((CommonToken)A, false);
                                //InsertWS(mPrinter.getSpacesAroundAssignment());

                            }
                            PushFollow(FOLLOW_assignmentExpressionNoIn_in_variableDeclarationNoIn9824);
                            assignmentExpressionNoIn219 = assignmentExpressionNoIn();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpressionNoIn219.Tree);

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 91, variableDeclarationNoIn_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "variableDeclarationNoIn"

    public class variableIdentifierDecl_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "variableIdentifierDecl"
    // AS3_ex.g3:2132:1: variableIdentifierDecl : identifierLiteral (C= COLON type )? ;
    public AS3_exParser.variableIdentifierDecl_return variableIdentifierDecl() // throws RecognitionException [1]
    {
        AS3_exParser.variableIdentifierDecl_return retval = new AS3_exParser.variableIdentifierDecl_return();
        retval.Start = input.LT(1);
        int variableIdentifierDecl_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        AS3_exParser.identifierLiteral_return identifierLiteral220 = null;

        AS3_exParser.type_return type221 = null;


        object C_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 92))
            {
                return retval;
            }
            // AS3_ex.g3:2133:5: ( identifierLiteral (C= COLON type )? )
            // AS3_ex.g3:2133:10: identifierLiteral (C= COLON type )?
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_identifierLiteral_in_variableIdentifierDecl9851);
                identifierLiteral220 = identifierLiteral();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, identifierLiteral220.Tree);
                // AS3_ex.g3:2133:28: (C= COLON type )?
                int alt106 = 2;
                int LA106_0 = input.LA(1);

                if ((LA106_0 == COLON))
                {
                    alt106 = 1;
                }
                switch (alt106)
                {
                    case 1:
                        // AS3_ex.g3:2133:30: C= COLON type
                        {
                            C = (IToken)Match(input, COLON, FOLLOW_COLON_in_variableIdentifierDecl9857); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                C_tree = (object)adaptor.Create(C);
                                adaptor.AddChild(root_0, C_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                InsertWS(mPrinter.GetAdvancedSpacesBeforeColons()); Emit((CommonToken)C); InsertWS(mPrinter.GetAdvancedSpacesAfterColons());
                            }
                            PushFollow(FOLLOW_type_in_variableIdentifierDecl9861);
                            type221 = type();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, type221.Tree);

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 92, variableIdentifierDecl_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "variableIdentifierDecl"

    public class type_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "type"
    // AS3_ex.g3:2139:1: type : ( qualifiedName | S= STAR | V= VOID );
    public AS3_exParser.type_return type() // throws RecognitionException [1]
    {
        AS3_exParser.type_return retval = new AS3_exParser.type_return();
        retval.Start = input.LT(1);
        int type_StartIndex = input.Index();
        object root_0 = null;

        IToken S = null;
        IToken V = null;
        AS3_exParser.qualifiedName_return qualifiedName222 = null;


        object S_tree = null;
        object V_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 93))
            {
                return retval;
            }
            // AS3_ex.g3:2139:5: ( qualifiedName | S= STAR | V= VOID )
            int alt107 = 3;
            switch (input.LA(1))
            {
                case DEFAULT:
                case INTERNAL:
                case NATIVE:
                case TO:
                case EACH:
                case GET:
                case SET:
                case NAMESPACE:
                case DYNAMIC:
                case FINAL:
                case OVERRIDE:
                case STATIC:
                case IDENTIFIER:
                    {
                        alt107 = 1;
                    }
                    break;
                case STAR:
                    {
                        alt107 = 2;
                    }
                    break;
                case VOID:
                    {
                        alt107 = 3;
                    }
                    break;
                default:
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    NoViableAltException nvae_d107s0 =
                        new NoViableAltException("", 107, 0, input);

                    throw nvae_d107s0;
            }

            switch (alt107)
            {
                case 1:
                    // AS3_ex.g3:2139:9: qualifiedName
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_qualifiedName_in_type9885);
                        qualifiedName222 = qualifiedName();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, qualifiedName222.Tree);

                    }
                    break;
                case 2:
                    // AS3_ex.g3:2139:25: S= STAR
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        S = (IToken)Match(input, STAR, FOLLOW_STAR_in_type9891); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            S_tree = (object)adaptor.Create(S);
                            adaptor.AddChild(root_0, S_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)S);
                        }

                    }
                    break;
                case 3:
                    // AS3_ex.g3:2139:59: V= VOID
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        V = (IToken)Match(input, VOID, FOLLOW_VOID_in_type9899); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            V_tree = (object)adaptor.Create(V);
                            adaptor.AddChild(root_0, V_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)V);
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 93, type_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "type"

    public class typeList_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "typeList"
    // AS3_ex.g3:2141:1: typeList : type (C= COMMA type )* ;
    public AS3_exParser.typeList_return typeList() // throws RecognitionException [1]
    {
        AS3_exParser.typeList_return retval = new AS3_exParser.typeList_return();
        retval.Start = input.LT(1);
        int typeList_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        AS3_exParser.type_return type223 = null;

        AS3_exParser.type_return type224 = null;


        object C_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 94))
            {
                return retval;
            }
            // AS3_ex.g3:2142:5: ( type (C= COMMA type )* )
            // AS3_ex.g3:2142:9: type (C= COMMA type )*
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_type_in_typeList9916);
                type223 = type();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, type223.Tree);
                // AS3_ex.g3:2142:14: (C= COMMA type )*
                do
                {
                    int alt108 = 2;
                    int LA108_0 = input.LA(1);

                    if ((LA108_0 == COMMA))
                    {
                        alt108 = 1;
                    }


                    switch (alt108)
                    {
                        case 1:
                            // AS3_ex.g3:2142:15: C= COMMA type
                            {
                                if (state.backtracking == 0)
                                {
                                    InsertWS(mPrinter.GetSpacesBeforeComma());
                                }
                                C = (IToken)Match(input, COMMA, FOLLOW_COMMA_in_typeList9922); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    C_tree = (object)adaptor.Create(C);
                                    adaptor.AddChild(root_0, C_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    Emit((CommonToken)C);
                                }
                                if (state.backtracking == 0)
                                {
                                    InsertWS(mPrinter.GetSpacesAfterComma());
                                }
                                PushFollow(FOLLOW_type_in_typeList9927);
                                type224 = type();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, type224.Tree);

                            }
                            break;

                        default:
                            goto loop108;
                    }
                } while (true);

            loop108:
                ;	// Stops C# compiler whining that label 'loop108' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 94, typeList_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "typeList"

    public class standardQualifiedName_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "standardQualifiedName"
    // AS3_ex.g3:2146:1: standardQualifiedName : typeSpecifier (D= DOT typeSpecifier )* ;
    public AS3_exParser.standardQualifiedName_return standardQualifiedName() // throws RecognitionException [1]
    {
        AS3_exParser.standardQualifiedName_return retval = new AS3_exParser.standardQualifiedName_return();
        retval.Start = input.LT(1);
        int standardQualifiedName_StartIndex = input.Index();
        object root_0 = null;

        IToken D = null;
        AS3_exParser.typeSpecifier_return typeSpecifier225 = null;

        AS3_exParser.typeSpecifier_return typeSpecifier226 = null;


        object D_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 95))
            {
                return retval;
            }
            // AS3_ex.g3:2147:2: ( typeSpecifier (D= DOT typeSpecifier )* )
            // AS3_ex.g3:2148:2: typeSpecifier (D= DOT typeSpecifier )*
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_typeSpecifier_in_standardQualifiedName9951);
                typeSpecifier225 = typeSpecifier();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, typeSpecifier225.Tree);
                // AS3_ex.g3:2148:16: (D= DOT typeSpecifier )*
                do
                {
                    int alt109 = 2;
                    int LA109_0 = input.LA(1);

                    if ((LA109_0 == DOT))
                    {
                        int LA109_1 = input.LA(2);

                        if ((LA109_1 == DEFAULT || LA109_1 == INTERNAL || LA109_1 == NATIVE || LA109_1 == TO || (LA109_1 >= EACH && LA109_1 <= NAMESPACE) || (LA109_1 >= DYNAMIC && LA109_1 <= STATIC) || LA109_1 == IDENTIFIER))
                        {
                            alt109 = 1;
                        }


                    }


                    switch (alt109)
                    {
                        case 1:
                            // AS3_ex.g3:2148:17: D= DOT typeSpecifier
                            {
                                D = (IToken)Match(input, DOT, FOLLOW_DOT_in_standardQualifiedName9956); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    D_tree = (object)adaptor.Create(D);
                                    adaptor.AddChild(root_0, D_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    Emit((CommonToken)D);
                                }
                                PushFollow(FOLLOW_typeSpecifier_in_standardQualifiedName9960);
                                typeSpecifier226 = typeSpecifier();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, typeSpecifier226.Tree);

                            }
                            break;

                        default:
                            goto loop109;
                    }
                } while (true);

            loop109:
                ;	// Stops C# compiler whining that label 'loop109' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 95, standardQualifiedName_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "standardQualifiedName"

    public class qualifiedName_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "qualifiedName"
    // AS3_ex.g3:2152:1: qualifiedName : standardQualifiedName ( typePostfixSyntax )? ;
    public AS3_exParser.qualifiedName_return qualifiedName() // throws RecognitionException [1]
    {
        AS3_exParser.qualifiedName_return retval = new AS3_exParser.qualifiedName_return();
        retval.Start = input.LT(1);
        int qualifiedName_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.standardQualifiedName_return standardQualifiedName227 = null;

        AS3_exParser.typePostfixSyntax_return typePostfixSyntax228 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 96))
            {
                return retval;
            }
            // AS3_ex.g3:2153:5: ( standardQualifiedName ( typePostfixSyntax )? )
            // AS3_ex.g3:2154:6: standardQualifiedName ( typePostfixSyntax )?
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_standardQualifiedName_in_qualifiedName9988);
                standardQualifiedName227 = standardQualifiedName();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, standardQualifiedName227.Tree);
                // AS3_ex.g3:2154:28: ( typePostfixSyntax )?
                int alt110 = 2;
                int LA110_0 = input.LA(1);

                if ((LA110_0 == DOT))
                {
                    int LA110_1 = input.LA(2);

                    if ((LA110_1 == LT))
                    {
                        alt110 = 1;
                    }
                }
                switch (alt110)
                {
                    case 1:
                        // AS3_ex.g3:2154:29: typePostfixSyntax
                        {
                            PushFollow(FOLLOW_typePostfixSyntax_in_qualifiedName9991);
                            typePostfixSyntax228 = typePostfixSyntax();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, typePostfixSyntax228.Tree);

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 96, qualifiedName_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "qualifiedName"

    public class typePostfixSyntax_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "typePostfixSyntax"
    // AS3_ex.g3:2157:1: typePostfixSyntax : D= DOT L= LT standardQualifiedName ( typePostfixSyntax )? G= GT ;
    public AS3_exParser.typePostfixSyntax_return typePostfixSyntax() // throws RecognitionException [1]
    {
        AS3_exParser.typePostfixSyntax_return retval = new AS3_exParser.typePostfixSyntax_return();
        retval.Start = input.LT(1);
        int typePostfixSyntax_StartIndex = input.Index();
        object root_0 = null;

        IToken D = null;
        IToken L = null;
        IToken G = null;
        AS3_exParser.standardQualifiedName_return standardQualifiedName229 = null;

        AS3_exParser.typePostfixSyntax_return typePostfixSyntax230 = null;


        object D_tree = null;
        object L_tree = null;
        object G_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 97))
            {
                return retval;
            }
            // AS3_ex.g3:2157:18: (D= DOT L= LT standardQualifiedName ( typePostfixSyntax )? G= GT )
            // AS3_ex.g3:2158:2: D= DOT L= LT standardQualifiedName ( typePostfixSyntax )? G= GT
            {
                root_0 = (object)adaptor.GetNilNode();

                D = (IToken)Match(input, DOT, FOLLOW_DOT_in_typePostfixSyntax10013); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    D_tree = (object)adaptor.Create(D);
                    adaptor.AddChild(root_0, D_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)D);
                }
                L = (IToken)Match(input, LT, FOLLOW_LT_in_typePostfixSyntax10019); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)L);
                }
                PushFollow(FOLLOW_standardQualifiedName_in_typePostfixSyntax10023);
                standardQualifiedName229 = standardQualifiedName();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, standardQualifiedName229.Tree);
                // AS3_ex.g3:2158:85: ( typePostfixSyntax )?
                int alt111 = 2;
                int LA111_0 = input.LA(1);

                if ((LA111_0 == DOT))
                {
                    alt111 = 1;
                }
                switch (alt111)
                {
                    case 1:
                        // AS3_ex.g3:2158:86: typePostfixSyntax
                        {
                            PushFollow(FOLLOW_typePostfixSyntax_in_typePostfixSyntax10026);
                            typePostfixSyntax230 = typePostfixSyntax();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, typePostfixSyntax230.Tree);

                        }
                        break;

                }

                G = (IToken)Match(input, GT, FOLLOW_GT_in_typePostfixSyntax10032); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    G_tree = (object)adaptor.Create(G);
                    adaptor.AddChild(root_0, G_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)G);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 97, typePostfixSyntax_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "typePostfixSyntax"

    public class qualifiedIdentifier_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "qualifiedIdentifier"
    // AS3_ex.g3:2161:1: qualifiedIdentifier : I= IDENTIFIER ;
    public AS3_exParser.qualifiedIdentifier_return qualifiedIdentifier() // throws RecognitionException [1]
    {
        AS3_exParser.qualifiedIdentifier_return retval = new AS3_exParser.qualifiedIdentifier_return();
        retval.Start = input.LT(1);
        int qualifiedIdentifier_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;

        object I_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 98))
            {
                return retval;
            }
            // AS3_ex.g3:2162:5: (I= IDENTIFIER )
            // AS3_ex.g3:2162:9: I= IDENTIFIER
            {
                root_0 = (object)adaptor.GetNilNode();

                I = (IToken)Match(input, IDENTIFIER, FOLLOW_IDENTIFIER_in_qualifiedIdentifier10056); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    I_tree = (object)adaptor.Create(I);
                    adaptor.AddChild(root_0, I_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)I);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 98, qualifiedIdentifier_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "qualifiedIdentifier"

    public class parExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "parExpression"
    // AS3_ex.g3:2168:1: parExpression : L= LPAREN expression R= RPAREN ;
    public AS3_exParser.parExpression_return parExpression() // throws RecognitionException [1]
    {
        AS3_exParser.parExpression_return retval = new AS3_exParser.parExpression_return();
        retval.Start = input.LT(1);
        int parExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        AS3_exParser.expression_return expression231 = null;


        object L_tree = null;
        object R_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 99))
            {
                return retval;
            }
            // AS3_ex.g3:2169:5: (L= LPAREN expression R= RPAREN )
            // AS3_ex.g3:2169:7: L= LPAREN expression R= RPAREN
            {
                root_0 = (object)adaptor.GetNilNode();

                L = (IToken)Match(input, LPAREN, FOLLOW_LPAREN_in_parExpression10081); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)L); InsertWS(mPrinter.GetAdvancedSpacesInsideParens());
                }
                if (state.backtracking == 0)
                {
                    PushExpressionIndent();
                }
                PushFollow(FOLLOW_expression_in_parExpression10088);
                expression231 = expression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, expression231.Tree);
                R = (IToken)Match(input, RPAREN, FOLLOW_RPAREN_in_parExpression10093); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if (state.backtracking == 0)
                {
                    InsertWS(mPrinter.GetAdvancedSpacesInsideParens()); Emit((CommonToken)R);
                }
                if (state.backtracking == 0)
                {
                    PopIndent();
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 99, parExpression_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "parExpression"

    public class expression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "expression"
    // AS3_ex.g3:2172:1: expression : assignmentExpression (C= COMMA assignmentExpression )* ;
    public AS3_exParser.expression_return expression() // throws RecognitionException [1]
    {
        AS3_exParser.expression_return retval = new AS3_exParser.expression_return();
        retval.Start = input.LT(1);
        int expression_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        AS3_exParser.assignmentExpression_return assignmentExpression232 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression233 = null;


        object C_tree = null;


        WrapOptions options = mPrinter.GetExpressionWrapOptions();
        bool pushedFormat = false;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 100))
            {
                return retval;
            }
            // AS3_ex.g3:2177:5: ( assignmentExpression (C= COMMA assignmentExpression )* )
            // AS3_ex.g3:2178:6: assignmentExpression (C= COMMA assignmentExpression )*
            {
                root_0 = (object)adaptor.GetNilNode();

                if (state.backtracking == 0)
                {
                    pushedFormat = PushFormatType(options, true);
                }
                PushFollow(FOLLOW_assignmentExpression_in_expression10134);
                assignmentExpression232 = assignmentExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression232.Tree);
                // AS3_ex.g3:2179:27: (C= COMMA assignmentExpression )*
                do
                {
                    int alt112 = 2;
                    int LA112_0 = input.LA(1);

                    if ((LA112_0 == COMMA))
                    {
                        alt112 = 1;
                    }


                    switch (alt112)
                    {
                        case 1:
                            // AS3_ex.g3:2179:29: C= COMMA assignmentExpression
                            {
                                if (state.backtracking == 0)
                                {
                                    InsertWS(mPrinter.GetSpacesBeforeComma());
                                }
                                C = (IToken)Match(input, COMMA, FOLLOW_COMMA_in_expression10142); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    C_tree = (object)adaptor.Create(C);
                                    adaptor.AddChild(root_0, C_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    Emit((CommonToken)C);
                                }
                                if (state.backtracking == 0)
                                {
                                    InsertWS(mPrinter.GetSpacesAfterComma());
                                }
                                PushFollow(FOLLOW_assignmentExpression_in_expression10148);
                                assignmentExpression233 = assignmentExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression233.Tree);

                            }
                            break;

                        default:
                            goto loop112;
                    }
                } while (true);

            loop112:
                ;	// Stops C# compiler whining that label 'loop112' has no statements

                if (state.backtracking == 0)
                {

                    if (pushedFormat)
                        mPrinter.PopFormatMode();

                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 100, expression_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "expression"

    public class expressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "expressionNoIn"
    // AS3_ex.g3:2186:1: expressionNoIn : assignmentExpressionNoIn (C= COMMA assignmentExpressionNoIn )* ;
    public AS3_exParser.expressionNoIn_return expressionNoIn() // throws RecognitionException [1]
    {
        AS3_exParser.expressionNoIn_return retval = new AS3_exParser.expressionNoIn_return();
        retval.Start = input.LT(1);
        int expressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        AS3_exParser.assignmentExpressionNoIn_return assignmentExpressionNoIn234 = null;

        AS3_exParser.assignmentExpressionNoIn_return assignmentExpressionNoIn235 = null;


        object C_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 101))
            {
                return retval;
            }
            // AS3_ex.g3:2187:5: ( assignmentExpressionNoIn (C= COMMA assignmentExpressionNoIn )* )
            // AS3_ex.g3:2187:9: assignmentExpressionNoIn (C= COMMA assignmentExpressionNoIn )*
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_assignmentExpressionNoIn_in_expressionNoIn10176);
                assignmentExpressionNoIn234 = assignmentExpressionNoIn();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpressionNoIn234.Tree);
                // AS3_ex.g3:2187:34: (C= COMMA assignmentExpressionNoIn )*
                do
                {
                    int alt113 = 2;
                    int LA113_0 = input.LA(1);

                    if ((LA113_0 == COMMA))
                    {
                        alt113 = 1;
                    }


                    switch (alt113)
                    {
                        case 1:
                            // AS3_ex.g3:2187:36: C= COMMA assignmentExpressionNoIn
                            {
                                if (state.backtracking == 0)
                                {
                                    InsertWS(mPrinter.GetSpacesBeforeComma());
                                }
                                C = (IToken)Match(input, COMMA, FOLLOW_COMMA_in_expressionNoIn10184); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    C_tree = (object)adaptor.Create(C);
                                    adaptor.AddChild(root_0, C_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    Emit((CommonToken)C);
                                }
                                if (state.backtracking == 0)
                                {
                                    InsertWS(mPrinter.GetSpacesAfterComma());
                                }
                                PushFollow(FOLLOW_assignmentExpressionNoIn_in_expressionNoIn10190);
                                assignmentExpressionNoIn235 = assignmentExpressionNoIn();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpressionNoIn235.Tree);

                            }
                            break;

                        default:
                            goto loop113;
                    }
                } while (true);

            loop113:
                ;	// Stops C# compiler whining that label 'loop113' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 101, expressionNoIn_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "expressionNoIn"

    public class assignmentExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "assignmentExpression"
    // AS3_ex.g3:2191:1: assignmentExpression : ( leftHandSideExpression assignmentOperator assignmentExpression | conditionalExpression );
    public AS3_exParser.assignmentExpression_return assignmentExpression() // throws RecognitionException [1]
    {
        AS3_exParser.assignmentExpression_return retval = new AS3_exParser.assignmentExpression_return();
        retval.Start = input.LT(1);
        int assignmentExpression_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.leftHandSideExpression_return leftHandSideExpression236 = null;

        AS3_exParser.assignmentOperator_return assignmentOperator237 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression238 = null;

        AS3_exParser.conditionalExpression_return conditionalExpression239 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 102))
            {
                return retval;
            }
            // AS3_ex.g3:2192:5: ( leftHandSideExpression assignmentOperator assignmentExpression | conditionalExpression )
            int alt114 = 2;
            alt114 = dfa114.Predict(input);
            switch (alt114)
            {
                case 1:
                    // AS3_ex.g3:2193:7: leftHandSideExpression assignmentOperator assignmentExpression
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_leftHandSideExpression_in_assignmentExpression10219);
                        leftHandSideExpression236 = leftHandSideExpression();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, leftHandSideExpression236.Tree);
                        PushFollow(FOLLOW_assignmentOperator_in_assignmentExpression10222);
                        assignmentOperator237 = assignmentOperator();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentOperator237.Tree);
                        PushFollow(FOLLOW_assignmentExpression_in_assignmentExpression10225);
                        assignmentExpression238 = assignmentExpression();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression238.Tree);

                    }
                    break;
                case 2:
                    // AS3_ex.g3:2194:7: conditionalExpression
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_conditionalExpression_in_assignmentExpression10233);
                        conditionalExpression239 = conditionalExpression();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, conditionalExpression239.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 102, assignmentExpression_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "assignmentExpression"

    public class assignmentExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "assignmentExpressionNoIn"
    // AS3_ex.g3:2198:1: assignmentExpressionNoIn : ( conditionalExpressionNoIn | leftHandSideExpression assignmentOperator assignmentExpressionNoIn );
    public AS3_exParser.assignmentExpressionNoIn_return assignmentExpressionNoIn() // throws RecognitionException [1]
    {
        AS3_exParser.assignmentExpressionNoIn_return retval = new AS3_exParser.assignmentExpressionNoIn_return();
        retval.Start = input.LT(1);
        int assignmentExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.conditionalExpressionNoIn_return conditionalExpressionNoIn240 = null;

        AS3_exParser.leftHandSideExpression_return leftHandSideExpression241 = null;

        AS3_exParser.assignmentOperator_return assignmentOperator242 = null;

        AS3_exParser.assignmentExpressionNoIn_return assignmentExpressionNoIn243 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 103))
            {
                return retval;
            }
            // AS3_ex.g3:2199:5: ( conditionalExpressionNoIn | leftHandSideExpression assignmentOperator assignmentExpressionNoIn )
            int alt115 = 2;
            alt115 = dfa115.Predict(input);
            switch (alt115)
            {
                case 1:
                    // AS3_ex.g3:2199:9: conditionalExpressionNoIn
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_conditionalExpressionNoIn_in_assignmentExpressionNoIn10253);
                        conditionalExpressionNoIn240 = conditionalExpressionNoIn();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, conditionalExpressionNoIn240.Tree);

                    }
                    break;
                case 2:
                    // AS3_ex.g3:2200:9: leftHandSideExpression assignmentOperator assignmentExpressionNoIn
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_leftHandSideExpression_in_assignmentExpressionNoIn10263);
                        leftHandSideExpression241 = leftHandSideExpression();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, leftHandSideExpression241.Tree);
                        PushFollow(FOLLOW_assignmentOperator_in_assignmentExpressionNoIn10266);
                        assignmentOperator242 = assignmentOperator();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentOperator242.Tree);
                        PushFollow(FOLLOW_assignmentExpressionNoIn_in_assignmentExpressionNoIn10269);
                        assignmentExpressionNoIn243 = assignmentExpressionNoIn();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpressionNoIn243.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 103, assignmentExpressionNoIn_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "assignmentExpressionNoIn"

    public class assignmentOperator_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "assignmentOperator"
    // AS3_ex.g3:2203:1: assignmentOperator : op= assignmentOperator_int ;
    public AS3_exParser.assignmentOperator_return assignmentOperator() // throws RecognitionException [1]
    {
        AS3_exParser.assignmentOperator_return retval = new AS3_exParser.assignmentOperator_return();
        retval.Start = input.LT(1);
        int assignmentOperator_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.assignmentOperator_int_return op = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 104))
            {
                return retval;
            }
            // AS3_ex.g3:2204:2: (op= assignmentOperator_int )
            // AS3_ex.g3:2204:4: op= assignmentOperator_int
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_assignmentOperator_int_in_assignmentOperator10285);
                op = assignmentOperator_int();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, op.Tree);
                if (state.backtracking == 0)
                {
                    InsertWS(mPrinter.GetSpacesAroundAssignment());
                    Emit((CommonToken)((op != null) ? ((IToken)op.Start) : null));
                    InsertWS(mPrinter.GetSpacesAroundAssignment());

                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 104, assignmentOperator_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "assignmentOperator"

    public class assignmentOperator_int_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "assignmentOperator_int"
    // AS3_ex.g3:2211:1: assignmentOperator_int : ( ASSIGN | s= STAR a= ASSIGN | DIV_ASSIGN | MOD_ASSIGN | ADD_ASSIGN | SUB_ASSIGN | SHL_ASSIGN | ( ( '>' '>' '=' )=>t1= '>' t2= '>' t3= '=' {...}? -> SHR_ASSIGN ) | ( ( '>' '>' '>' '=' )=>t1= '>' t2= '>' t3= '>' t4= '=' {...}? -> SHU_ASSIGN ) | AND_ASSIGN | XOR_ASSIGN | OR_ASSIGN | LOR_ASSIGN | LAND_ASSIGN );
    public AS3_exParser.assignmentOperator_int_return assignmentOperator_int() // throws RecognitionException [1]
    {
        AS3_exParser.assignmentOperator_int_return retval = new AS3_exParser.assignmentOperator_int_return();
        retval.Start = input.LT(1);
        int assignmentOperator_int_StartIndex = input.Index();
        object root_0 = null;

        IToken s = null;
        IToken a = null;
        IToken t1 = null;
        IToken t2 = null;
        IToken t3 = null;
        IToken t4 = null;
        IToken ASSIGN244 = null;
        IToken DIV_ASSIGN245 = null;
        IToken MOD_ASSIGN246 = null;
        IToken ADD_ASSIGN247 = null;
        IToken SUB_ASSIGN248 = null;
        IToken SHL_ASSIGN249 = null;
        IToken AND_ASSIGN250 = null;
        IToken XOR_ASSIGN251 = null;
        IToken OR_ASSIGN252 = null;
        IToken LOR_ASSIGN253 = null;
        IToken LAND_ASSIGN254 = null;

        object s_tree = null;
        //object a_tree = null;
        //object t1_tree = null;
        //object t2_tree = null;
        //object t3_tree = null;
        //object t4_tree = null;
        object ASSIGN244_tree = null;
        object DIV_ASSIGN245_tree = null;
        object MOD_ASSIGN246_tree = null;
        object ADD_ASSIGN247_tree = null;
        object SUB_ASSIGN248_tree = null;
        object SHL_ASSIGN249_tree = null;
        object AND_ASSIGN250_tree = null;
        object XOR_ASSIGN251_tree = null;
        object OR_ASSIGN252_tree = null;
        object LOR_ASSIGN253_tree = null;
        object LAND_ASSIGN254_tree = null;
        RewriteRuleTokenStream stream_GT = new RewriteRuleTokenStream(adaptor, "token GT");
        RewriteRuleTokenStream stream_ASSIGN = new RewriteRuleTokenStream(adaptor, "token ASSIGN");

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 105))
            {
                return retval;
            }
            // AS3_ex.g3:2212:5: ( ASSIGN | s= STAR a= ASSIGN | DIV_ASSIGN | MOD_ASSIGN | ADD_ASSIGN | SUB_ASSIGN | SHL_ASSIGN | ( ( '>' '>' '=' )=>t1= '>' t2= '>' t3= '=' {...}? -> SHR_ASSIGN ) | ( ( '>' '>' '>' '=' )=>t1= '>' t2= '>' t3= '>' t4= '=' {...}? -> SHU_ASSIGN ) | AND_ASSIGN | XOR_ASSIGN | OR_ASSIGN | LOR_ASSIGN | LAND_ASSIGN )
            int alt116 = 14;
            alt116 = dfa116.Predict(input);
            switch (alt116)
            {
                case 1:
                    // AS3_ex.g3:2212:7: ASSIGN
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        ASSIGN244 = (IToken)Match(input, ASSIGN, FOLLOW_ASSIGN_in_assignmentOperator_int10311); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            ASSIGN244_tree = (object)adaptor.Create(ASSIGN244);
                            adaptor.AddChild(root_0, ASSIGN244_tree);
                        }

                    }
                    break;
                case 2:
                    // AS3_ex.g3:2214:4: s= STAR a= ASSIGN
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        s = (IToken)Match(input, STAR, FOLLOW_STAR_in_assignmentOperator_int10320); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            s_tree = (object)adaptor.Create(s);
                            adaptor.AddChild(root_0, s_tree);
                        }
                        a = (IToken)Match(input, ASSIGN, FOLLOW_ASSIGN_in_assignmentOperator_int10324); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            s.Text = "*=";
                        }

                    }
                    break;
                case 3:
                    // AS3_ex.g3:2215:7: DIV_ASSIGN
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        DIV_ASSIGN245 = (IToken)Match(input, DIV_ASSIGN, FOLLOW_DIV_ASSIGN_in_assignmentOperator_int10335); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            DIV_ASSIGN245_tree = (object)adaptor.Create(DIV_ASSIGN245);
                            adaptor.AddChild(root_0, DIV_ASSIGN245_tree);
                        }

                    }
                    break;
                case 4:
                    // AS3_ex.g3:2216:7: MOD_ASSIGN
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        MOD_ASSIGN246 = (IToken)Match(input, MOD_ASSIGN, FOLLOW_MOD_ASSIGN_in_assignmentOperator_int10344); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            MOD_ASSIGN246_tree = (object)adaptor.Create(MOD_ASSIGN246);
                            adaptor.AddChild(root_0, MOD_ASSIGN246_tree);
                        }

                    }
                    break;
                case 5:
                    // AS3_ex.g3:2217:7: ADD_ASSIGN
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        ADD_ASSIGN247 = (IToken)Match(input, ADD_ASSIGN, FOLLOW_ADD_ASSIGN_in_assignmentOperator_int10353); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            ADD_ASSIGN247_tree = (object)adaptor.Create(ADD_ASSIGN247);
                            adaptor.AddChild(root_0, ADD_ASSIGN247_tree);
                        }

                    }
                    break;
                case 6:
                    // AS3_ex.g3:2218:7: SUB_ASSIGN
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        SUB_ASSIGN248 = (IToken)Match(input, SUB_ASSIGN, FOLLOW_SUB_ASSIGN_in_assignmentOperator_int10362); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            SUB_ASSIGN248_tree = (object)adaptor.Create(SUB_ASSIGN248);
                            adaptor.AddChild(root_0, SUB_ASSIGN248_tree);
                        }

                    }
                    break;
                case 7:
                    // AS3_ex.g3:2219:7: SHL_ASSIGN
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        SHL_ASSIGN249 = (IToken)Match(input, SHL_ASSIGN, FOLLOW_SHL_ASSIGN_in_assignmentOperator_int10370); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            SHL_ASSIGN249_tree = (object)adaptor.Create(SHL_ASSIGN249);
                            adaptor.AddChild(root_0, SHL_ASSIGN249_tree);
                        }

                    }
                    break;
                case 8:
                    // AS3_ex.g3:2222:9: ( ( '>' '>' '=' )=>t1= '>' t2= '>' t3= '=' {...}? -> SHR_ASSIGN )
                    {
                        // AS3_ex.g3:2222:9: ( ( '>' '>' '=' )=>t1= '>' t2= '>' t3= '=' {...}? -> SHR_ASSIGN )
                        // AS3_ex.g3:2222:10: ( '>' '>' '=' )=>t1= '>' t2= '>' t3= '=' {...}?
                        {
                            t1 = (IToken)Match(input, GT, FOLLOW_GT_in_assignmentOperator_int10394); if (state.failed) return retval;
                            if (state.backtracking == 0) stream_GT.Add(t1);

                            t2 = (IToken)Match(input, GT, FOLLOW_GT_in_assignmentOperator_int10398); if (state.failed) return retval;
                            if (state.backtracking == 0) stream_GT.Add(t2);

                            t3 = (IToken)Match(input, ASSIGN, FOLLOW_ASSIGN_in_assignmentOperator_int10402); if (state.failed) return retval;
                            if (state.backtracking == 0) stream_ASSIGN.Add(t3);

                            if (!((t1.Line == t2.Line &&
                                      t1.CharPositionInLine + 1 == t2.CharPositionInLine &&
                                      t2.Line == t3.Line &&
                                      t2.CharPositionInLine + 1 == t3.CharPositionInLine)))
                            {
                                if (state.backtracking > 0) { state.failed = true; return retval; }
                                throw new FailedPredicateException(input, "assignmentOperator_int", " $t1.Line == $t2.Line && \r\n          $t1.CharPositionInLine + 1 == $t2.CharPositionInLine && \r\n          $t2.Line == $t3.Line && \r\n          $t2.CharPositionInLine + 1 == $t3.CharPositionInLine ");
                            }


                            // AST REWRITE
                            // elements:          
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (state.backtracking == 0)
                            {
                                retval.Tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (object)adaptor.GetNilNode();
                                // 2227:7: -> SHR_ASSIGN
                                {
                                    adaptor.AddChild(root_0, (object)adaptor.Create(SHR_ASSIGN, "SHR_ASSIGN"));

                                }

                                retval.Tree = root_0; retval.Tree = root_0;
                            }
                        }

                        if (state.backtracking == 0)
                        {
                            t1.Text = ">>=";
                        }

                    }
                    break;
                case 9:
                    // AS3_ex.g3:2229:7: ( ( '>' '>' '>' '=' )=>t1= '>' t2= '>' t3= '>' t4= '=' {...}? -> SHU_ASSIGN )
                    {
                        // AS3_ex.g3:2229:7: ( ( '>' '>' '>' '=' )=>t1= '>' t2= '>' t3= '>' t4= '=' {...}? -> SHU_ASSIGN )
                        // AS3_ex.g3:2229:8: ( '>' '>' '>' '=' )=>t1= '>' t2= '>' t3= '>' t4= '=' {...}?
                        {
                            t1 = (IToken)Match(input, GT, FOLLOW_GT_in_assignmentOperator_int10448); if (state.failed) return retval;
                            if (state.backtracking == 0) stream_GT.Add(t1);

                            t2 = (IToken)Match(input, GT, FOLLOW_GT_in_assignmentOperator_int10452); if (state.failed) return retval;
                            if (state.backtracking == 0) stream_GT.Add(t2);

                            t3 = (IToken)Match(input, GT, FOLLOW_GT_in_assignmentOperator_int10456); if (state.failed) return retval;
                            if (state.backtracking == 0) stream_GT.Add(t3);

                            t4 = (IToken)Match(input, ASSIGN, FOLLOW_ASSIGN_in_assignmentOperator_int10460); if (state.failed) return retval;
                            if (state.backtracking == 0) stream_ASSIGN.Add(t4);

                            if (!((t1.Line == t2.Line &&
                                      t1.CharPositionInLine + 1 == t2.CharPositionInLine &&
                                      t2.Line == t3.Line &&
                                      t2.CharPositionInLine + 1 == t3.CharPositionInLine &&
                                      t3.Line == t4.Line &&
                                      t3.CharPositionInLine + 1 == t4.CharPositionInLine)))
                            {
                                if (state.backtracking > 0) { state.failed = true; return retval; }
                                throw new FailedPredicateException(input, "assignmentOperator_int", " $t1.Line == $t2.Line && \r\n          $t1.CharPositionInLine + 1 == $t2.CharPositionInLine &&\r\n          $t2.Line == $t3.Line && \r\n          $t2.CharPositionInLine + 1 == $t3.CharPositionInLine &&\r\n          $t3.Line == $t4.Line && \r\n          $t3.CharPositionInLine + 1 == $t4.CharPositionInLine ");
                            }


                            // AST REWRITE
                            // elements:          
                            // token labels:      
                            // rule labels:       retval
                            // token list labels: 
                            // rule list labels:  
                            if (state.backtracking == 0)
                            {
                                retval.Tree = root_0;
                                RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                root_0 = (object)adaptor.GetNilNode();
                                // 2236:7: -> SHU_ASSIGN
                                {
                                    adaptor.AddChild(root_0, (object)adaptor.Create(SHU_ASSIGN, "SHU_ASSIGN"));

                                }

                                retval.Tree = root_0; retval.Tree = root_0;
                            }
                        }

                        if (state.backtracking == 0)
                        {
                            t1.Text = ">>>=";
                        }

                    }
                    break;
                case 10:
                    // AS3_ex.g3:2237:7: AND_ASSIGN
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        AND_ASSIGN250 = (IToken)Match(input, AND_ASSIGN, FOLLOW_AND_ASSIGN_in_assignmentOperator_int10491); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            AND_ASSIGN250_tree = (object)adaptor.Create(AND_ASSIGN250);
                            adaptor.AddChild(root_0, AND_ASSIGN250_tree);
                        }

                    }
                    break;
                case 11:
                    // AS3_ex.g3:2238:7: XOR_ASSIGN
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        XOR_ASSIGN251 = (IToken)Match(input, XOR_ASSIGN, FOLLOW_XOR_ASSIGN_in_assignmentOperator_int10500); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            XOR_ASSIGN251_tree = (object)adaptor.Create(XOR_ASSIGN251);
                            adaptor.AddChild(root_0, XOR_ASSIGN251_tree);
                        }

                    }
                    break;
                case 12:
                    // AS3_ex.g3:2239:7: OR_ASSIGN
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        OR_ASSIGN252 = (IToken)Match(input, OR_ASSIGN, FOLLOW_OR_ASSIGN_in_assignmentOperator_int10509); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            OR_ASSIGN252_tree = (object)adaptor.Create(OR_ASSIGN252);
                            adaptor.AddChild(root_0, OR_ASSIGN252_tree);
                        }

                    }
                    break;
                case 13:
                    // AS3_ex.g3:2240:7: LOR_ASSIGN
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        LOR_ASSIGN253 = (IToken)Match(input, LOR_ASSIGN, FOLLOW_LOR_ASSIGN_in_assignmentOperator_int10517); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            LOR_ASSIGN253_tree = (object)adaptor.Create(LOR_ASSIGN253);
                            adaptor.AddChild(root_0, LOR_ASSIGN253_tree);
                        }

                    }
                    break;
                case 14:
                    // AS3_ex.g3:2241:7: LAND_ASSIGN
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        LAND_ASSIGN254 = (IToken)Match(input, LAND_ASSIGN, FOLLOW_LAND_ASSIGN_in_assignmentOperator_int10525); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            LAND_ASSIGN254_tree = (object)adaptor.Create(LAND_ASSIGN254);
                            adaptor.AddChild(root_0, LAND_ASSIGN254_tree);
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 105, assignmentOperator_int_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "assignmentOperator_int"

    public class conditionalExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "conditionalExpression"
    // AS3_ex.g3:2245:1: conditionalExpression : logicalORExpression (Q= QUE assignmentExpression C= COLON assignmentExpression )? ;
    public AS3_exParser.conditionalExpression_return conditionalExpression() // throws RecognitionException [1]
    {
        AS3_exParser.conditionalExpression_return retval = new AS3_exParser.conditionalExpression_return();
        retval.Start = input.LT(1);
        int conditionalExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken Q = null;
        IToken C = null;
        AS3_exParser.logicalORExpression_return logicalORExpression255 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression256 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression257 = null;


        object Q_tree = null;
        object C_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 106))
            {
                return retval;
            }
            // AS3_ex.g3:2246:5: ( logicalORExpression (Q= QUE assignmentExpression C= COLON assignmentExpression )? )
            // AS3_ex.g3:2246:9: logicalORExpression (Q= QUE assignmentExpression C= COLON assignmentExpression )?
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_logicalORExpression_in_conditionalExpression10545);
                logicalORExpression255 = logicalORExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, logicalORExpression255.Tree);
                // AS3_ex.g3:2246:29: (Q= QUE assignmentExpression C= COLON assignmentExpression )?
                int alt117 = 2;
                int LA117_0 = input.LA(1);

                if ((LA117_0 == QUE))
                {
                    alt117 = 1;
                }
                switch (alt117)
                {
                    case 1:
                        // AS3_ex.g3:2246:31: Q= QUE assignmentExpression C= COLON assignmentExpression
                        {
                            Q = (IToken)Match(input, QUE, FOLLOW_QUE_in_conditionalExpression10551); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                Q_tree = (object)adaptor.Create(Q);
                                adaptor.AddChild(root_0, Q_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                IndentEmit((CommonToken)Q);
                            }
                            PushFollow(FOLLOW_assignmentExpression_in_conditionalExpression10556);
                            assignmentExpression256 = assignmentExpression();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression256.Tree);
                            if (state.backtracking == 0)
                            {
                                PopIndent();
                            }
                            C = (IToken)Match(input, COLON, FOLLOW_COLON_in_conditionalExpression10563); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                C_tree = (object)adaptor.Create(C);
                                adaptor.AddChild(root_0, C_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                IndentEmit((CommonToken)C);
                            }
                            PushFollow(FOLLOW_assignmentExpression_in_conditionalExpression10568);
                            assignmentExpression257 = assignmentExpression();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression257.Tree);
                            if (state.backtracking == 0)
                            {
                                PopIndent();
                            }

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 106, conditionalExpression_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "conditionalExpression"

    public class conditionalExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "conditionalExpressionNoIn"
    // AS3_ex.g3:2249:1: conditionalExpressionNoIn : logicalORExpressionNoIn (Q= QUE assignmentExpression C= COLON assignmentExpression )? ;
    public AS3_exParser.conditionalExpressionNoIn_return conditionalExpressionNoIn() // throws RecognitionException [1]
    {
        AS3_exParser.conditionalExpressionNoIn_return retval = new AS3_exParser.conditionalExpressionNoIn_return();
        retval.Start = input.LT(1);
        int conditionalExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken Q = null;
        IToken C = null;
        AS3_exParser.logicalORExpressionNoIn_return logicalORExpressionNoIn258 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression259 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression260 = null;


        object Q_tree = null;
        object C_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 107))
            {
                return retval;
            }
            // AS3_ex.g3:2250:5: ( logicalORExpressionNoIn (Q= QUE assignmentExpression C= COLON assignmentExpression )? )
            // AS3_ex.g3:2250:9: logicalORExpressionNoIn (Q= QUE assignmentExpression C= COLON assignmentExpression )?
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_logicalORExpressionNoIn_in_conditionalExpressionNoIn10595);
                logicalORExpressionNoIn258 = logicalORExpressionNoIn();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, logicalORExpressionNoIn258.Tree);
                // AS3_ex.g3:2250:33: (Q= QUE assignmentExpression C= COLON assignmentExpression )?
                int alt118 = 2;
                int LA118_0 = input.LA(1);

                if ((LA118_0 == QUE))
                {
                    alt118 = 1;
                }
                switch (alt118)
                {
                    case 1:
                        // AS3_ex.g3:2250:35: Q= QUE assignmentExpression C= COLON assignmentExpression
                        {
                            Q = (IToken)Match(input, QUE, FOLLOW_QUE_in_conditionalExpressionNoIn10601); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                Q_tree = (object)adaptor.Create(Q);
                                adaptor.AddChild(root_0, Q_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                IndentEmit((CommonToken)Q);
                            }
                            PushFollow(FOLLOW_assignmentExpression_in_conditionalExpressionNoIn10605);
                            assignmentExpression259 = assignmentExpression();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression259.Tree);
                            if (state.backtracking == 0)
                            {
                                PopIndent();
                            }
                            C = (IToken)Match(input, COLON, FOLLOW_COLON_in_conditionalExpressionNoIn10612); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                C_tree = (object)adaptor.Create(C);
                                adaptor.AddChild(root_0, C_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                IndentEmit((CommonToken)C);
                            }
                            PushFollow(FOLLOW_assignmentExpression_in_conditionalExpressionNoIn10617);
                            assignmentExpression260 = assignmentExpression();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression260.Tree);
                            if (state.backtracking == 0)
                            {
                                PopIndent();
                            }

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 107, conditionalExpressionNoIn_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "conditionalExpressionNoIn"

    public class logicalORExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "logicalORExpression"
    // AS3_ex.g3:2254:1: logicalORExpression : logicalANDExpression (L= LOR logicalANDExpression )* ;
    public AS3_exParser.logicalORExpression_return logicalORExpression() // throws RecognitionException [1]
    {
        AS3_exParser.logicalORExpression_return retval = new AS3_exParser.logicalORExpression_return();
        retval.Start = input.LT(1);
        int logicalORExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        AS3_exParser.logicalANDExpression_return logicalANDExpression261 = null;

        AS3_exParser.logicalANDExpression_return logicalANDExpression262 = null;


        object L_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 108))
            {
                return retval;
            }
            // AS3_ex.g3:2255:5: ( logicalANDExpression (L= LOR logicalANDExpression )* )
            // AS3_ex.g3:2255:9: logicalANDExpression (L= LOR logicalANDExpression )*
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_logicalANDExpression_in_logicalORExpression10649);
                logicalANDExpression261 = logicalANDExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, logicalANDExpression261.Tree);
                // AS3_ex.g3:2255:30: (L= LOR logicalANDExpression )*
                do
                {
                    int alt119 = 2;
                    int LA119_0 = input.LA(1);

                    if ((LA119_0 == LOR))
                    {
                        alt119 = 1;
                    }


                    switch (alt119)
                    {
                        case 1:
                            // AS3_ex.g3:2255:32: L= LOR logicalANDExpression
                            {
                                L = (IToken)Match(input, LOR, FOLLOW_LOR_in_logicalORExpression10655); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    L_tree = (object)adaptor.Create(L);
                                    adaptor.AddChild(root_0, L_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    IndentEmit((CommonToken)L);
                                }
                                PushFollow(FOLLOW_logicalANDExpression_in_logicalORExpression10659);
                                logicalANDExpression262 = logicalANDExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, logicalANDExpression262.Tree);
                                if (state.backtracking == 0)
                                {
                                    PopIndent();
                                }

                            }
                            break;

                        default:
                            goto loop119;
                    }
                } while (true);

            loop119:
                ;	// Stops C# compiler whining that label 'loop119' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 108, logicalORExpression_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "logicalORExpression"

    public class logicalORExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "logicalORExpressionNoIn"
    // AS3_ex.g3:2258:1: logicalORExpressionNoIn : logicalANDExpressionNoIn (L= LOR logicalANDExpressionNoIn )* ;
    public AS3_exParser.logicalORExpressionNoIn_return logicalORExpressionNoIn() // throws RecognitionException [1]
    {
        AS3_exParser.logicalORExpressionNoIn_return retval = new AS3_exParser.logicalORExpressionNoIn_return();
        retval.Start = input.LT(1);
        int logicalORExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        AS3_exParser.logicalANDExpressionNoIn_return logicalANDExpressionNoIn263 = null;

        AS3_exParser.logicalANDExpressionNoIn_return logicalANDExpressionNoIn264 = null;


        object L_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 109))
            {
                return retval;
            }
            // AS3_ex.g3:2259:5: ( logicalANDExpressionNoIn (L= LOR logicalANDExpressionNoIn )* )
            // AS3_ex.g3:2259:9: logicalANDExpressionNoIn (L= LOR logicalANDExpressionNoIn )*
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_logicalANDExpressionNoIn_in_logicalORExpressionNoIn10687);
                logicalANDExpressionNoIn263 = logicalANDExpressionNoIn();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, logicalANDExpressionNoIn263.Tree);
                // AS3_ex.g3:2259:34: (L= LOR logicalANDExpressionNoIn )*
                do
                {
                    int alt120 = 2;
                    int LA120_0 = input.LA(1);

                    if ((LA120_0 == LOR))
                    {
                        alt120 = 1;
                    }


                    switch (alt120)
                    {
                        case 1:
                            // AS3_ex.g3:2259:36: L= LOR logicalANDExpressionNoIn
                            {
                                L = (IToken)Match(input, LOR, FOLLOW_LOR_in_logicalORExpressionNoIn10693); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    L_tree = (object)adaptor.Create(L);
                                    adaptor.AddChild(root_0, L_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    IndentEmit((CommonToken)L);
                                }
                                PushFollow(FOLLOW_logicalANDExpressionNoIn_in_logicalORExpressionNoIn10697);
                                logicalANDExpressionNoIn264 = logicalANDExpressionNoIn();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, logicalANDExpressionNoIn264.Tree);
                                if (state.backtracking == 0)
                                {
                                    PopIndent();
                                }

                            }
                            break;

                        default:
                            goto loop120;
                    }
                } while (true);

            loop120:
                ;	// Stops C# compiler whining that label 'loop120' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 109, logicalORExpressionNoIn_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "logicalORExpressionNoIn"

    public class logicalANDExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "logicalANDExpression"
    // AS3_ex.g3:2262:1: logicalANDExpression : bitwiseORExpression (L= LAND bitwiseORExpression )* ;
    public AS3_exParser.logicalANDExpression_return logicalANDExpression() // throws RecognitionException [1]
    {
        AS3_exParser.logicalANDExpression_return retval = new AS3_exParser.logicalANDExpression_return();
        retval.Start = input.LT(1);
        int logicalANDExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        AS3_exParser.bitwiseORExpression_return bitwiseORExpression265 = null;

        AS3_exParser.bitwiseORExpression_return bitwiseORExpression266 = null;


        object L_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 110))
            {
                return retval;
            }
            // AS3_ex.g3:2263:5: ( bitwiseORExpression (L= LAND bitwiseORExpression )* )
            // AS3_ex.g3:2263:9: bitwiseORExpression (L= LAND bitwiseORExpression )*
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_bitwiseORExpression_in_logicalANDExpression10729);
                bitwiseORExpression265 = bitwiseORExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseORExpression265.Tree);
                // AS3_ex.g3:2263:29: (L= LAND bitwiseORExpression )*
                do
                {
                    int alt121 = 2;
                    int LA121_0 = input.LA(1);

                    if ((LA121_0 == LAND))
                    {
                        alt121 = 1;
                    }


                    switch (alt121)
                    {
                        case 1:
                            // AS3_ex.g3:2263:31: L= LAND bitwiseORExpression
                            {
                                L = (IToken)Match(input, LAND, FOLLOW_LAND_in_logicalANDExpression10735); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    L_tree = (object)adaptor.Create(L);
                                    adaptor.AddChild(root_0, L_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    IndentEmit((CommonToken)L);
                                }
                                PushFollow(FOLLOW_bitwiseORExpression_in_logicalANDExpression10739);
                                bitwiseORExpression266 = bitwiseORExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseORExpression266.Tree);
                                if (state.backtracking == 0)
                                {
                                    PopIndent();
                                }

                            }
                            break;

                        default:
                            goto loop121;
                    }
                } while (true);

            loop121:
                ;	// Stops C# compiler whining that label 'loop121' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 110, logicalANDExpression_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "logicalANDExpression"

    public class logicalANDExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "logicalANDExpressionNoIn"
    // AS3_ex.g3:2266:1: logicalANDExpressionNoIn : bitwiseORExpressionNoIn (L= LAND bitwiseORExpressionNoIn )* ;
    public AS3_exParser.logicalANDExpressionNoIn_return logicalANDExpressionNoIn() // throws RecognitionException [1]
    {
        AS3_exParser.logicalANDExpressionNoIn_return retval = new AS3_exParser.logicalANDExpressionNoIn_return();
        retval.Start = input.LT(1);
        int logicalANDExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        AS3_exParser.bitwiseORExpressionNoIn_return bitwiseORExpressionNoIn267 = null;

        AS3_exParser.bitwiseORExpressionNoIn_return bitwiseORExpressionNoIn268 = null;


        object L_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 111))
            {
                return retval;
            }
            // AS3_ex.g3:2267:5: ( bitwiseORExpressionNoIn (L= LAND bitwiseORExpressionNoIn )* )
            // AS3_ex.g3:2267:9: bitwiseORExpressionNoIn (L= LAND bitwiseORExpressionNoIn )*
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn10766);
                bitwiseORExpressionNoIn267 = bitwiseORExpressionNoIn();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseORExpressionNoIn267.Tree);
                // AS3_ex.g3:2267:33: (L= LAND bitwiseORExpressionNoIn )*
                do
                {
                    int alt122 = 2;
                    int LA122_0 = input.LA(1);

                    if ((LA122_0 == LAND))
                    {
                        alt122 = 1;
                    }


                    switch (alt122)
                    {
                        case 1:
                            // AS3_ex.g3:2267:35: L= LAND bitwiseORExpressionNoIn
                            {
                                L = (IToken)Match(input, LAND, FOLLOW_LAND_in_logicalANDExpressionNoIn10772); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    L_tree = (object)adaptor.Create(L);
                                    adaptor.AddChild(root_0, L_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    IndentEmit((CommonToken)L);
                                }
                                PushFollow(FOLLOW_bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn10776);
                                bitwiseORExpressionNoIn268 = bitwiseORExpressionNoIn();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseORExpressionNoIn268.Tree);
                                if (state.backtracking == 0)
                                {
                                    PopIndent();
                                }

                            }
                            break;

                        default:
                            goto loop122;
                    }
                } while (true);

            loop122:
                ;	// Stops C# compiler whining that label 'loop122' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 111, logicalANDExpressionNoIn_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "logicalANDExpressionNoIn"

    public class bitwiseORExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "bitwiseORExpression"
    // AS3_ex.g3:2271:1: bitwiseORExpression : bitwiseXORExpression (O= OR bitwiseXORExpression )* ;
    public AS3_exParser.bitwiseORExpression_return bitwiseORExpression() // throws RecognitionException [1]
    {
        AS3_exParser.bitwiseORExpression_return retval = new AS3_exParser.bitwiseORExpression_return();
        retval.Start = input.LT(1);
        int bitwiseORExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken O = null;
        AS3_exParser.bitwiseXORExpression_return bitwiseXORExpression269 = null;

        AS3_exParser.bitwiseXORExpression_return bitwiseXORExpression270 = null;


        object O_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 112))
            {
                return retval;
            }
            // AS3_ex.g3:2272:5: ( bitwiseXORExpression (O= OR bitwiseXORExpression )* )
            // AS3_ex.g3:2272:9: bitwiseXORExpression (O= OR bitwiseXORExpression )*
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_bitwiseXORExpression_in_bitwiseORExpression10808);
                bitwiseXORExpression269 = bitwiseXORExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseXORExpression269.Tree);
                // AS3_ex.g3:2272:30: (O= OR bitwiseXORExpression )*
                do
                {
                    int alt123 = 2;
                    int LA123_0 = input.LA(1);

                    if ((LA123_0 == OR))
                    {
                        alt123 = 1;
                    }


                    switch (alt123)
                    {
                        case 1:
                            // AS3_ex.g3:2272:32: O= OR bitwiseXORExpression
                            {
                                O = (IToken)Match(input, OR, FOLLOW_OR_in_bitwiseORExpression10814); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    O_tree = (object)adaptor.Create(O);
                                    adaptor.AddChild(root_0, O_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    IndentEmit((CommonToken)O);
                                }
                                PushFollow(FOLLOW_bitwiseXORExpression_in_bitwiseORExpression10818);
                                bitwiseXORExpression270 = bitwiseXORExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseXORExpression270.Tree);
                                if (state.backtracking == 0)
                                {
                                    PopIndent();
                                }

                            }
                            break;

                        default:
                            goto loop123;
                    }
                } while (true);

            loop123:
                ;	// Stops C# compiler whining that label 'loop123' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 112, bitwiseORExpression_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "bitwiseORExpression"

    public class bitwiseORExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "bitwiseORExpressionNoIn"
    // AS3_ex.g3:2275:1: bitwiseORExpressionNoIn : bitwiseXORExpressionNoIn (O= OR bitwiseXORExpressionNoIn )* ;
    public AS3_exParser.bitwiseORExpressionNoIn_return bitwiseORExpressionNoIn() // throws RecognitionException [1]
    {
        AS3_exParser.bitwiseORExpressionNoIn_return retval = new AS3_exParser.bitwiseORExpressionNoIn_return();
        retval.Start = input.LT(1);
        int bitwiseORExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken O = null;
        AS3_exParser.bitwiseXORExpressionNoIn_return bitwiseXORExpressionNoIn271 = null;

        AS3_exParser.bitwiseXORExpressionNoIn_return bitwiseXORExpressionNoIn272 = null;


        object O_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 113))
            {
                return retval;
            }
            // AS3_ex.g3:2276:5: ( bitwiseXORExpressionNoIn (O= OR bitwiseXORExpressionNoIn )* )
            // AS3_ex.g3:2276:9: bitwiseXORExpressionNoIn (O= OR bitwiseXORExpressionNoIn )*
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn10845);
                bitwiseXORExpressionNoIn271 = bitwiseXORExpressionNoIn();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseXORExpressionNoIn271.Tree);
                // AS3_ex.g3:2276:34: (O= OR bitwiseXORExpressionNoIn )*
                do
                {
                    int alt124 = 2;
                    int LA124_0 = input.LA(1);

                    if ((LA124_0 == OR))
                    {
                        alt124 = 1;
                    }


                    switch (alt124)
                    {
                        case 1:
                            // AS3_ex.g3:2276:36: O= OR bitwiseXORExpressionNoIn
                            {
                                O = (IToken)Match(input, OR, FOLLOW_OR_in_bitwiseORExpressionNoIn10851); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    O_tree = (object)adaptor.Create(O);
                                    adaptor.AddChild(root_0, O_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    IndentEmit((CommonToken)O);
                                }
                                PushFollow(FOLLOW_bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn10855);
                                bitwiseXORExpressionNoIn272 = bitwiseXORExpressionNoIn();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseXORExpressionNoIn272.Tree);
                                if (state.backtracking == 0)
                                {
                                    PopIndent();
                                }

                            }
                            break;

                        default:
                            goto loop124;
                    }
                } while (true);

            loop124:
                ;	// Stops C# compiler whining that label 'loop124' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 113, bitwiseORExpressionNoIn_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "bitwiseORExpressionNoIn"

    public class bitwiseXORExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "bitwiseXORExpression"
    // AS3_ex.g3:2279:1: bitwiseXORExpression : bitwiseANDExpression (x= XOR bitwiseANDExpression )* ;
    public AS3_exParser.bitwiseXORExpression_return bitwiseXORExpression() // throws RecognitionException [1]
    {
        AS3_exParser.bitwiseXORExpression_return retval = new AS3_exParser.bitwiseXORExpression_return();
        retval.Start = input.LT(1);
        int bitwiseXORExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;
        AS3_exParser.bitwiseANDExpression_return bitwiseANDExpression273 = null;

        AS3_exParser.bitwiseANDExpression_return bitwiseANDExpression274 = null;


        object x_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 114))
            {
                return retval;
            }
            // AS3_ex.g3:2280:5: ( bitwiseANDExpression (x= XOR bitwiseANDExpression )* )
            // AS3_ex.g3:2280:9: bitwiseANDExpression (x= XOR bitwiseANDExpression )*
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_bitwiseANDExpression_in_bitwiseXORExpression10886);
                bitwiseANDExpression273 = bitwiseANDExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseANDExpression273.Tree);
                // AS3_ex.g3:2280:30: (x= XOR bitwiseANDExpression )*
                do
                {
                    int alt125 = 2;
                    int LA125_0 = input.LA(1);

                    if ((LA125_0 == XOR))
                    {
                        alt125 = 1;
                    }


                    switch (alt125)
                    {
                        case 1:
                            // AS3_ex.g3:2280:32: x= XOR bitwiseANDExpression
                            {
                                x = (IToken)Match(input, XOR, FOLLOW_XOR_in_bitwiseXORExpression10892); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    x_tree = (object)adaptor.Create(x);
                                    adaptor.AddChild(root_0, x_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    IndentEmit((CommonToken)x);
                                }
                                PushFollow(FOLLOW_bitwiseANDExpression_in_bitwiseXORExpression10896);
                                bitwiseANDExpression274 = bitwiseANDExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseANDExpression274.Tree);
                                if (state.backtracking == 0)
                                {
                                    PopIndent();
                                }

                            }
                            break;

                        default:
                            goto loop125;
                    }
                } while (true);

            loop125:
                ;	// Stops C# compiler whining that label 'loop125' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 114, bitwiseXORExpression_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "bitwiseXORExpression"

    public class bitwiseXORExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "bitwiseXORExpressionNoIn"
    // AS3_ex.g3:2283:1: bitwiseXORExpressionNoIn : bitwiseANDExpressionNoIn (x= XOR bitwiseANDExpressionNoIn )* ;
    public AS3_exParser.bitwiseXORExpressionNoIn_return bitwiseXORExpressionNoIn() // throws RecognitionException [1]
    {
        AS3_exParser.bitwiseXORExpressionNoIn_return retval = new AS3_exParser.bitwiseXORExpressionNoIn_return();
        retval.Start = input.LT(1);
        int bitwiseXORExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken x = null;
        AS3_exParser.bitwiseANDExpressionNoIn_return bitwiseANDExpressionNoIn275 = null;

        AS3_exParser.bitwiseANDExpressionNoIn_return bitwiseANDExpressionNoIn276 = null;


        object x_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 115))
            {
                return retval;
            }
            // AS3_ex.g3:2284:5: ( bitwiseANDExpressionNoIn (x= XOR bitwiseANDExpressionNoIn )* )
            // AS3_ex.g3:2284:9: bitwiseANDExpressionNoIn (x= XOR bitwiseANDExpressionNoIn )*
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn10923);
                bitwiseANDExpressionNoIn275 = bitwiseANDExpressionNoIn();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseANDExpressionNoIn275.Tree);
                // AS3_ex.g3:2284:34: (x= XOR bitwiseANDExpressionNoIn )*
                do
                {
                    int alt126 = 2;
                    int LA126_0 = input.LA(1);

                    if ((LA126_0 == XOR))
                    {
                        alt126 = 1;
                    }


                    switch (alt126)
                    {
                        case 1:
                            // AS3_ex.g3:2284:36: x= XOR bitwiseANDExpressionNoIn
                            {
                                x = (IToken)Match(input, XOR, FOLLOW_XOR_in_bitwiseXORExpressionNoIn10929); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    x_tree = (object)adaptor.Create(x);
                                    adaptor.AddChild(root_0, x_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    IndentEmit((CommonToken)x);
                                }
                                PushFollow(FOLLOW_bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn10933);
                                bitwiseANDExpressionNoIn276 = bitwiseANDExpressionNoIn();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseANDExpressionNoIn276.Tree);
                                if (state.backtracking == 0)
                                {
                                    PopIndent();
                                }

                            }
                            break;

                        default:
                            goto loop126;
                    }
                } while (true);

            loop126:
                ;	// Stops C# compiler whining that label 'loop126' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 115, bitwiseXORExpressionNoIn_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "bitwiseXORExpressionNoIn"

    public class bitwiseANDExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "bitwiseANDExpression"
    // AS3_ex.g3:2287:1: bitwiseANDExpression : equalityExpression (A= AND equalityExpression )* ;
    public AS3_exParser.bitwiseANDExpression_return bitwiseANDExpression() // throws RecognitionException [1]
    {
        AS3_exParser.bitwiseANDExpression_return retval = new AS3_exParser.bitwiseANDExpression_return();
        retval.Start = input.LT(1);
        int bitwiseANDExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken A = null;
        AS3_exParser.equalityExpression_return equalityExpression277 = null;

        AS3_exParser.equalityExpression_return equalityExpression278 = null;


        object A_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 116))
            {
                return retval;
            }
            // AS3_ex.g3:2288:5: ( equalityExpression (A= AND equalityExpression )* )
            // AS3_ex.g3:2288:9: equalityExpression (A= AND equalityExpression )*
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_equalityExpression_in_bitwiseANDExpression10960);
                equalityExpression277 = equalityExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, equalityExpression277.Tree);
                // AS3_ex.g3:2288:28: (A= AND equalityExpression )*
                do
                {
                    int alt127 = 2;
                    int LA127_0 = input.LA(1);

                    if ((LA127_0 == AND))
                    {
                        alt127 = 1;
                    }


                    switch (alt127)
                    {
                        case 1:
                            // AS3_ex.g3:2288:30: A= AND equalityExpression
                            {
                                A = (IToken)Match(input, AND, FOLLOW_AND_in_bitwiseANDExpression10966); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    A_tree = (object)adaptor.Create(A);
                                    adaptor.AddChild(root_0, A_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    IndentEmit((CommonToken)A);
                                }
                                PushFollow(FOLLOW_equalityExpression_in_bitwiseANDExpression10970);
                                equalityExpression278 = equalityExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, equalityExpression278.Tree);
                                if (state.backtracking == 0)
                                {
                                    PopIndent();
                                }

                            }
                            break;

                        default:
                            goto loop127;
                    }
                } while (true);

            loop127:
                ;	// Stops C# compiler whining that label 'loop127' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 116, bitwiseANDExpression_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "bitwiseANDExpression"

    public class bitwiseANDExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "bitwiseANDExpressionNoIn"
    // AS3_ex.g3:2291:1: bitwiseANDExpressionNoIn : equalityExpressionNoIn (A= AND equalityExpressionNoIn )* ;
    public AS3_exParser.bitwiseANDExpressionNoIn_return bitwiseANDExpressionNoIn() // throws RecognitionException [1]
    {
        AS3_exParser.bitwiseANDExpressionNoIn_return retval = new AS3_exParser.bitwiseANDExpressionNoIn_return();
        retval.Start = input.LT(1);
        int bitwiseANDExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken A = null;
        AS3_exParser.equalityExpressionNoIn_return equalityExpressionNoIn279 = null;

        AS3_exParser.equalityExpressionNoIn_return equalityExpressionNoIn280 = null;


        object A_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 117))
            {
                return retval;
            }
            // AS3_ex.g3:2292:5: ( equalityExpressionNoIn (A= AND equalityExpressionNoIn )* )
            // AS3_ex.g3:2292:9: equalityExpressionNoIn (A= AND equalityExpressionNoIn )*
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_equalityExpressionNoIn_in_bitwiseANDExpressionNoIn10997);
                equalityExpressionNoIn279 = equalityExpressionNoIn();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, equalityExpressionNoIn279.Tree);
                // AS3_ex.g3:2292:32: (A= AND equalityExpressionNoIn )*
                do
                {
                    int alt128 = 2;
                    int LA128_0 = input.LA(1);

                    if ((LA128_0 == AND))
                    {
                        alt128 = 1;
                    }


                    switch (alt128)
                    {
                        case 1:
                            // AS3_ex.g3:2292:34: A= AND equalityExpressionNoIn
                            {
                                A = (IToken)Match(input, AND, FOLLOW_AND_in_bitwiseANDExpressionNoIn11003); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    A_tree = (object)adaptor.Create(A);
                                    adaptor.AddChild(root_0, A_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    IndentEmit((CommonToken)A);
                                }
                                PushFollow(FOLLOW_equalityExpressionNoIn_in_bitwiseANDExpressionNoIn11007);
                                equalityExpressionNoIn280 = equalityExpressionNoIn();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, equalityExpressionNoIn280.Tree);
                                if (state.backtracking == 0)
                                {
                                    PopIndent();
                                }

                            }
                            break;

                        default:
                            goto loop128;
                    }
                } while (true);

            loop128:
                ;	// Stops C# compiler whining that label 'loop128' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 117, bitwiseANDExpressionNoIn_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "bitwiseANDExpressionNoIn"

    public class equalityExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "equalityExpression"
    // AS3_ex.g3:2296:1: equalityExpression : relationalExpression (eq= ( EQ | NEQ | SAME | NSAME ) relationalExpression )* ;
    public AS3_exParser.equalityExpression_return equalityExpression() // throws RecognitionException [1]
    {
        AS3_exParser.equalityExpression_return retval = new AS3_exParser.equalityExpression_return();
        retval.Start = input.LT(1);
        int equalityExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken eq = null;
        AS3_exParser.relationalExpression_return relationalExpression281 = null;

        AS3_exParser.relationalExpression_return relationalExpression282 = null;


        //object eq_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 118))
            {
                return retval;
            }
            // AS3_ex.g3:2297:5: ( relationalExpression (eq= ( EQ | NEQ | SAME | NSAME ) relationalExpression )* )
            // AS3_ex.g3:2297:9: relationalExpression (eq= ( EQ | NEQ | SAME | NSAME ) relationalExpression )*
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_relationalExpression_in_equalityExpression11035);
                relationalExpression281 = relationalExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, relationalExpression281.Tree);
                // AS3_ex.g3:2297:30: (eq= ( EQ | NEQ | SAME | NSAME ) relationalExpression )*
                do
                {
                    int alt129 = 2;
                    int LA129_0 = input.LA(1);

                    if (((LA129_0 >= EQ && LA129_0 <= NSAME)))
                    {
                        alt129 = 1;
                    }


                    switch (alt129)
                    {
                        case 1:
                            // AS3_ex.g3:2297:32: eq= ( EQ | NEQ | SAME | NSAME ) relationalExpression
                            {
                                eq = (IToken)input.LT(1);
                                if ((input.LA(1) >= EQ && input.LA(1) <= NSAME))
                                {
                                    input.Consume();
                                    if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(eq));
                                    state.errorRecovery = false; state.failed = false;
                                }
                                else
                                {
                                    if (state.backtracking > 0) { state.failed = true; return retval; }
                                    MismatchedSetException mse = new MismatchedSetException(null, input);
                                    throw mse;
                                }

                                if (state.backtracking == 0)
                                {
                                    IndentEmit((CommonToken)eq);
                                }
                                PushFollow(FOLLOW_relationalExpression_in_equalityExpression11053);
                                relationalExpression282 = relationalExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, relationalExpression282.Tree);
                                if (state.backtracking == 0)
                                {
                                    PopIndent();
                                }

                            }
                            break;

                        default:
                            goto loop129;
                    }
                } while (true);

            loop129:
                ;	// Stops C# compiler whining that label 'loop129' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 118, equalityExpression_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "equalityExpression"

    public class equalityExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "equalityExpressionNoIn"
    // AS3_ex.g3:2300:1: equalityExpressionNoIn : relationalExpressionNoIn (eq= ( EQ | NEQ | SAME | NSAME ) relationalExpressionNoIn )* ;
    public AS3_exParser.equalityExpressionNoIn_return equalityExpressionNoIn() // throws RecognitionException [1]
    {
        AS3_exParser.equalityExpressionNoIn_return retval = new AS3_exParser.equalityExpressionNoIn_return();
        retval.Start = input.LT(1);
        int equalityExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken eq = null;
        AS3_exParser.relationalExpressionNoIn_return relationalExpressionNoIn283 = null;

        AS3_exParser.relationalExpressionNoIn_return relationalExpressionNoIn284 = null;


        //object eq_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 119))
            {
                return retval;
            }
            // AS3_ex.g3:2301:5: ( relationalExpressionNoIn (eq= ( EQ | NEQ | SAME | NSAME ) relationalExpressionNoIn )* )
            // AS3_ex.g3:2301:9: relationalExpressionNoIn (eq= ( EQ | NEQ | SAME | NSAME ) relationalExpressionNoIn )*
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_relationalExpressionNoIn_in_equalityExpressionNoIn11080);
                relationalExpressionNoIn283 = relationalExpressionNoIn();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, relationalExpressionNoIn283.Tree);
                // AS3_ex.g3:2301:34: (eq= ( EQ | NEQ | SAME | NSAME ) relationalExpressionNoIn )*
                do
                {
                    int alt130 = 2;
                    int LA130_0 = input.LA(1);

                    if (((LA130_0 >= EQ && LA130_0 <= NSAME)))
                    {
                        alt130 = 1;
                    }


                    switch (alt130)
                    {
                        case 1:
                            // AS3_ex.g3:2301:36: eq= ( EQ | NEQ | SAME | NSAME ) relationalExpressionNoIn
                            {
                                eq = (IToken)input.LT(1);
                                if ((input.LA(1) >= EQ && input.LA(1) <= NSAME))
                                {
                                    input.Consume();
                                    if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(eq));
                                    state.errorRecovery = false; state.failed = false;
                                }
                                else
                                {
                                    if (state.backtracking > 0) { state.failed = true; return retval; }
                                    MismatchedSetException mse = new MismatchedSetException(null, input);
                                    throw mse;
                                }

                                if (state.backtracking == 0)
                                {
                                    IndentEmit((CommonToken)eq);
                                }
                                PushFollow(FOLLOW_relationalExpressionNoIn_in_equalityExpressionNoIn11099);
                                relationalExpressionNoIn284 = relationalExpressionNoIn();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, relationalExpressionNoIn284.Tree);
                                if (state.backtracking == 0)
                                {
                                    PopIndent();
                                }

                            }
                            break;

                        default:
                            goto loop130;
                    }
                } while (true);

            loop130:
                ;	// Stops C# compiler whining that label 'loop130' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 119, equalityExpressionNoIn_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "equalityExpressionNoIn"

    public class relationalExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "relationalExpression"
    // AS3_ex.g3:2305:1: relationalExpression : shiftExpression ( (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )* ;
    public AS3_exParser.relationalExpression_return relationalExpression() // throws RecognitionException [1]
    {
        AS3_exParser.relationalExpression_return retval = new AS3_exParser.relationalExpression_return();
        retval.Start = input.LT(1);
        int relationalExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken g = null;
        IToken assign = null;
        IToken eq = null;
        AS3_exParser.shiftExpression_return shiftExpression285 = null;

        AS3_exParser.shiftExpression_return shiftExpression286 = null;


        object g_tree = null;
        object assign_tree = null;
        //object eq_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 120))
            {
                return retval;
            }
            // AS3_ex.g3:2306:5: ( shiftExpression ( (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )* )
            // AS3_ex.g3:2306:9: shiftExpression ( (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )*
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_shiftExpression_in_relationalExpression11127);
                shiftExpression285 = shiftExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, shiftExpression285.Tree);
                // AS3_ex.g3:2307:6: ( (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )*
                do
                {
                    int alt133 = 2;
                    alt133 = dfa133.Predict(input);
                    switch (alt133)
                    {
                        case 1:
                            // AS3_ex.g3:2308:7: (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression
                            {
                                // AS3_ex.g3:2308:7: (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) )
                                int alt132 = 2;
                                int LA132_0 = input.LA(1);

                                if ((LA132_0 == GT))
                                {
                                    alt132 = 1;
                                }
                                else if ((LA132_0 == AS || (LA132_0 >= IN && LA132_0 <= INSTANCEOF) || LA132_0 == IS || LA132_0 == LT || LA132_0 == LTE))
                                {
                                    alt132 = 2;
                                }
                                else
                                {
                                    if (state.backtracking > 0) { state.failed = true; return retval; }
                                    NoViableAltException nvae_d132s0 =
                                        new NoViableAltException("", 132, 0, input);

                                    throw nvae_d132s0;
                                }
                                switch (alt132)
                                {
                                    case 1:
                                        // AS3_ex.g3:2308:9: g= GT (assign= ASSIGN )?
                                        {
                                            g = (IToken)Match(input, GT, FOLLOW_GT_in_relationalExpression11147); if (state.failed) return retval;
                                            if (state.backtracking == 0)
                                            {
                                                g_tree = (object)adaptor.Create(g);
                                                adaptor.AddChild(root_0, g_tree);
                                            }
                                            // AS3_ex.g3:2308:14: (assign= ASSIGN )?
                                            int alt131 = 2;
                                            int LA131_0 = input.LA(1);

                                            if ((LA131_0 == ASSIGN))
                                            {
                                                alt131 = 1;
                                            }
                                            switch (alt131)
                                            {
                                                case 1:
                                                    // AS3_ex.g3:2308:15: assign= ASSIGN
                                                    {
                                                        assign = (IToken)Match(input, ASSIGN, FOLLOW_ASSIGN_in_relationalExpression11152); if (state.failed) return retval;
                                                        if (state.backtracking == 0)
                                                        {
                                                            assign_tree = (object)adaptor.Create(assign);
                                                            adaptor.AddChild(root_0, assign_tree);
                                                        }

                                                    }
                                                    break;

                                            }

                                            if (state.backtracking == 0)
                                            {
                                                if (assign != null)
                                                {
                                                    g.Text = ">=";
                                                    g.Type = GTE;
                                                }
                                                IndentEmit((CommonToken)g);

                                            }

                                        }
                                        break;
                                    case 2:
                                        // AS3_ex.g3:2316:14: eq= ( IN | LT | LTE | INSTANCEOF | IS | AS )
                                        {
                                            eq = (IToken)input.LT(1);
                                            if (input.LA(1) == AS || (input.LA(1) >= IN && input.LA(1) <= INSTANCEOF) || input.LA(1) == IS || input.LA(1) == LT || input.LA(1) == LTE)
                                            {
                                                input.Consume();
                                                if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(eq));
                                                state.errorRecovery = false; state.failed = false;
                                            }
                                            else
                                            {
                                                if (state.backtracking > 0) { state.failed = true; return retval; }
                                                MismatchedSetException mse = new MismatchedSetException(null, input);
                                                throw mse;
                                            }

                                            if (state.backtracking == 0)
                                            {
                                                IndentEmit((CommonToken)eq);
                                            }

                                        }
                                        break;

                                }

                                PushFollow(FOLLOW_shiftExpression_in_relationalExpression11223);
                                shiftExpression286 = shiftExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, shiftExpression286.Tree);
                                if (state.backtracking == 0)
                                {
                                    PopIndent();
                                }

                            }
                            break;

                        default:
                            goto loop133;
                    }
                } while (true);

            loop133:
                ;	// Stops C# compiler whining that label 'loop133' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 120, relationalExpression_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "relationalExpression"

    public class relationalExpressionNoIn_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "relationalExpressionNoIn"
    // AS3_ex.g3:2322:1: relationalExpressionNoIn : shiftExpression ( (g= GT (assign= ASSIGN )? | eq= ( LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )* ;
    public AS3_exParser.relationalExpressionNoIn_return relationalExpressionNoIn() // throws RecognitionException [1]
    {
        AS3_exParser.relationalExpressionNoIn_return retval = new AS3_exParser.relationalExpressionNoIn_return();
        retval.Start = input.LT(1);
        int relationalExpressionNoIn_StartIndex = input.Index();
        object root_0 = null;

        IToken g = null;
        IToken assign = null;
        IToken eq = null;
        AS3_exParser.shiftExpression_return shiftExpression287 = null;

        AS3_exParser.shiftExpression_return shiftExpression288 = null;


        object g_tree = null;
        object assign_tree = null;
        //object eq_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 121))
            {
                return retval;
            }
            // AS3_ex.g3:2323:5: ( shiftExpression ( (g= GT (assign= ASSIGN )? | eq= ( LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )* )
            // AS3_ex.g3:2323:9: shiftExpression ( (g= GT (assign= ASSIGN )? | eq= ( LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )*
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_shiftExpression_in_relationalExpressionNoIn11259);
                shiftExpression287 = shiftExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, shiftExpression287.Tree);
                // AS3_ex.g3:2324:6: ( (g= GT (assign= ASSIGN )? | eq= ( LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )*
                do
                {
                    int alt136 = 2;
                    int LA136_0 = input.LA(1);

                    if ((LA136_0 == AS || LA136_0 == INSTANCEOF || LA136_0 == IS || (LA136_0 >= LT && LA136_0 <= LTE)))
                    {
                        alt136 = 1;
                    }


                    switch (alt136)
                    {
                        case 1:
                            // AS3_ex.g3:2325:7: (g= GT (assign= ASSIGN )? | eq= ( LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression
                            {
                                // AS3_ex.g3:2325:7: (g= GT (assign= ASSIGN )? | eq= ( LT | LTE | INSTANCEOF | IS | AS ) )
                                int alt135 = 2;
                                int LA135_0 = input.LA(1);

                                if ((LA135_0 == GT))
                                {
                                    alt135 = 1;
                                }
                                else if ((LA135_0 == AS || LA135_0 == INSTANCEOF || LA135_0 == IS || LA135_0 == LT || LA135_0 == LTE))
                                {
                                    alt135 = 2;
                                }
                                else
                                {
                                    if (state.backtracking > 0) { state.failed = true; return retval; }
                                    NoViableAltException nvae_d135s0 =
                                        new NoViableAltException("", 135, 0, input);

                                    throw nvae_d135s0;
                                }
                                switch (alt135)
                                {
                                    case 1:
                                        // AS3_ex.g3:2325:9: g= GT (assign= ASSIGN )?
                                        {
                                            g = (IToken)Match(input, GT, FOLLOW_GT_in_relationalExpressionNoIn11279); if (state.failed) return retval;
                                            if (state.backtracking == 0)
                                            {
                                                g_tree = (object)adaptor.Create(g);
                                                adaptor.AddChild(root_0, g_tree);
                                            }
                                            // AS3_ex.g3:2325:14: (assign= ASSIGN )?
                                            int alt134 = 2;
                                            int LA134_0 = input.LA(1);

                                            if ((LA134_0 == ASSIGN))
                                            {
                                                alt134 = 1;
                                            }
                                            switch (alt134)
                                            {
                                                case 1:
                                                    // AS3_ex.g3:2325:15: assign= ASSIGN
                                                    {
                                                        assign = (IToken)Match(input, ASSIGN, FOLLOW_ASSIGN_in_relationalExpressionNoIn11284); if (state.failed) return retval;
                                                        if (state.backtracking == 0)
                                                        {
                                                            assign_tree = (object)adaptor.Create(assign);
                                                            adaptor.AddChild(root_0, assign_tree);
                                                        }

                                                    }
                                                    break;

                                            }

                                            if (state.backtracking == 0)
                                            {
                                                if (assign != null)
                                                {
                                                    g.Text = ">=";
                                                    g.Type = GTE;
                                                }
                                                IndentEmit((CommonToken)g);

                                            }

                                        }
                                        break;
                                    case 2:
                                        // AS3_ex.g3:2333:14: eq= ( LT | LTE | INSTANCEOF | IS | AS )
                                        {
                                            eq = (IToken)input.LT(1);
                                            if (input.LA(1) == AS || input.LA(1) == INSTANCEOF || input.LA(1) == IS || input.LA(1) == LT || input.LA(1) == LTE)
                                            {
                                                input.Consume();
                                                if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(eq));
                                                state.errorRecovery = false; state.failed = false;
                                            }
                                            else
                                            {
                                                if (state.backtracking > 0) { state.failed = true; return retval; }
                                                MismatchedSetException mse = new MismatchedSetException(null, input);
                                                throw mse;
                                            }

                                            if (state.backtracking == 0)
                                            {
                                                IndentEmit((CommonToken)eq);
                                            }

                                        }
                                        break;

                                }

                                PushFollow(FOLLOW_shiftExpression_in_relationalExpressionNoIn11353);
                                shiftExpression288 = shiftExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, shiftExpression288.Tree);
                                if (state.backtracking == 0)
                                {
                                    PopIndent();
                                }

                            }
                            break;

                        default:
                            goto loop136;
                    }
                } while (true);

            loop136:
                ;	// Stops C# compiler whining that label 'loop136' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 121, relationalExpressionNoIn_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "relationalExpressionNoIn"

    public class shiftExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "shiftExpression"
    // AS3_ex.g3:2340:1: shiftExpression : additiveExpression ( (t1= SHL | ( ( '>' '>' )=>t1= '>' t2= '>' {...}? -> SHR ) | ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}? -> SHU ) ) additiveExpression )* ;
    public AS3_exParser.shiftExpression_return shiftExpression() // throws RecognitionException [1]
    {
        AS3_exParser.shiftExpression_return retval = new AS3_exParser.shiftExpression_return();
        retval.Start = input.LT(1);
        int shiftExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken t1 = null;
        IToken t2 = null;
        IToken t3 = null;
        AS3_exParser.additiveExpression_return additiveExpression289 = null;

        AS3_exParser.additiveExpression_return additiveExpression290 = null;


        //object t1_tree = null;
        //object t2_tree = null;
        //object t3_tree = null;
        RewriteRuleTokenStream stream_GT = new RewriteRuleTokenStream(adaptor, "token GT");
        RewriteRuleTokenStream stream_SHL = new RewriteRuleTokenStream(adaptor, "token SHL");
        RewriteRuleSubtreeStream stream_additiveExpression = new RewriteRuleSubtreeStream(adaptor, "rule additiveExpression");
        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 122))
            {
                return retval;
            }
            // AS3_ex.g3:2341:5: ( additiveExpression ( (t1= SHL | ( ( '>' '>' )=>t1= '>' t2= '>' {...}? -> SHR ) | ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}? -> SHU ) ) additiveExpression )* )
            // AS3_ex.g3:2341:9: additiveExpression ( (t1= SHL | ( ( '>' '>' )=>t1= '>' t2= '>' {...}? -> SHR ) | ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}? -> SHU ) ) additiveExpression )*
            {
                PushFollow(FOLLOW_additiveExpression_in_shiftExpression11386);
                additiveExpression289 = additiveExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) stream_additiveExpression.Add(additiveExpression289.Tree);
                // AS3_ex.g3:2341:28: ( (t1= SHL | ( ( '>' '>' )=>t1= '>' t2= '>' {...}? -> SHR ) | ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}? -> SHU ) ) additiveExpression )*
                do
                {
                    int alt138 = 2;
                    int LA138_0 = input.LA(1);

                    if ((LA138_0 == GT))
                    {
                        int LA138_1 = input.LA(2);

                        if ((LA138_1 == GT))
                        {
                            alt138 = 1;
                        }


                    }
                    else if ((LA138_0 == SHL))
                    {
                        alt138 = 1;
                    }


                    switch (alt138)
                    {
                        case 1:
                            // AS3_ex.g3:2342:7: (t1= SHL | ( ( '>' '>' )=>t1= '>' t2= '>' {...}? -> SHR ) | ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}? -> SHU ) ) additiveExpression
                            {
                                // AS3_ex.g3:2342:7: (t1= SHL | ( ( '>' '>' )=>t1= '>' t2= '>' {...}? -> SHR ) | ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}? -> SHU ) )
                                int alt137 = 3;
                                int LA137_0 = input.LA(1);

                                if ((LA137_0 == SHL))
                                {
                                    alt137 = 1;
                                }
                                else if ((LA137_0 == GT))
                                {
                                    int LA137_2 = input.LA(2);

                                    if ((LA137_2 == GT))
                                    {
                                        int LA137_3 = input.LA(3);

                                        if ((LA137_3 == GT) && (synpred285_AS3_ex()))
                                        {
                                            alt137 = 3;
                                        }
                                        else if (((LA137_3 >= AS && LA137_3 <= STATIC) || LA137_3 == LCURLY || LA137_3 == LPAREN || LA137_3 == LBRACK || LA137_3 == LT || (LA137_3 >= PLUS && LA137_3 <= STAR) || (LA137_3 >= INC && LA137_3 <= DEC) || (LA137_3 >= NOT && LA137_3 <= INV) || (LA137_3 >= XML_AT && LA137_3 <= XML_LS_STD) || (LA137_3 >= SINGLE_QUOTE_LITERAL && LA137_3 <= DOUBLE_QUOTE_LITERAL) || LA137_3 == REGULAR_EXPR_LITERAL || LA137_3 == HEX_NUMBER_LITERAL || LA137_3 == DEC_NUMBER_LITERAL || LA137_3 == IDENTIFIER || (LA137_3 >= XML_COMMENT && LA137_3 <= XML_PI)))
                                        {
                                            alt137 = 2;
                                        }
                                        else
                                        {
                                            if (state.backtracking > 0) { state.failed = true; return retval; }
                                            NoViableAltException nvae_d137s3 =
                                                new NoViableAltException("", 137, 3, input);

                                            throw nvae_d137s3;
                                        }
                                    }
                                    else
                                    {
                                        if (state.backtracking > 0) { state.failed = true; return retval; }
                                        NoViableAltException nvae_d137s2 =
                                            new NoViableAltException("", 137, 2, input);

                                        throw nvae_d137s2;
                                    }
                                }
                                else
                                {
                                    if (state.backtracking > 0) { state.failed = true; return retval; }
                                    NoViableAltException nvae_d137s0 =
                                        new NoViableAltException("", 137, 0, input);

                                    throw nvae_d137s0;
                                }
                                switch (alt137)
                                {
                                    case 1:
                                        // AS3_ex.g3:2343:8: t1= SHL
                                        {
                                            t1 = (IToken)Match(input, SHL, FOLLOW_SHL_in_shiftExpression11408); if (state.failed) return retval;
                                            if (state.backtracking == 0) stream_SHL.Add(t1);


                                        }
                                        break;
                                    case 2:
                                        // AS3_ex.g3:2344:11: ( ( '>' '>' )=>t1= '>' t2= '>' {...}? -> SHR )
                                        {
                                            // AS3_ex.g3:2344:11: ( ( '>' '>' )=>t1= '>' t2= '>' {...}? -> SHR )
                                            // AS3_ex.g3:2344:12: ( '>' '>' )=>t1= '>' t2= '>' {...}?
                                            {
                                                t1 = (IToken)Match(input, GT, FOLLOW_GT_in_shiftExpression11430); if (state.failed) return retval;
                                                if (state.backtracking == 0) stream_GT.Add(t1);

                                                t2 = (IToken)Match(input, GT, FOLLOW_GT_in_shiftExpression11434); if (state.failed) return retval;
                                                if (state.backtracking == 0) stream_GT.Add(t2);

                                                if (!((t1.Line == t2.Line &&
                                                                    t1.CharPositionInLine + 1 == t2.CharPositionInLine)))
                                                {
                                                    if (state.backtracking > 0) { state.failed = true; return retval; }
                                                    throw new FailedPredicateException(input, "shiftExpression", " $t1.Line == $t2.Line && \r\n          \t\t\t$t1.CharPositionInLine + 1 == $t2.CharPositionInLine ");
                                                }


                                                // AST REWRITE
                                                // elements:          
                                                // token labels:      
                                                // rule labels:       retval
                                                // token list labels: 
                                                // rule list labels:  
                                                if (state.backtracking == 0)
                                                {
                                                    retval.Tree = root_0;
                                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                                    root_0 = (object)adaptor.GetNilNode();
                                                    // 2347:10: -> SHR
                                                    {
                                                        adaptor.AddChild(root_0, (object)adaptor.Create(SHR, "SHR"));

                                                    }

                                                    retval.Tree = root_0; retval.Tree = root_0;
                                                }
                                            }

                                            if (state.backtracking == 0)
                                            {
                                                t1.Text = ">>";
                                            }

                                        }
                                        break;
                                    case 3:
                                        // AS3_ex.g3:2348:10: ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}? -> SHU )
                                        {
                                            // AS3_ex.g3:2348:10: ( ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}? -> SHU )
                                            // AS3_ex.g3:2348:11: ( '>' '>' '>' )=>t1= '>' t2= '>' t3= '>' {...}?
                                            {
                                                t1 = (IToken)Match(input, GT, FOLLOW_GT_in_shiftExpression11485); if (state.failed) return retval;
                                                if (state.backtracking == 0) stream_GT.Add(t1);

                                                t2 = (IToken)Match(input, GT, FOLLOW_GT_in_shiftExpression11489); if (state.failed) return retval;
                                                if (state.backtracking == 0) stream_GT.Add(t2);

                                                t3 = (IToken)Match(input, GT, FOLLOW_GT_in_shiftExpression11493); if (state.failed) return retval;
                                                if (state.backtracking == 0) stream_GT.Add(t3);

                                                if (!((t1.Line == t2.Line &&
                                                                    t1.CharPositionInLine + 1 == t2.CharPositionInLine &&
                                                                    t2.Line == t3.Line &&
                                                                    t2.CharPositionInLine + 1 == t3.CharPositionInLine)))
                                                {
                                                    if (state.backtracking > 0) { state.failed = true; return retval; }
                                                    throw new FailedPredicateException(input, "shiftExpression", " $t1.Line == $t2.Line && \r\n          \t\t\t$t1.CharPositionInLine + 1 == $t2.CharPositionInLine &&\r\n          \t\t\t$t2.Line == $t3.Line && \r\n          \t\t\t$t2.CharPositionInLine + 1 == $t3.CharPositionInLine ");
                                                }


                                                // AST REWRITE
                                                // elements:          
                                                // token labels:      
                                                // rule labels:       retval
                                                // token list labels: 
                                                // rule list labels:  
                                                if (state.backtracking == 0)
                                                {
                                                    retval.Tree = root_0;
                                                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "token retval", (retval != null ? retval.Tree : null));

                                                    root_0 = (object)adaptor.GetNilNode();
                                                    // 2353:10: -> SHU
                                                    {
                                                        adaptor.AddChild(root_0, (object)adaptor.Create(SHU, "SHU"));

                                                    }

                                                    retval.Tree = root_0; retval.Tree = root_0;
                                                }
                                            }

                                            if (state.backtracking == 0)
                                            {
                                                t1.Text = ">>>";
                                            }

                                        }
                                        break;

                                }

                                if (state.backtracking == 0)
                                {
                                    IndentEmit((CommonToken)t1);
                                }
                                PushFollow(FOLLOW_additiveExpression_in_shiftExpression11540);
                                additiveExpression290 = additiveExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) stream_additiveExpression.Add(additiveExpression290.Tree);
                                if (state.backtracking == 0)
                                {
                                    PopIndent();
                                }

                            }
                            break;

                        default:
                            goto loop138;
                    }
                } while (true);

            loop138:
                ;	// Stops C# compiler whining that label 'loop138' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 122, shiftExpression_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "shiftExpression"

    public class additiveExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "additiveExpression"
    // AS3_ex.g3:2360:1: additiveExpression : multiplicativeExpression (op= ( PLUS | SUB ) multiplicativeExpression )* ;
    public AS3_exParser.additiveExpression_return additiveExpression() // throws RecognitionException [1]
    {
        AS3_exParser.additiveExpression_return retval = new AS3_exParser.additiveExpression_return();
        retval.Start = input.LT(1);
        int additiveExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken op = null;
        AS3_exParser.multiplicativeExpression_return multiplicativeExpression291 = null;

        AS3_exParser.multiplicativeExpression_return multiplicativeExpression292 = null;


        //object op_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 123))
            {
                return retval;
            }
            // AS3_ex.g3:2361:5: ( multiplicativeExpression (op= ( PLUS | SUB ) multiplicativeExpression )* )
            // AS3_ex.g3:2361:9: multiplicativeExpression (op= ( PLUS | SUB ) multiplicativeExpression )*
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_multiplicativeExpression_in_additiveExpression11570);
                multiplicativeExpression291 = multiplicativeExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, multiplicativeExpression291.Tree);
                // AS3_ex.g3:2361:34: (op= ( PLUS | SUB ) multiplicativeExpression )*
                do
                {
                    int alt139 = 2;
                    alt139 = dfa139.Predict(input);
                    switch (alt139)
                    {
                        case 1:
                            // AS3_ex.g3:2361:36: op= ( PLUS | SUB ) multiplicativeExpression
                            {
                                op = (IToken)input.LT(1);
                                if ((input.LA(1) >= PLUS && input.LA(1) <= SUB))
                                {
                                    input.Consume();
                                    if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(op));
                                    state.errorRecovery = false; state.failed = false;
                                }
                                else
                                {
                                    if (state.backtracking > 0) { state.failed = true; return retval; }
                                    MismatchedSetException mse = new MismatchedSetException(null, input);
                                    throw mse;
                                }

                                if (state.backtracking == 0)
                                {
                                    IndentEmit((CommonToken)op);
                                }
                                PushFollow(FOLLOW_multiplicativeExpression_in_additiveExpression11584);
                                multiplicativeExpression292 = multiplicativeExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, multiplicativeExpression292.Tree);
                                if (state.backtracking == 0)
                                {
                                    PopIndent();
                                }

                            }
                            break;

                        default:
                            goto loop139;
                    }
                } while (true);

            loop139:
                ;	// Stops C# compiler whining that label 'loop139' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 123, additiveExpression_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "additiveExpression"

    public class multiplicativeExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "multiplicativeExpression"
    // AS3_ex.g3:2365:1: multiplicativeExpression : unaryExpression (op= ( STAR | DIV | MOD ) unaryExpression )* ;
    public AS3_exParser.multiplicativeExpression_return multiplicativeExpression() // throws RecognitionException [1]
    {
        AS3_exParser.multiplicativeExpression_return retval = new AS3_exParser.multiplicativeExpression_return();
        retval.Start = input.LT(1);
        int multiplicativeExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken op = null;
        AS3_exParser.unaryExpression_return unaryExpression293 = null;

        AS3_exParser.unaryExpression_return unaryExpression294 = null;


        //object op_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 124))
            {
                return retval;
            }
            // AS3_ex.g3:2366:5: ( unaryExpression (op= ( STAR | DIV | MOD ) unaryExpression )* )
            // AS3_ex.g3:2366:9: unaryExpression (op= ( STAR | DIV | MOD ) unaryExpression )*
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_unaryExpression_in_multiplicativeExpression11608);
                unaryExpression293 = unaryExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpression293.Tree);
                // AS3_ex.g3:2366:25: (op= ( STAR | DIV | MOD ) unaryExpression )*
                do
                {
                    int alt140 = 2;
                    alt140 = dfa140.Predict(input);
                    switch (alt140)
                    {
                        case 1:
                            // AS3_ex.g3:2366:27: op= ( STAR | DIV | MOD ) unaryExpression
                            {
                                op = (IToken)input.LT(1);
                                if ((input.LA(1) >= STAR && input.LA(1) <= MOD))
                                {
                                    input.Consume();
                                    if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(op));
                                    state.errorRecovery = false; state.failed = false;
                                }
                                else
                                {
                                    if (state.backtracking > 0) { state.failed = true; return retval; }
                                    MismatchedSetException mse = new MismatchedSetException(null, input);
                                    throw mse;
                                }

                                if (state.backtracking == 0)
                                {
                                    IndentEmit((CommonToken)op);
                                }
                                PushFollow(FOLLOW_unaryExpression_in_multiplicativeExpression11623);
                                unaryExpression294 = unaryExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpression294.Tree);
                                if (state.backtracking == 0)
                                {
                                    PopIndent();
                                }

                            }
                            break;

                        default:
                            goto loop140;
                    }
                } while (true);

            loop140:
                ;	// Stops C# compiler whining that label 'loop140' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 124, multiplicativeExpression_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "multiplicativeExpression"

    public class unaryExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "unaryExpression"
    // AS3_ex.g3:2370:1: unaryExpression : ( postfixExpression | op= ( NOT | INV ) unaryExpression | unaryOp postfixExpression );
    public AS3_exParser.unaryExpression_return unaryExpression() // throws RecognitionException [1]
    {
        AS3_exParser.unaryExpression_return retval = new AS3_exParser.unaryExpression_return();
        retval.Start = input.LT(1);
        int unaryExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken op = null;
        AS3_exParser.postfixExpression_return postfixExpression295 = null;

        AS3_exParser.unaryExpression_return unaryExpression296 = null;

        AS3_exParser.unaryOp_return unaryOp297 = null;

        AS3_exParser.postfixExpression_return postfixExpression298 = null;


        //object op_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 125))
            {
                return retval;
            }
            // AS3_ex.g3:2371:5: ( postfixExpression | op= ( NOT | INV ) unaryExpression | unaryOp postfixExpression )
            int alt141 = 3;
            alt141 = dfa141.Predict(input);
            switch (alt141)
            {
                case 1:
                    // AS3_ex.g3:2371:9: postfixExpression
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_postfixExpression_in_unaryExpression11647);
                        postfixExpression295 = postfixExpression();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, postfixExpression295.Tree);

                    }
                    break;
                case 2:
                    // AS3_ex.g3:2372:8: op= ( NOT | INV ) unaryExpression
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        op = (IToken)input.LT(1);
                        if ((input.LA(1) >= NOT && input.LA(1) <= INV))
                        {
                            input.Consume();
                            if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(op));
                            state.errorRecovery = false; state.failed = false;
                        }
                        else
                        {
                            if (state.backtracking > 0) { state.failed = true; return retval; }
                            MismatchedSetException mse = new MismatchedSetException(null, input);
                            throw mse;
                        }

                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)op);
                        }
                        PushFollow(FOLLOW_unaryExpression_in_unaryExpression11668);
                        unaryExpression296 = unaryExpression();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpression296.Tree);

                    }
                    break;
                case 3:
                    // AS3_ex.g3:2373:9: unaryOp postfixExpression
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_unaryOp_in_unaryExpression11678);
                        unaryOp297 = unaryOp();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, unaryOp297.Tree);
                        PushFollow(FOLLOW_postfixExpression_in_unaryExpression11680);
                        postfixExpression298 = postfixExpression();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, postfixExpression298.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 125, unaryExpression_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "unaryExpression"

    public class unaryOp_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "unaryOp"
    // AS3_ex.g3:2378:1: unaryOp : op= ( DELETE | VOID | TYPEOF | INC | DEC | PLUS | SUB | INV | NOT ) ;
    public AS3_exParser.unaryOp_return unaryOp() // throws RecognitionException [1]
    {
        AS3_exParser.unaryOp_return retval = new AS3_exParser.unaryOp_return();
        retval.Start = input.LT(1);
        int unaryOp_StartIndex = input.Index();
        object root_0 = null;

        IToken op = null;

        //object op_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 126))
            {
                return retval;
            }
            // AS3_ex.g3:2379:5: (op= ( DELETE | VOID | TYPEOF | INC | DEC | PLUS | SUB | INV | NOT ) )
            // AS3_ex.g3:2379:9: op= ( DELETE | VOID | TYPEOF | INC | DEC | PLUS | SUB | INV | NOT )
            {
                root_0 = (object)adaptor.GetNilNode();

                op = (IToken)input.LT(1);
                if (input.LA(1) == DELETE || input.LA(1) == TYPEOF || input.LA(1) == VOID || (input.LA(1) >= PLUS && input.LA(1) <= SUB) || (input.LA(1) >= INC && input.LA(1) <= DEC) || (input.LA(1) >= NOT && input.LA(1) <= INV))
                {
                    input.Consume();
                    if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(op));
                    state.errorRecovery = false; state.failed = false;
                }
                else
                {
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    MismatchedSetException mse = new MismatchedSetException(null, input);
                    throw mse;
                }

                if (state.backtracking == 0)
                {
                    Emit((CommonToken)op);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 126, unaryOp_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "unaryOp"

    public class postfixExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "postfixExpression"
    // AS3_ex.g3:2384:1: postfixExpression : leftHandSideExpression ( postfixOp )? ;
    public AS3_exParser.postfixExpression_return postfixExpression() // throws RecognitionException [1]
    {
        AS3_exParser.postfixExpression_return retval = new AS3_exParser.postfixExpression_return();
        retval.Start = input.LT(1);
        int postfixExpression_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.leftHandSideExpression_return leftHandSideExpression299 = null;

        AS3_exParser.postfixOp_return postfixOp300 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 127))
            {
                return retval;
            }
            // AS3_ex.g3:2385:5: ( leftHandSideExpression ( postfixOp )? )
            // AS3_ex.g3:2385:9: leftHandSideExpression ( postfixOp )?
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_leftHandSideExpression_in_postfixExpression11768);
                leftHandSideExpression299 = leftHandSideExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, leftHandSideExpression299.Tree);
                // AS3_ex.g3:2385:32: ( postfixOp )?
                int alt142 = 2;
                alt142 = dfa142.Predict(input);
                switch (alt142)
                {
                    case 1:
                        // AS3_ex.g3:0:0: postfixOp
                        {
                            PushFollow(FOLLOW_postfixOp_in_postfixExpression11770);
                            postfixOp300 = postfixOp();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, postfixOp300.Tree);

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 127, postfixExpression_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "postfixExpression"

    public class postfixOp_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "postfixOp"
    // AS3_ex.g3:2388:1: postfixOp : op= ( INC | DEC ) ;
    public AS3_exParser.postfixOp_return postfixOp() // throws RecognitionException [1]
    {
        AS3_exParser.postfixOp_return retval = new AS3_exParser.postfixOp_return();
        retval.Start = input.LT(1);
        int postfixOp_StartIndex = input.Index();
        object root_0 = null;

        IToken op = null;

        //object op_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 128))
            {
                return retval;
            }
            // AS3_ex.g3:2389:5: (op= ( INC | DEC ) )
            // AS3_ex.g3:2389:9: op= ( INC | DEC )
            {
                root_0 = (object)adaptor.GetNilNode();

                op = (IToken)input.LT(1);
                if ((input.LA(1) >= INC && input.LA(1) <= DEC))
                {
                    input.Consume();
                    if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(op));
                    state.errorRecovery = false; state.failed = false;
                }
                else
                {
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    MismatchedSetException mse = new MismatchedSetException(null, input);
                    throw mse;
                }

                if (state.backtracking == 0)
                {
                    Emit((CommonToken)op);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 128, postfixOp_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "postfixOp"

    public class memberExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "memberExpression"
    // AS3_ex.g3:2393:1: memberExpression : ( primaryExpression | functionExpression | newExpression );
    public AS3_exParser.memberExpression_return memberExpression() // throws RecognitionException [1]
    {
        AS3_exParser.memberExpression_return retval = new AS3_exParser.memberExpression_return();
        retval.Start = input.LT(1);
        int memberExpression_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.primaryExpression_return primaryExpression301 = null;

        AS3_exParser.functionExpression_return functionExpression302 = null;

        AS3_exParser.newExpression_return newExpression303 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 129))
            {
                return retval;
            }
            // AS3_ex.g3:2394:2: ( primaryExpression | functionExpression | newExpression )
            int alt143 = 3;
            switch (input.LA(1))
            {
                case AS:
                case BREAK:
                case CASE:
                case CATCH:
                case CLASS:
                case CONST:
                case CONTINUE:
                case DEFAULT:
                case DELETE:
                case DO:
                case ELSE:
                case EXTENDS:
                case FALSE:
                case FINALLY:
                case FOR:
                case IF:
                case IMPLEMENTS:
                case IMPORT:
                case IN:
                case INSTANCEOF:
                case INTERFACE:
                case INTERNAL:
                case IS:
                case NATIVE:
                case NULL:
                case PACKAGE:
                case PRIVATE:
                case PROTECTED:
                case PUBLIC:
                case RETURN:
                case SUPER:
                case SWITCH:
                case THIS:
                case THROW:
                case TO:
                case TRUE:
                case TRY:
                case TYPEOF:
                case USE:
                case VAR:
                case VOID:
                case WHILE:
                case WITH:
                case EACH:
                case GET:
                case SET:
                case NAMESPACE:
                case INCLUDE:
                case DYNAMIC:
                case FINAL:
                case OVERRIDE:
                case STATIC:
                case LCURLY:
                case LPAREN:
                case LBRACK:
                case LT:
                case STAR:
                case XML_AT:
                case XML_LS_STD:
                case SINGLE_QUOTE_LITERAL:
                case DOUBLE_QUOTE_LITERAL:
                case REGULAR_EXPR_LITERAL:
                case HEX_NUMBER_LITERAL:
                case DEC_NUMBER_LITERAL:
                case IDENTIFIER:
                case XML_COMMENT:
                case XML_CDATA:
                case XML_PI:
                    {
                        alt143 = 1;
                    }
                    break;
                case FUNCTION:
                    {
                        int LA143_2 = input.LA(2);

                        if ((LA143_2 == DOT || LA143_2 == SUB || LA143_2 == COLON || LA143_2 == XML_NS_OP))
                        {
                            alt143 = 1;
                        }
                        else if ((LA143_2 == LPAREN || LA143_2 == IDENTIFIER))
                        {
                            alt143 = 2;
                        }
                        else
                        {
                            if (state.backtracking > 0) { state.failed = true; return retval; }
                            NoViableAltException nvae_d143s2 =
                                new NoViableAltException("", 143, 2, input);

                            throw nvae_d143s2;
                        }
                    }
                    break;
                case NEW:
                    {
                        int LA143_3 = input.LA(2);

                        if ((LA143_3 == DOT || LA143_3 == SUB || LA143_3 == COLON || LA143_3 == XML_NS_OP))
                        {
                            alt143 = 1;
                        }
                        else if (((LA143_3 >= AS && LA143_3 <= STATIC) || LA143_3 == LCURLY || LA143_3 == LPAREN || LA143_3 == LBRACK || LA143_3 == LT || LA143_3 == STAR || (LA143_3 >= XML_AT && LA143_3 <= XML_LS_STD) || (LA143_3 >= SINGLE_QUOTE_LITERAL && LA143_3 <= DOUBLE_QUOTE_LITERAL) || LA143_3 == REGULAR_EXPR_LITERAL || LA143_3 == HEX_NUMBER_LITERAL || LA143_3 == DEC_NUMBER_LITERAL || LA143_3 == IDENTIFIER || (LA143_3 >= XML_COMMENT && LA143_3 <= XML_PI)))
                        {
                            alt143 = 3;
                        }
                        else
                        {
                            if (state.backtracking > 0) { state.failed = true; return retval; }
                            NoViableAltException nvae_d143s3 =
                                new NoViableAltException("", 143, 3, input);

                            throw nvae_d143s3;
                        }
                    }
                    break;
                default:
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    NoViableAltException nvae_d143s0 =
                        new NoViableAltException("", 143, 0, input);

                    throw nvae_d143s0;
            }

            switch (alt143)
            {
                case 1:
                    // AS3_ex.g3:2394:4: primaryExpression
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_primaryExpression_in_memberExpression11818);
                        primaryExpression301 = primaryExpression();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, primaryExpression301.Tree);

                    }
                    break;
                case 2:
                    // AS3_ex.g3:2395:4: functionExpression
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_functionExpression_in_memberExpression11823);
                        functionExpression302 = functionExpression();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, functionExpression302.Tree);

                    }
                    break;
                case 3:
                    // AS3_ex.g3:2396:4: newExpression
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_newExpression_in_memberExpression11828);
                        newExpression303 = newExpression();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, newExpression303.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 129, memberExpression_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "memberExpression"

    public class newExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "newExpression"
    // AS3_ex.g3:2399:1: newExpression : N= NEW primaryExpression ;
    public AS3_exParser.newExpression_return newExpression() // throws RecognitionException [1]
    {
        AS3_exParser.newExpression_return retval = new AS3_exParser.newExpression_return();
        retval.Start = input.LT(1);
        int newExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken N = null;
        AS3_exParser.primaryExpression_return primaryExpression304 = null;


        object N_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 130))
            {
                return retval;
            }
            // AS3_ex.g3:2400:2: (N= NEW primaryExpression )
            // AS3_ex.g3:2400:4: N= NEW primaryExpression
            {
                root_0 = (object)adaptor.GetNilNode();

                N = (IToken)Match(input, NEW, FOLLOW_NEW_in_newExpression11841); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    N_tree = (object)adaptor.Create(N);
                    adaptor.AddChild(root_0, N_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)N);
                }
                PushFollow(FOLLOW_primaryExpression_in_newExpression11846);
                primaryExpression304 = primaryExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, primaryExpression304.Tree);

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 130, newExpression_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "newExpression"

    public class leftHandSideExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "leftHandSideExpression"
    // AS3_ex.g3:2404:1: leftHandSideExpression : memberExpression ( arguments | L= LBRACK expression R= RBRACK | D= DOT ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier | E= XML_ELLIPSIS ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier | D= DOT parExpression | typePostfixSyntax )* ;
    public AS3_exParser.leftHandSideExpression_return leftHandSideExpression() // throws RecognitionException [1]
    {
        AS3_exParser.leftHandSideExpression_return retval = new AS3_exParser.leftHandSideExpression_return();
        retval.Start = input.LT(1);
        int leftHandSideExpression_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        IToken D = null;
        IToken op = null;
        IToken E = null;
        AS3_exParser.memberExpression_return memberExpression305 = null;

        AS3_exParser.arguments_return arguments306 = null;

        AS3_exParser.expression_return expression307 = null;

        AS3_exParser.eitherIdentifier_return eitherIdentifier308 = null;

        AS3_exParser.eitherIdentifier_return eitherIdentifier309 = null;

        AS3_exParser.eitherIdentifier_return eitherIdentifier310 = null;

        AS3_exParser.eitherIdentifier_return eitherIdentifier311 = null;

        AS3_exParser.parExpression_return parExpression312 = null;

        AS3_exParser.typePostfixSyntax_return typePostfixSyntax313 = null;


        object L_tree = null;
        object R_tree = null;
        object D_tree = null;
        object op_tree = null;
        object E_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 131))
            {
                return retval;
            }
            // AS3_ex.g3:2405:5: ( memberExpression ( arguments | L= LBRACK expression R= RBRACK | D= DOT ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier | E= XML_ELLIPSIS ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier | D= DOT parExpression | typePostfixSyntax )* )
            // AS3_ex.g3:2405:9: memberExpression ( arguments | L= LBRACK expression R= RBRACK | D= DOT ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier | E= XML_ELLIPSIS ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier | D= DOT parExpression | typePostfixSyntax )*
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_memberExpression_in_leftHandSideExpression11863);
                memberExpression305 = memberExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, memberExpression305.Tree);
                // AS3_ex.g3:2406:5: ( arguments | L= LBRACK expression R= RBRACK | D= DOT ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier | E= XML_ELLIPSIS ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier | D= DOT parExpression | typePostfixSyntax )*
                do
                {
                    int alt146 = 7;
                    alt146 = dfa146.Predict(input);
                    switch (alt146)
                    {
                        case 1:
                            // AS3_ex.g3:2407:7: arguments
                            {
                                PushFollow(FOLLOW_arguments_in_leftHandSideExpression11878);
                                arguments306 = arguments();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, arguments306.Tree);

                            }
                            break;
                        case 2:
                            // AS3_ex.g3:2408:9: L= LBRACK expression R= RBRACK
                            {
                                L = (IToken)Match(input, LBRACK, FOLLOW_LBRACK_in_leftHandSideExpression11890); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    L_tree = (object)adaptor.Create(L);
                                    adaptor.AddChild(root_0, L_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    Emit((CommonToken)L); InsertWS(mPrinter.GetAdvancedSpacesInsideArrayReferenceBrackets());
                                }
                                PushFollow(FOLLOW_expression_in_leftHandSideExpression11894);
                                expression307 = expression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, expression307.Tree);
                                R = (IToken)Match(input, RBRACK, FOLLOW_RBRACK_in_leftHandSideExpression11898); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    R_tree = (object)adaptor.Create(R);
                                    adaptor.AddChild(root_0, R_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    InsertWS(mPrinter.GetAdvancedSpacesInsideArrayReferenceBrackets()); Emit((CommonToken)R);
                                }

                            }
                            break;
                        case 3:
                            // AS3_ex.g3:2410:9: D= DOT ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier
                            {
                                D = (IToken)Match(input, DOT, FOLLOW_DOT_in_leftHandSideExpression11913); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    D_tree = (object)adaptor.Create(D);
                                    adaptor.AddChild(root_0, D_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    Emit((CommonToken)D);
                                }
                                // AS3_ex.g3:2410:40: ( eitherIdentifier op= XML_NS_OP )?
                                int alt144 = 2;
                                switch (input.LA(1))
                                {
                                    case IDENTIFIER:
                                        {
                                            int LA144_1 = input.LA(2);

                                            if ((synpred309_AS3_ex()))
                                            {
                                                alt144 = 1;
                                            }
                                        }
                                        break;
                                    case XML_AT:
                                        {
                                            int LA144_2 = input.LA(2);

                                            if ((synpred309_AS3_ex()))
                                            {
                                                alt144 = 1;
                                            }
                                        }
                                        break;
                                    case AS:
                                    case BREAK:
                                    case CASE:
                                    case CATCH:
                                    case CLASS:
                                    case CONST:
                                    case CONTINUE:
                                    case DEFAULT:
                                    case DELETE:
                                    case DO:
                                    case ELSE:
                                    case EXTENDS:
                                    case FALSE:
                                    case FINALLY:
                                    case FOR:
                                    case FUNCTION:
                                    case IF:
                                    case IMPLEMENTS:
                                    case IMPORT:
                                    case IN:
                                    case INSTANCEOF:
                                    case INTERFACE:
                                    case INTERNAL:
                                    case IS:
                                    case NEW:
                                    case NULL:
                                    case PACKAGE:
                                    case PRIVATE:
                                    case PROTECTED:
                                    case PUBLIC:
                                    case RETURN:
                                    case SUPER:
                                    case SWITCH:
                                    case THIS:
                                    case THROW:
                                    case TRUE:
                                    case TRY:
                                    case TYPEOF:
                                    case USE:
                                    case VAR:
                                    case VOID:
                                    case WHILE:
                                    case WITH:
                                    case INCLUDE:
                                        {
                                            int LA144_3 = input.LA(2);

                                            if ((synpred309_AS3_ex()))
                                            {
                                                alt144 = 1;
                                            }
                                        }
                                        break;
                                    case NATIVE:
                                    case TO:
                                    case EACH:
                                    case GET:
                                    case SET:
                                    case NAMESPACE:
                                    case DYNAMIC:
                                    case FINAL:
                                    case OVERRIDE:
                                    case STATIC:
                                        {
                                            int LA144_4 = input.LA(2);

                                            if ((synpred309_AS3_ex()))
                                            {
                                                alt144 = 1;
                                            }
                                        }
                                        break;
                                    case STAR:
                                        {
                                            int LA144_5 = input.LA(2);

                                            if ((synpred309_AS3_ex()))
                                            {
                                                alt144 = 1;
                                            }
                                        }
                                        break;
                                }

                                switch (alt144)
                                {
                                    case 1:
                                        // AS3_ex.g3:2410:41: eitherIdentifier op= XML_NS_OP
                                        {
                                            PushFollow(FOLLOW_eitherIdentifier_in_leftHandSideExpression11918);
                                            eitherIdentifier308 = eitherIdentifier();
                                            state.followingStackPointer--;
                                            if (state.failed) return retval;
                                            if (state.backtracking == 0) adaptor.AddChild(root_0, eitherIdentifier308.Tree);
                                            op = (IToken)Match(input, XML_NS_OP, FOLLOW_XML_NS_OP_in_leftHandSideExpression11922); if (state.failed) return retval;
                                            if (state.backtracking == 0)
                                            {
                                                op_tree = (object)adaptor.Create(op);
                                                adaptor.AddChild(root_0, op_tree);
                                            }
                                            if (state.backtracking == 0)
                                            {
                                                Emit((CommonToken)op);
                                            }

                                        }
                                        break;

                                }

                                PushFollow(FOLLOW_eitherIdentifier_in_leftHandSideExpression11929);
                                eitherIdentifier309 = eitherIdentifier();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, eitherIdentifier309.Tree);

                            }
                            break;
                        case 4:
                            // AS3_ex.g3:2411:9: E= XML_ELLIPSIS ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier
                            {
                                E = (IToken)Match(input, XML_ELLIPSIS, FOLLOW_XML_ELLIPSIS_in_leftHandSideExpression11941); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    E_tree = (object)adaptor.Create(E);
                                    adaptor.AddChild(root_0, E_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    Emit((CommonToken)E);
                                }
                                // AS3_ex.g3:2411:48: ( eitherIdentifier op= XML_NS_OP )?
                                int alt145 = 2;
                                switch (input.LA(1))
                                {
                                    case IDENTIFIER:
                                        {
                                            int LA145_1 = input.LA(2);

                                            if ((synpred311_AS3_ex()))
                                            {
                                                alt145 = 1;
                                            }
                                        }
                                        break;
                                    case XML_AT:
                                        {
                                            int LA145_2 = input.LA(2);

                                            if ((synpred311_AS3_ex()))
                                            {
                                                alt145 = 1;
                                            }
                                        }
                                        break;
                                    case AS:
                                    case BREAK:
                                    case CASE:
                                    case CATCH:
                                    case CLASS:
                                    case CONST:
                                    case CONTINUE:
                                    case DEFAULT:
                                    case DELETE:
                                    case DO:
                                    case ELSE:
                                    case EXTENDS:
                                    case FALSE:
                                    case FINALLY:
                                    case FOR:
                                    case FUNCTION:
                                    case IF:
                                    case IMPLEMENTS:
                                    case IMPORT:
                                    case IN:
                                    case INSTANCEOF:
                                    case INTERFACE:
                                    case INTERNAL:
                                    case IS:
                                    case NEW:
                                    case NULL:
                                    case PACKAGE:
                                    case PRIVATE:
                                    case PROTECTED:
                                    case PUBLIC:
                                    case RETURN:
                                    case SUPER:
                                    case SWITCH:
                                    case THIS:
                                    case THROW:
                                    case TRUE:
                                    case TRY:
                                    case TYPEOF:
                                    case USE:
                                    case VAR:
                                    case VOID:
                                    case WHILE:
                                    case WITH:
                                    case INCLUDE:
                                        {
                                            int LA145_3 = input.LA(2);

                                            if ((synpred311_AS3_ex()))
                                            {
                                                alt145 = 1;
                                            }
                                        }
                                        break;
                                    case NATIVE:
                                    case TO:
                                    case EACH:
                                    case GET:
                                    case SET:
                                    case NAMESPACE:
                                    case DYNAMIC:
                                    case FINAL:
                                    case OVERRIDE:
                                    case STATIC:
                                        {
                                            int LA145_4 = input.LA(2);

                                            if ((synpred311_AS3_ex()))
                                            {
                                                alt145 = 1;
                                            }
                                        }
                                        break;
                                    case STAR:
                                        {
                                            int LA145_5 = input.LA(2);

                                            if ((synpred311_AS3_ex()))
                                            {
                                                alt145 = 1;
                                            }
                                        }
                                        break;
                                }

                                switch (alt145)
                                {
                                    case 1:
                                        // AS3_ex.g3:2411:49: eitherIdentifier op= XML_NS_OP
                                        {
                                            PushFollow(FOLLOW_eitherIdentifier_in_leftHandSideExpression11945);
                                            eitherIdentifier310 = eitherIdentifier();
                                            state.followingStackPointer--;
                                            if (state.failed) return retval;
                                            if (state.backtracking == 0) adaptor.AddChild(root_0, eitherIdentifier310.Tree);
                                            op = (IToken)Match(input, XML_NS_OP, FOLLOW_XML_NS_OP_in_leftHandSideExpression11949); if (state.failed) return retval;
                                            if (state.backtracking == 0)
                                            {
                                                op_tree = (object)adaptor.Create(op);
                                                adaptor.AddChild(root_0, op_tree);
                                            }
                                            if (state.backtracking == 0)
                                            {
                                                Emit((CommonToken)op);
                                            }

                                        }
                                        break;

                                }

                                PushFollow(FOLLOW_eitherIdentifier_in_leftHandSideExpression11956);
                                eitherIdentifier311 = eitherIdentifier();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, eitherIdentifier311.Tree);

                            }
                            break;
                        case 5:
                            // AS3_ex.g3:2412:9: D= DOT parExpression
                            {
                                D = (IToken)Match(input, DOT, FOLLOW_DOT_in_leftHandSideExpression11968); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    D_tree = (object)adaptor.Create(D);
                                    adaptor.AddChild(root_0, D_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    Emit((CommonToken)D);
                                }
                                PushFollow(FOLLOW_parExpression_in_leftHandSideExpression11972);
                                parExpression312 = parExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, parExpression312.Tree);

                            }
                            break;
                        case 6:
                            // AS3_ex.g3:2413:9: typePostfixSyntax
                            {
                                PushFollow(FOLLOW_typePostfixSyntax_in_leftHandSideExpression11982);
                                typePostfixSyntax313 = typePostfixSyntax();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, typePostfixSyntax313.Tree);

                            }
                            break;

                        default:
                            goto loop146;
                    }
                } while (true);

            loop146:
                ;	// Stops C# compiler whining that label 'loop146' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 131, leftHandSideExpression_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "leftHandSideExpression"

    public class eitherIdentifier_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "eitherIdentifier"
    // AS3_ex.g3:2417:1: eitherIdentifier : (I= IDENTIFIER | xmlPropertyIdentifier | allKeywords );
    public AS3_exParser.eitherIdentifier_return eitherIdentifier() // throws RecognitionException [1]
    {
        AS3_exParser.eitherIdentifier_return retval = new AS3_exParser.eitherIdentifier_return();
        retval.Start = input.LT(1);
        int eitherIdentifier_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        AS3_exParser.xmlPropertyIdentifier_return xmlPropertyIdentifier314 = null;

        AS3_exParser.allKeywords_return allKeywords315 = null;


        object I_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 132))
            {
                return retval;
            }
            // AS3_ex.g3:2418:2: (I= IDENTIFIER | xmlPropertyIdentifier | allKeywords )
            int alt147 = 3;
            switch (input.LA(1))
            {
                case IDENTIFIER:
                    {
                        int LA147_1 = input.LA(2);

                        if ((synpred315_AS3_ex()))
                        {
                            alt147 = 1;
                        }
                        else if ((synpred316_AS3_ex()))
                        {
                            alt147 = 2;
                        }
                        else
                        {
                            if (state.backtracking > 0) { state.failed = true; return retval; }
                            NoViableAltException nvae_d147s1 =
                                new NoViableAltException("", 147, 1, input);

                            throw nvae_d147s1;
                        }
                    }
                    break;
                case STAR:
                case XML_AT:
                    {
                        alt147 = 2;
                    }
                    break;
                case AS:
                case BREAK:
                case CASE:
                case CATCH:
                case CLASS:
                case CONST:
                case CONTINUE:
                case DEFAULT:
                case DELETE:
                case DO:
                case ELSE:
                case EXTENDS:
                case FALSE:
                case FINALLY:
                case FOR:
                case FUNCTION:
                case IF:
                case IMPLEMENTS:
                case IMPORT:
                case IN:
                case INSTANCEOF:
                case INTERFACE:
                case INTERNAL:
                case IS:
                case NEW:
                case NULL:
                case PACKAGE:
                case PRIVATE:
                case PROTECTED:
                case PUBLIC:
                case RETURN:
                case SUPER:
                case SWITCH:
                case THIS:
                case THROW:
                case TRUE:
                case TRY:
                case TYPEOF:
                case USE:
                case VAR:
                case VOID:
                case WHILE:
                case WITH:
                case INCLUDE:
                    {
                        int LA147_3 = input.LA(2);

                        if ((synpred316_AS3_ex()))
                        {
                            alt147 = 2;
                        }
                        else if ((true))
                        {
                            alt147 = 3;
                        }
                        /*else
                        {
                            if (state.backtracking > 0) { state.failed = true; return retval; }
                            NoViableAltException nvae_d147s3 =
                                new NoViableAltException("", 147, 3, input);

                            throw nvae_d147s3;
                        }*/
                    }
                    break;
                case NATIVE:
                case TO:
                case EACH:
                case GET:
                case SET:
                case NAMESPACE:
                case DYNAMIC:
                case FINAL:
                case OVERRIDE:
                case STATIC:
                    {
                        int LA147_4 = input.LA(2);

                        if ((synpred316_AS3_ex()))
                        {
                            alt147 = 2;
                        }
                        else if ((true))
                        {
                            alt147 = 3;
                        }
                        /*else
                        {
                            if (state.backtracking > 0) { state.failed = true; return retval; }
                            NoViableAltException nvae_d147s4 =
                                new NoViableAltException("", 147, 4, input);

                            throw nvae_d147s4;
                        }*/
                    }
                    break;
                default:
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    NoViableAltException nvae_d147s0 =
                        new NoViableAltException("", 147, 0, input);

                    throw nvae_d147s0;
            }

            switch (alt147)
            {
                case 1:
                    // AS3_ex.g3:2418:4: I= IDENTIFIER
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        I = (IToken)Match(input, IDENTIFIER, FOLLOW_IDENTIFIER_in_eitherIdentifier12012); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            I_tree = (object)adaptor.Create(I);
                            adaptor.AddChild(root_0, I_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)I);
                        }

                    }
                    break;
                case 2:
                    // AS3_ex.g3:2419:5: xmlPropertyIdentifier
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlPropertyIdentifier_in_eitherIdentifier12022);
                        xmlPropertyIdentifier314 = xmlPropertyIdentifier();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, xmlPropertyIdentifier314.Tree);

                    }
                    break;
                case 3:
                    // AS3_ex.g3:2420:5: allKeywords
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_allKeywords_in_eitherIdentifier12028);
                        allKeywords315 = allKeywords();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, allKeywords315.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 132, eitherIdentifier_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "eitherIdentifier"

    public class typeSpecifier_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "typeSpecifier"
    // AS3_ex.g3:2423:1: typeSpecifier : (I= IDENTIFIER | notQuiteReservedWord | I= INTERNAL | D= DEFAULT );
    public AS3_exParser.typeSpecifier_return typeSpecifier() // throws RecognitionException [1]
    {
        AS3_exParser.typeSpecifier_return retval = new AS3_exParser.typeSpecifier_return();
        retval.Start = input.LT(1);
        int typeSpecifier_StartIndex = input.Index();
        object root_0 = null;

        IToken I = null;
        IToken D = null;
        AS3_exParser.notQuiteReservedWord_return notQuiteReservedWord316 = null;


        object I_tree = null;
        object D_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 133))
            {
                return retval;
            }
            // AS3_ex.g3:2423:14: (I= IDENTIFIER | notQuiteReservedWord | I= INTERNAL | D= DEFAULT )
            int alt148 = 4;
            switch (input.LA(1))
            {
                case IDENTIFIER:
                    {
                        alt148 = 1;
                    }
                    break;
                case NATIVE:
                case TO:
                case EACH:
                case GET:
                case SET:
                case NAMESPACE:
                case DYNAMIC:
                case FINAL:
                case OVERRIDE:
                case STATIC:
                    {
                        alt148 = 2;
                    }
                    break;
                case INTERNAL:
                    {
                        alt148 = 3;
                    }
                    break;
                case DEFAULT:
                    {
                        alt148 = 4;
                    }
                    break;
                default:
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    NoViableAltException nvae_d148s0 =
                        new NoViableAltException("", 148, 0, input);

                    throw nvae_d148s0;
            }

            switch (alt148)
            {
                case 1:
                    // AS3_ex.g3:2424:2: I= IDENTIFIER
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        I = (IToken)Match(input, IDENTIFIER, FOLLOW_IDENTIFIER_in_typeSpecifier12041); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            I_tree = (object)adaptor.Create(I);
                            adaptor.AddChild(root_0, I_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)I);
                        }

                    }
                    break;
                case 2:
                    // AS3_ex.g3:2424:42: notQuiteReservedWord
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_notQuiteReservedWord_in_typeSpecifier12047);
                        notQuiteReservedWord316 = notQuiteReservedWord();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, notQuiteReservedWord316.Tree);

                    }
                    break;
                case 3:
                    // AS3_ex.g3:2424:65: I= INTERNAL
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        I = (IToken)Match(input, INTERNAL, FOLLOW_INTERNAL_in_typeSpecifier12053); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            I_tree = (object)adaptor.Create(I);
                            adaptor.AddChild(root_0, I_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)I);
                        }

                    }
                    break;
                case 4:
                    // AS3_ex.g3:2424:103: D= DEFAULT
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        D = (IToken)Match(input, DEFAULT, FOLLOW_DEFAULT_in_typeSpecifier12061); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            D_tree = (object)adaptor.Create(D);
                            adaptor.AddChild(root_0, D_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)D);
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 133, typeSpecifier_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "typeSpecifier"

    public class notQuiteReservedWord_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "notQuiteReservedWord"
    // AS3_ex.g3:2427:1: notQuiteReservedWord : word= ( TO | NATIVE | EACH | GET | SET | NAMESPACE | DYNAMIC | FINAL | OVERRIDE | STATIC ) ;
    public AS3_exParser.notQuiteReservedWord_return notQuiteReservedWord() // throws RecognitionException [1]
    {
        AS3_exParser.notQuiteReservedWord_return retval = new AS3_exParser.notQuiteReservedWord_return();
        retval.Start = input.LT(1);
        int notQuiteReservedWord_StartIndex = input.Index();
        object root_0 = null;

        IToken word = null;

        //object word_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 134))
            {
                return retval;
            }
            // AS3_ex.g3:2428:2: (word= ( TO | NATIVE | EACH | GET | SET | NAMESPACE | DYNAMIC | FINAL | OVERRIDE | STATIC ) )
            // AS3_ex.g3:2429:2: word= ( TO | NATIVE | EACH | GET | SET | NAMESPACE | DYNAMIC | FINAL | OVERRIDE | STATIC )
            {
                root_0 = (object)adaptor.GetNilNode();

                word = (IToken)input.LT(1);
                if (input.LA(1) == NATIVE || input.LA(1) == TO || (input.LA(1) >= EACH && input.LA(1) <= NAMESPACE) || (input.LA(1) >= DYNAMIC && input.LA(1) <= STATIC))
                {
                    input.Consume();
                    if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(word));
                    state.errorRecovery = false; state.failed = false;
                }
                else
                {
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    MismatchedSetException mse = new MismatchedSetException(null, input);
                    throw mse;
                }

                if (state.backtracking == 0)
                {
                    Emit((CommonToken)word);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 134, notQuiteReservedWord_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "notQuiteReservedWord"

    public class allKeywords_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "allKeywords"
    // AS3_ex.g3:2432:1: allKeywords : ( reservedWord | notQuiteReservedWord ) ;
    public AS3_exParser.allKeywords_return allKeywords() // throws RecognitionException [1]
    {
        AS3_exParser.allKeywords_return retval = new AS3_exParser.allKeywords_return();
        retval.Start = input.LT(1);
        int allKeywords_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.reservedWord_return reservedWord317 = null;

        AS3_exParser.notQuiteReservedWord_return notQuiteReservedWord318 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 135))
            {
                return retval;
            }
            // AS3_ex.g3:2433:2: ( ( reservedWord | notQuiteReservedWord ) )
            // AS3_ex.g3:2433:4: ( reservedWord | notQuiteReservedWord )
            {
                root_0 = (object)adaptor.GetNilNode();

                // AS3_ex.g3:2433:4: ( reservedWord | notQuiteReservedWord )
                int alt149 = 2;
                int LA149_0 = input.LA(1);

                if (((LA149_0 >= AS && LA149_0 <= IS) || (LA149_0 >= NEW && LA149_0 <= THROW) || (LA149_0 >= TRUE && LA149_0 <= WITH) || LA149_0 == INCLUDE))
                {
                    alt149 = 1;
                }
                else if ((LA149_0 == NATIVE || LA149_0 == TO || (LA149_0 >= EACH && LA149_0 <= NAMESPACE) || (LA149_0 >= DYNAMIC && LA149_0 <= STATIC)))
                {
                    alt149 = 2;
                }
                else
                {
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    NoViableAltException nvae_d149s0 =
                        new NoViableAltException("", 149, 0, input);

                    throw nvae_d149s0;
                }
                switch (alt149)
                {
                    case 1:
                        // AS3_ex.g3:2433:5: reservedWord
                        {
                            PushFollow(FOLLOW_reservedWord_in_allKeywords12132);
                            reservedWord317 = reservedWord();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, reservedWord317.Tree);

                        }
                        break;
                    case 2:
                        // AS3_ex.g3:2433:20: notQuiteReservedWord
                        {
                            PushFollow(FOLLOW_notQuiteReservedWord_in_allKeywords12136);
                            notQuiteReservedWord318 = notQuiteReservedWord();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, notQuiteReservedWord318.Tree);

                        }
                        break;

                }


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 135, allKeywords_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "allKeywords"

    public class reservedWord_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "reservedWord"
    // AS3_ex.g3:2435:1: reservedWord : word= ( AS | BREAK | CASE | CATCH | CLASS | CONST | CONTINUE | DEFAULT | DELETE | DO | ELSE | EXTENDS | FALSE | FINALLY | FOR | FUNCTION | IF | IMPLEMENTS | IMPORT | IN | INSTANCEOF | INTERFACE | INTERNAL | IS | NEW | NULL | PACKAGE | PRIVATE | PROTECTED | PUBLIC | RETURN | SUPER | SWITCH | THIS | THROW | TRUE | TRY | TYPEOF | USE | VAR | VOID | WHILE | WITH | INCLUDE ) ;
    public AS3_exParser.reservedWord_return reservedWord() // throws RecognitionException [1]
    {
        AS3_exParser.reservedWord_return retval = new AS3_exParser.reservedWord_return();
        retval.Start = input.LT(1);
        int reservedWord_StartIndex = input.Index();
        object root_0 = null;

        IToken word = null;

        //object word_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 136))
            {
                return retval;
            }
            // AS3_ex.g3:2436:2: (word= ( AS | BREAK | CASE | CATCH | CLASS | CONST | CONTINUE | DEFAULT | DELETE | DO | ELSE | EXTENDS | FALSE | FINALLY | FOR | FUNCTION | IF | IMPLEMENTS | IMPORT | IN | INSTANCEOF | INTERFACE | INTERNAL | IS | NEW | NULL | PACKAGE | PRIVATE | PROTECTED | PUBLIC | RETURN | SUPER | SWITCH | THIS | THROW | TRUE | TRY | TYPEOF | USE | VAR | VOID | WHILE | WITH | INCLUDE ) )
            // AS3_ex.g3:2437:5: word= ( AS | BREAK | CASE | CATCH | CLASS | CONST | CONTINUE | DEFAULT | DELETE | DO | ELSE | EXTENDS | FALSE | FINALLY | FOR | FUNCTION | IF | IMPLEMENTS | IMPORT | IN | INSTANCEOF | INTERFACE | INTERNAL | IS | NEW | NULL | PACKAGE | PRIVATE | PROTECTED | PUBLIC | RETURN | SUPER | SWITCH | THIS | THROW | TRUE | TRY | TYPEOF | USE | VAR | VOID | WHILE | WITH | INCLUDE )
            {
                root_0 = (object)adaptor.GetNilNode();

                word = (IToken)input.LT(1);
                if ((input.LA(1) >= AS && input.LA(1) <= IS) || (input.LA(1) >= NEW && input.LA(1) <= THROW) || (input.LA(1) >= TRUE && input.LA(1) <= WITH) || input.LA(1) == INCLUDE)
                {
                    input.Consume();
                    if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(word));
                    state.errorRecovery = false; state.failed = false;
                }
                else
                {
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    MismatchedSetException mse = new MismatchedSetException(null, input);
                    throw mse;
                }

                if (state.backtracking == 0)
                {
                    Emit((CommonToken)word);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 136, reservedWord_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "reservedWord"

    public class arguments_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "arguments"
    // AS3_ex.g3:2494:1: arguments : L= LPAREN ( assignmentExpression (C= COMMA assignmentExpression )* )? R= RPAREN ;
    public AS3_exParser.arguments_return arguments() // throws RecognitionException [1]
    {
        AS3_exParser.arguments_return retval = new AS3_exParser.arguments_return();
        retval.Start = input.LT(1);
        int arguments_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken C = null;
        IToken R = null;
        AS3_exParser.assignmentExpression_return assignmentExpression319 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression320 = null;


        object L_tree = null;
        object C_tree = null;
        object R_tree = null;


        WrapOptions options = mPrinter.GetMethodCallWrapOptions();
        bool pushedFormat = false;
        bool pushedIndent = false;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 137))
            {
                return retval;
            }
            // AS3_ex.g3:2501:2: (L= LPAREN ( assignmentExpression (C= COMMA assignmentExpression )* )? R= RPAREN )
            // AS3_ex.g3:2502:4: L= LPAREN ( assignmentExpression (C= COMMA assignmentExpression )* )? R= RPAREN
            {
                root_0 = (object)adaptor.GetNilNode();

                if (state.backtracking == 0)
                {
                    pushedFormat = PushFormatType(options, false);
                }
                L = (IToken)Match(input, LPAREN, FOLLOW_LPAREN_in_arguments12717); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)L); InsertWS(mPrinter.GetAdvancedSpacesInsideParens());
                }
                // AS3_ex.g3:2504:4: ( assignmentExpression (C= COMMA assignmentExpression )* )?
                int alt151 = 2;
                int LA151_0 = input.LA(1);

                if (((LA151_0 >= AS && LA151_0 <= STATIC) || LA151_0 == VOID || LA151_0 == LCURLY || LA151_0 == LPAREN || LA151_0 == LBRACK || LA151_0 == LT || (LA151_0 >= PLUS && LA151_0 <= STAR) || (LA151_0 >= INC && LA151_0 <= DEC) || (LA151_0 >= NOT && LA151_0 <= INV) || (LA151_0 >= XML_AT && LA151_0 <= XML_LS_STD) || (LA151_0 >= SINGLE_QUOTE_LITERAL && LA151_0 <= DOUBLE_QUOTE_LITERAL) || LA151_0 == REGULAR_EXPR_LITERAL || LA151_0 == HEX_NUMBER_LITERAL || LA151_0 == DEC_NUMBER_LITERAL || LA151_0 == IDENTIFIER || (LA151_0 >= XML_COMMENT && LA151_0 <= XML_PI)))
                {
                    alt151 = 1;
                }
                switch (alt151)
                {
                    case 1:
                        // AS3_ex.g3:2504:6: assignmentExpression (C= COMMA assignmentExpression )*
                        {
                            if (state.backtracking == 0)
                            {
                                pushedIndent = PushLazyParmIndent(pushedIndent, options.IndentStyle);
                            }
                            PushFollow(FOLLOW_assignmentExpression_in_arguments12729);
                            assignmentExpression319 = assignmentExpression();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression319.Tree);
                            // AS3_ex.g3:2505:10: (C= COMMA assignmentExpression )*
                            do
                            {
                                int alt150 = 2;
                                int LA150_0 = input.LA(1);

                                if ((LA150_0 == COMMA))
                                {
                                    alt150 = 1;
                                }


                                switch (alt150)
                                {
                                    case 1:
                                        // AS3_ex.g3:2506:11: C= COMMA assignmentExpression
                                        {
                                            C = (IToken)Match(input, COMMA, FOLLOW_COMMA_in_arguments12757); if (state.failed) return retval;
                                            if (state.backtracking == 0)
                                            {
                                                C_tree = (object)adaptor.Create(C);
                                                adaptor.AddChild(root_0, C_tree);
                                            }
                                            if (state.backtracking == 0)
                                            {
                                                pushedIndent = EmitCommaWithSpacingAndCRs(options, (CommonToken)C, pushedIndent);
                                            }
                                            PushFollow(FOLLOW_assignmentExpression_in_arguments12782);
                                            assignmentExpression320 = assignmentExpression();
                                            state.followingStackPointer--;
                                            if (state.failed) return retval;
                                            if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression320.Tree);

                                        }
                                        break;

                                    default:
                                        goto loop150;
                                }
                            } while (true);

                        loop150:
                            ;	// Stops C# compiler whining that label 'loop150' has no statements


                        }
                        break;

                }

                R = (IToken)Match(input, RPAREN, FOLLOW_RPAREN_in_arguments12810); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if (state.backtracking == 0)
                {
                    InsertWS(mPrinter.GetAdvancedSpacesInsideParens()); Emit((CommonToken)R);
                }
                if (state.backtracking == 0)
                {

                    if (pushedIndent)
                        PopIndent();
                    if (pushedFormat)
                        mPrinter.PopFormatMode();

                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 137, arguments_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "arguments"

    public class suffix_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "suffix"
    // AS3_ex.g3:2523:1: suffix : ( indexSuffix | propertyReferenceSuffix );
    public AS3_exParser.suffix_return suffix() // throws RecognitionException [1]
    {
        AS3_exParser.suffix_return retval = new AS3_exParser.suffix_return();
        retval.Start = input.LT(1);
        int suffix_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.indexSuffix_return indexSuffix321 = null;

        AS3_exParser.propertyReferenceSuffix_return propertyReferenceSuffix322 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 138))
            {
                return retval;
            }
            // AS3_ex.g3:2524:5: ( indexSuffix | propertyReferenceSuffix )
            int alt152 = 2;
            int LA152_0 = input.LA(1);

            if ((LA152_0 == LBRACK))
            {
                alt152 = 1;
            }
            else if ((LA152_0 == DOT))
            {
                alt152 = 2;
            }
            else
            {
                if (state.backtracking > 0) { state.failed = true; return retval; }
                NoViableAltException nvae_d152s0 =
                    new NoViableAltException("", 152, 0, input);

                throw nvae_d152s0;
            }
            switch (alt152)
            {
                case 1:
                    // AS3_ex.g3:2524:10: indexSuffix
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_indexSuffix_in_suffix12849);
                        indexSuffix321 = indexSuffix();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, indexSuffix321.Tree);

                    }
                    break;
                case 2:
                    // AS3_ex.g3:2524:24: propertyReferenceSuffix
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_propertyReferenceSuffix_in_suffix12853);
                        propertyReferenceSuffix322 = propertyReferenceSuffix();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, propertyReferenceSuffix322.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 138, suffix_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "suffix"

    public class indexSuffix_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "indexSuffix"
    // AS3_ex.g3:2527:1: indexSuffix : L= LBRACK expression R= RBRACK ;
    public AS3_exParser.indexSuffix_return indexSuffix() // throws RecognitionException [1]
    {
        AS3_exParser.indexSuffix_return retval = new AS3_exParser.indexSuffix_return();
        retval.Start = input.LT(1);
        int indexSuffix_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        AS3_exParser.expression_return expression323 = null;


        object L_tree = null;
        object R_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 139))
            {
                return retval;
            }
            // AS3_ex.g3:2528:5: (L= LBRACK expression R= RBRACK )
            // AS3_ex.g3:2528:10: L= LBRACK expression R= RBRACK
            {
                root_0 = (object)adaptor.GetNilNode();

                L = (IToken)Match(input, LBRACK, FOLLOW_LBRACK_in_indexSuffix12894); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)L); InsertWS(mPrinter.GetAdvancedSpacesInsideArrayReferenceBrackets());
                }
                PushFollow(FOLLOW_expression_in_indexSuffix12899);
                expression323 = expression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, expression323.Tree);
                R = (IToken)Match(input, RBRACK, FOLLOW_RBRACK_in_indexSuffix12904); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if (state.backtracking == 0)
                {
                    InsertWS(mPrinter.GetAdvancedSpacesInsideArrayReferenceBrackets()); Emit((CommonToken)R);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 139, indexSuffix_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "indexSuffix"

    public class propertyReferenceSuffix_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "propertyReferenceSuffix"
    // AS3_ex.g3:2531:1: propertyReferenceSuffix : (D= DOT I= IDENTIFIER | D= DOT xmlPropertyIdentifier | D= DOT );
    public AS3_exParser.propertyReferenceSuffix_return propertyReferenceSuffix() // throws RecognitionException [1]
    {
        AS3_exParser.propertyReferenceSuffix_return retval = new AS3_exParser.propertyReferenceSuffix_return();
        retval.Start = input.LT(1);
        int propertyReferenceSuffix_StartIndex = input.Index();
        object root_0 = null;

        IToken D = null;
        IToken I = null;
        AS3_exParser.xmlPropertyIdentifier_return xmlPropertyIdentifier324 = null;


        object D_tree = null;
        object I_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 140))
            {
                return retval;
            }
            // AS3_ex.g3:2532:5: (D= DOT I= IDENTIFIER | D= DOT xmlPropertyIdentifier | D= DOT )
            int alt153 = 3;
            int LA153_0 = input.LA(1);

            if ((LA153_0 == DOT))
            {
                switch (input.LA(2))
                {
                    case AS:
                    case BREAK:
                    case CASE:
                    case CATCH:
                    case CLASS:
                    case CONST:
                    case CONTINUE:
                    case DEFAULT:
                    case DELETE:
                    case DO:
                    case ELSE:
                    case EXTENDS:
                    case FALSE:
                    case FINALLY:
                    case FOR:
                    case FUNCTION:
                    case IF:
                    case IMPLEMENTS:
                    case IMPORT:
                    case IN:
                    case INSTANCEOF:
                    case INTERFACE:
                    case INTERNAL:
                    case IS:
                    case NATIVE:
                    case NEW:
                    case NULL:
                    case PACKAGE:
                    case PRIVATE:
                    case PROTECTED:
                    case PUBLIC:
                    case RETURN:
                    case SUPER:
                    case SWITCH:
                    case THIS:
                    case THROW:
                    case TO:
                    case TRUE:
                    case TRY:
                    case TYPEOF:
                    case USE:
                    case VAR:
                    case VOID:
                    case WHILE:
                    case WITH:
                    case EACH:
                    case GET:
                    case SET:
                    case NAMESPACE:
                    case INCLUDE:
                    case DYNAMIC:
                    case FINAL:
                    case OVERRIDE:
                    case STATIC:
                    case STAR:
                    case XML_AT:
                        {
                            alt153 = 2;
                        }
                        break;
                    case IDENTIFIER:
                        {
                            int LA153_3 = input.LA(3);

                            if ((LA153_3 == DOT || LA153_3 == SUB || LA153_3 == COLON || LA153_3 == XML_NS_OP))
                            {
                                alt153 = 2;
                            }
                            else if ((LA153_3 == EOF))
                            {
                                alt153 = 1;
                            }
                            else
                            {
                                if (state.backtracking > 0) { state.failed = true; return retval; }
                                NoViableAltException nvae_d153s3 =
                                    new NoViableAltException("", 153, 3, input);

                                throw nvae_d153s3;
                            }
                        }
                        break;
                    case EOF:
                        {
                            alt153 = 3;
                        }
                        break;
                    default:
                        if (state.backtracking > 0) { state.failed = true; return retval; }
                        NoViableAltException nvae_d153s1 =
                            new NoViableAltException("", 153, 1, input);

                        throw nvae_d153s1;
                }

            }
            else
            {
                if (state.backtracking > 0) { state.failed = true; return retval; }
                NoViableAltException nvae_d153s0 =
                    new NoViableAltException("", 153, 0, input);

                throw nvae_d153s0;
            }
            switch (alt153)
            {
                case 1:
                    // AS3_ex.g3:2532:10: D= DOT I= IDENTIFIER
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        D = (IToken)Match(input, DOT, FOLLOW_DOT_in_propertyReferenceSuffix12932); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            D_tree = (object)adaptor.Create(D);
                            adaptor.AddChild(root_0, D_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)D);
                        }
                        I = (IToken)Match(input, IDENTIFIER, FOLLOW_IDENTIFIER_in_propertyReferenceSuffix12939); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            I_tree = (object)adaptor.Create(I);
                            adaptor.AddChild(root_0, I_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)I);
                        }

                    }
                    break;
                case 2:
                    // AS3_ex.g3:2533:10: D= DOT xmlPropertyIdentifier
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        D = (IToken)Match(input, DOT, FOLLOW_DOT_in_propertyReferenceSuffix12954); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            D_tree = (object)adaptor.Create(D);
                            adaptor.AddChild(root_0, D_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)D);
                        }
                        PushFollow(FOLLOW_xmlPropertyIdentifier_in_propertyReferenceSuffix12959);
                        xmlPropertyIdentifier324 = xmlPropertyIdentifier();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, xmlPropertyIdentifier324.Tree);

                    }
                    break;
                case 3:
                    // AS3_ex.g3:2534:10: D= DOT
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        D = (IToken)Match(input, DOT, FOLLOW_DOT_in_propertyReferenceSuffix12972); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            D_tree = (object)adaptor.Create(D);
                            adaptor.AddChild(root_0, D_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)D);
                        }

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 140, propertyReferenceSuffix_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "propertyReferenceSuffix"

    public class primaryExpression_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "primaryExpression"
    // AS3_ex.g3:2538:1: primaryExpression : primaryExpressionHelper ;
    public AS3_exParser.primaryExpression_return primaryExpression() // throws RecognitionException [1]
    {
        AS3_exParser.primaryExpression_return retval = new AS3_exParser.primaryExpression_return();
        retval.Start = input.LT(1);
        int primaryExpression_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.primaryExpressionHelper_return primaryExpressionHelper325 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 141))
            {
                return retval;
            }
            // AS3_ex.g3:2539:5: ( primaryExpressionHelper )
            // AS3_ex.g3:2539:10: primaryExpressionHelper
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_primaryExpressionHelper_in_primaryExpression13005);
                primaryExpressionHelper325 = primaryExpressionHelper();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, primaryExpressionHelper325.Tree);

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 141, primaryExpression_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "primaryExpression"

    public class primaryExpressionHelper_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "primaryExpressionHelper"
    // AS3_ex.g3:2543:1: primaryExpressionHelper : (T= THIS | S= SUPER | literal | arrayLiteral | objectLiteral | identifierLiteral | xmlPrimaryExpression | parExpression | conditionalCompilerOption );
    public AS3_exParser.primaryExpressionHelper_return primaryExpressionHelper() // throws RecognitionException [1]
    {
        AS3_exParser.primaryExpressionHelper_return retval = new AS3_exParser.primaryExpressionHelper_return();
        retval.Start = input.LT(1);
        int primaryExpressionHelper_StartIndex = input.Index();
        object root_0 = null;

        IToken T = null;
        IToken S = null;
        AS3_exParser.literal_return literal326 = null;

        AS3_exParser.arrayLiteral_return arrayLiteral327 = null;

        AS3_exParser.objectLiteral_return objectLiteral328 = null;

        AS3_exParser.identifierLiteral_return identifierLiteral329 = null;

        AS3_exParser.xmlPrimaryExpression_return xmlPrimaryExpression330 = null;

        AS3_exParser.parExpression_return parExpression331 = null;

        AS3_exParser.conditionalCompilerOption_return conditionalCompilerOption332 = null;


        object T_tree = null;
        object S_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 142))
            {
                return retval;
            }
            // AS3_ex.g3:2544:5: (T= THIS | S= SUPER | literal | arrayLiteral | objectLiteral | identifierLiteral | xmlPrimaryExpression | parExpression | conditionalCompilerOption )
            int alt154 = 9;
            alt154 = dfa154.Predict(input);
            switch (alt154)
            {
                case 1:
                    // AS3_ex.g3:2544:9: T= THIS
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        T = (IToken)Match(input, THIS, FOLLOW_THIS_in_primaryExpressionHelper13032); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            T_tree = (object)adaptor.Create(T);
                            adaptor.AddChild(root_0, T_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)T);
                        }

                    }
                    break;
                case 2:
                    // AS3_ex.g3:2545:9: S= SUPER
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        S = (IToken)Match(input, SUPER, FOLLOW_SUPER_in_primaryExpressionHelper13046); if (state.failed) return retval;
                        if (state.backtracking == 0)
                        {
                            S_tree = (object)adaptor.Create(S);
                            adaptor.AddChild(root_0, S_tree);
                        }
                        if (state.backtracking == 0)
                        {
                            Emit((CommonToken)S);
                        }

                    }
                    break;
                case 3:
                    // AS3_ex.g3:2546:9: literal
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_literal_in_primaryExpressionHelper13058);
                        literal326 = literal();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, literal326.Tree);

                    }
                    break;
                case 4:
                    // AS3_ex.g3:2547:9: arrayLiteral
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_arrayLiteral_in_primaryExpressionHelper13070);
                        arrayLiteral327 = arrayLiteral();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, arrayLiteral327.Tree);

                    }
                    break;
                case 5:
                    // AS3_ex.g3:2548:9: objectLiteral
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_objectLiteral_in_primaryExpressionHelper13081);
                        objectLiteral328 = objectLiteral();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, objectLiteral328.Tree);

                    }
                    break;
                case 6:
                    // AS3_ex.g3:2549:9: identifierLiteral
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_identifierLiteral_in_primaryExpressionHelper13093);
                        identifierLiteral329 = identifierLiteral();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, identifierLiteral329.Tree);

                    }
                    break;
                case 7:
                    // AS3_ex.g3:2550:9: xmlPrimaryExpression
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_xmlPrimaryExpression_in_primaryExpressionHelper13104);
                        xmlPrimaryExpression330 = xmlPrimaryExpression();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, xmlPrimaryExpression330.Tree);

                    }
                    break;
                case 8:
                    // AS3_ex.g3:2551:9: parExpression
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_parExpression_in_primaryExpressionHelper13114);
                        parExpression331 = parExpression();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, parExpression331.Tree);

                    }
                    break;
                case 9:
                    // AS3_ex.g3:2552:9: conditionalCompilerOption
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_conditionalCompilerOption_in_primaryExpressionHelper13125);
                        conditionalCompilerOption332 = conditionalCompilerOption();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, conditionalCompilerOption332.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 142, primaryExpressionHelper_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "primaryExpressionHelper"

    public class objectLiteral_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "objectLiteral"
    // AS3_ex.g3:2556:1: objectLiteral : L= LCURLY ( propertyNameAndValueList )? R= RCURLY ;
    public AS3_exParser.objectLiteral_return objectLiteral() // throws RecognitionException [1]
    {
        AS3_exParser.objectLiteral_return retval = new AS3_exParser.objectLiteral_return();
        retval.Start = input.LT(1);
        int objectLiteral_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        AS3_exParser.propertyNameAndValueList_return propertyNameAndValueList333 = null;


        object L_tree = null;
        object R_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 143))
            {
                return retval;
            }
            // AS3_ex.g3:2557:5: (L= LCURLY ( propertyNameAndValueList )? R= RCURLY )
            // AS3_ex.g3:2557:9: L= LCURLY ( propertyNameAndValueList )? R= RCURLY
            {
                root_0 = (object)adaptor.GetNilNode();

                L = (IToken)Match(input, LCURLY, FOLLOW_LCURLY_in_objectLiteral13147); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)L); InsertWS(mPrinter.GetAdvancedSpacesInsideObjectBraces()); PushIndent(true);
                }
                // AS3_ex.g3:2557:117: ( propertyNameAndValueList )?
                int alt155 = 2;
                int LA155_0 = input.LA(1);

                if ((LA155_0 == NATIVE || LA155_0 == TO || (LA155_0 >= EACH && LA155_0 <= NAMESPACE) || (LA155_0 >= DYNAMIC && LA155_0 <= STATIC) || (LA155_0 >= SINGLE_QUOTE_LITERAL && LA155_0 <= DOUBLE_QUOTE_LITERAL) || LA155_0 == HEX_NUMBER_LITERAL || LA155_0 == DEC_NUMBER_LITERAL || LA155_0 == IDENTIFIER))
                {
                    alt155 = 1;
                }
                switch (alt155)
                {
                    case 1:
                        // AS3_ex.g3:0:0: propertyNameAndValueList
                        {
                            PushFollow(FOLLOW_propertyNameAndValueList_in_objectLiteral13151);
                            propertyNameAndValueList333 = propertyNameAndValueList();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, propertyNameAndValueList333.Tree);

                        }
                        break;

                }

                R = (IToken)Match(input, RCURLY, FOLLOW_RCURLY_in_objectLiteral13156); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if (state.backtracking == 0)
                {
                    PopIndent(); InsertWS(mPrinter.GetAdvancedSpacesInsideObjectBraces()); Emit((CommonToken)R);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 143, objectLiteral_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "objectLiteral"

    public class propertyNameAndValueList_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "propertyNameAndValueList"
    // AS3_ex.g3:2560:1: propertyNameAndValueList : propertyNameAndValue (C= COMMA propertyNameAndValue )* ;
    public AS3_exParser.propertyNameAndValueList_return propertyNameAndValueList() // throws RecognitionException [1]
    {
        AS3_exParser.propertyNameAndValueList_return retval = new AS3_exParser.propertyNameAndValueList_return();
        retval.Start = input.LT(1);
        int propertyNameAndValueList_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        AS3_exParser.propertyNameAndValue_return propertyNameAndValue334 = null;

        AS3_exParser.propertyNameAndValue_return propertyNameAndValue335 = null;


        object C_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 144))
            {
                return retval;
            }
            // AS3_ex.g3:2561:5: ( propertyNameAndValue (C= COMMA propertyNameAndValue )* )
            // AS3_ex.g3:2561:9: propertyNameAndValue (C= COMMA propertyNameAndValue )*
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_propertyNameAndValue_in_propertyNameAndValueList13178);
                propertyNameAndValue334 = propertyNameAndValue();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, propertyNameAndValue334.Tree);
                // AS3_ex.g3:2561:30: (C= COMMA propertyNameAndValue )*
                do
                {
                    int alt156 = 2;
                    int LA156_0 = input.LA(1);

                    if ((LA156_0 == COMMA))
                    {
                        alt156 = 1;
                    }


                    switch (alt156)
                    {
                        case 1:
                            // AS3_ex.g3:2561:31: C= COMMA propertyNameAndValue
                            {
                                if (state.backtracking == 0)
                                {
                                    InsertWS(mPrinter.GetSpacesBeforeComma());
                                }
                                C = (IToken)Match(input, COMMA, FOLLOW_COMMA_in_propertyNameAndValueList13184); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    C_tree = (object)adaptor.Create(C);
                                    adaptor.AddChild(root_0, C_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    Emit((CommonToken)C);
                                }
                                if (state.backtracking == 0)
                                {
                                    InsertWS(mPrinter.GetSpacesAfterComma());
                                }
                                PushFollow(FOLLOW_propertyNameAndValue_in_propertyNameAndValueList13189);
                                propertyNameAndValue335 = propertyNameAndValue();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, propertyNameAndValue335.Tree);

                            }
                            break;

                        default:
                            goto loop156;
                    }
                } while (true);

            loop156:
                ;	// Stops C# compiler whining that label 'loop156' has no statements


            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 144, propertyNameAndValueList_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "propertyNameAndValueList"

    public class propertyNameAndValue_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "propertyNameAndValue"
    // AS3_ex.g3:2564:1: propertyNameAndValue : propertyName C= COLON assignmentExpression ;
    public AS3_exParser.propertyNameAndValue_return propertyNameAndValue() // throws RecognitionException [1]
    {
        AS3_exParser.propertyNameAndValue_return retval = new AS3_exParser.propertyNameAndValue_return();
        retval.Start = input.LT(1);
        int propertyNameAndValue_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        AS3_exParser.propertyName_return propertyName336 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression337 = null;


        object C_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 145))
            {
                return retval;
            }
            // AS3_ex.g3:2565:5: ( propertyName C= COLON assignmentExpression )
            // AS3_ex.g3:2565:9: propertyName C= COLON assignmentExpression
            {
                root_0 = (object)adaptor.GetNilNode();

                PushFollow(FOLLOW_propertyName_in_propertyNameAndValue13210);
                propertyName336 = propertyName();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, propertyName336.Tree);
                C = (IToken)Match(input, COLON, FOLLOW_COLON_in_propertyNameAndValue13214); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    C_tree = (object)adaptor.Create(C);
                    adaptor.AddChild(root_0, C_tree);
                }
                if (state.backtracking == 0)
                {

                    Emit((CommonToken)C);
                    InsertWS(mPrinter.GetSpacesAfterLabel());

                }
                PushFollow(FOLLOW_assignmentExpression_in_propertyNameAndValue13232);
                assignmentExpression337 = assignmentExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression337.Tree);

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 145, propertyNameAndValue_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "propertyNameAndValue"

    public class propertyName_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "propertyName"
    // AS3_ex.g3:2573:1: propertyName : ( identifierLiteral | stringLiteral | numericLiteral );
    public AS3_exParser.propertyName_return propertyName() // throws RecognitionException [1]
    {
        AS3_exParser.propertyName_return retval = new AS3_exParser.propertyName_return();
        retval.Start = input.LT(1);
        int propertyName_StartIndex = input.Index();
        object root_0 = null;

        AS3_exParser.identifierLiteral_return identifierLiteral338 = null;

        AS3_exParser.stringLiteral_return stringLiteral339 = null;

        AS3_exParser.numericLiteral_return numericLiteral340 = null;



        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 146))
            {
                return retval;
            }
            // AS3_ex.g3:2574:5: ( identifierLiteral | stringLiteral | numericLiteral )
            int alt157 = 3;
            switch (input.LA(1))
            {
                case NATIVE:
                case TO:
                case EACH:
                case GET:
                case SET:
                case NAMESPACE:
                case DYNAMIC:
                case FINAL:
                case OVERRIDE:
                case STATIC:
                case IDENTIFIER:
                    {
                        alt157 = 1;
                    }
                    break;
                case SINGLE_QUOTE_LITERAL:
                case DOUBLE_QUOTE_LITERAL:
                    {
                        alt157 = 2;
                    }
                    break;
                case HEX_NUMBER_LITERAL:
                case DEC_NUMBER_LITERAL:
                    {
                        alt157 = 3;
                    }
                    break;
                default:
                    if (state.backtracking > 0) { state.failed = true; return retval; }
                    NoViableAltException nvae_d157s0 =
                        new NoViableAltException("", 157, 0, input);

                    throw nvae_d157s0;
            }

            switch (alt157)
            {
                case 1:
                    // AS3_ex.g3:2574:9: identifierLiteral
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_identifierLiteral_in_propertyName13251);
                        identifierLiteral338 = identifierLiteral();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, identifierLiteral338.Tree);

                    }
                    break;
                case 2:
                    // AS3_ex.g3:2575:9: stringLiteral
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_stringLiteral_in_propertyName13262);
                        stringLiteral339 = stringLiteral();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, stringLiteral339.Tree);

                    }
                    break;
                case 3:
                    // AS3_ex.g3:2576:9: numericLiteral
                    {
                        root_0 = (object)adaptor.GetNilNode();

                        PushFollow(FOLLOW_numericLiteral_in_propertyName13273);
                        numericLiteral340 = numericLiteral();
                        state.followingStackPointer--;
                        if (state.failed) return retval;
                        if (state.backtracking == 0) adaptor.AddChild(root_0, numericLiteral340.Tree);

                    }
                    break;

            }
            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 146, propertyName_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "propertyName"

    public class arrayLiteral_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "arrayLiteral"
    // AS3_ex.g3:2580:1: arrayLiteral : L= LBRACK ( elementList )? R= RBRACK ;
    public AS3_exParser.arrayLiteral_return arrayLiteral() // throws RecognitionException [1]
    {
        AS3_exParser.arrayLiteral_return retval = new AS3_exParser.arrayLiteral_return();
        retval.Start = input.LT(1);
        int arrayLiteral_StartIndex = input.Index();
        object root_0 = null;

        IToken L = null;
        IToken R = null;
        AS3_exParser.elementList_return elementList341 = null;


        object L_tree = null;
        object R_tree = null;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 147))
            {
                return retval;
            }
            // AS3_ex.g3:2581:5: (L= LBRACK ( elementList )? R= RBRACK )
            // AS3_ex.g3:2581:9: L= LBRACK ( elementList )? R= RBRACK
            {
                root_0 = (object)adaptor.GetNilNode();

                L = (IToken)Match(input, LBRACK, FOLLOW_LBRACK_in_arrayLiteral13296); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    L_tree = (object)adaptor.Create(L);
                    adaptor.AddChild(root_0, L_tree);
                }
                if (state.backtracking == 0)
                {
                    Emit((CommonToken)L); InsertWS(mPrinter.GetAdvancedSpacesInsideArrayDeclBrackets());
                }
                // AS3_ex.g3:2581:105: ( elementList )?
                int alt158 = 2;
                int LA158_0 = input.LA(1);

                if (((LA158_0 >= AS && LA158_0 <= STATIC) || LA158_0 == VOID || LA158_0 == LCURLY || LA158_0 == LPAREN || LA158_0 == LBRACK || LA158_0 == LT || (LA158_0 >= PLUS && LA158_0 <= STAR) || (LA158_0 >= INC && LA158_0 <= DEC) || (LA158_0 >= NOT && LA158_0 <= INV) || (LA158_0 >= XML_AT && LA158_0 <= XML_LS_STD) || (LA158_0 >= SINGLE_QUOTE_LITERAL && LA158_0 <= DOUBLE_QUOTE_LITERAL) || LA158_0 == REGULAR_EXPR_LITERAL || LA158_0 == HEX_NUMBER_LITERAL || LA158_0 == DEC_NUMBER_LITERAL || LA158_0 == IDENTIFIER || (LA158_0 >= XML_COMMENT && LA158_0 <= XML_PI)))
                {
                    alt158 = 1;
                }
                switch (alt158)
                {
                    case 1:
                        // AS3_ex.g3:0:0: elementList
                        {
                            PushFollow(FOLLOW_elementList_in_arrayLiteral13300);
                            elementList341 = elementList();
                            state.followingStackPointer--;
                            if (state.failed) return retval;
                            if (state.backtracking == 0) adaptor.AddChild(root_0, elementList341.Tree);

                        }
                        break;

                }

                R = (IToken)Match(input, RBRACK, FOLLOW_RBRACK_in_arrayLiteral13305); if (state.failed) return retval;
                if (state.backtracking == 0)
                {
                    R_tree = (object)adaptor.Create(R);
                    adaptor.AddChild(root_0, R_tree);
                }
                if (state.backtracking == 0)
                {
                    InsertWS(mPrinter.GetAdvancedSpacesInsideArrayDeclBrackets()); Emit((CommonToken)R);
                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 147, arrayLiteral_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "arrayLiteral"

    public class elementList_return : ParserRuleReturnScope
    {
        private object tree;
        override public object Tree
        {
            get { return tree; }
            set { tree = (object)value; }
        }
    };

    // $ANTLR start "elementList"
    // AS3_ex.g3:2584:1: elementList : assignmentExpression (C= COMMA assignmentExpression )* (C= COMMA )? ;
    public AS3_exParser.elementList_return elementList() // throws RecognitionException [1]
    {
        AS3_exParser.elementList_return retval = new AS3_exParser.elementList_return();
        retval.Start = input.LT(1);
        int elementList_StartIndex = input.Index();
        object root_0 = null;

        IToken C = null;
        AS3_exParser.assignmentExpression_return assignmentExpression342 = null;

        AS3_exParser.assignmentExpression_return assignmentExpression343 = null;


        object C_tree = null;


        WrapOptions options = mPrinter.GetArrayInitWrapOptions();
        bool pushedFormat = false;
        bool pushedIndent = false;

        try
        {
            if ((state.backtracking > 0) && AlreadyParsedRule(input, 148))
            {
                return retval;
            }
            // AS3_ex.g3:2591:5: ( assignmentExpression (C= COMMA assignmentExpression )* (C= COMMA )? )
            // AS3_ex.g3:2592:6: assignmentExpression (C= COMMA assignmentExpression )* (C= COMMA )?
            {
                root_0 = (object)adaptor.GetNilNode();

                if (state.backtracking == 0)
                {
                    pushedFormat = PushFormatType(options, false);
                }
                if (state.backtracking == 0)
                {
                    pushedIndent = PushLazyParmIndent(pushedIndent, options.IndentStyle);
                }
                PushFollow(FOLLOW_assignmentExpression_in_elementList13351);
                assignmentExpression342 = assignmentExpression();
                state.followingStackPointer--;
                if (state.failed) return retval;
                if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression342.Tree);
                // AS3_ex.g3:2595:6: (C= COMMA assignmentExpression )*
                do
                {
                    int alt159 = 2;
                    int LA159_0 = input.LA(1);

                    if ((LA159_0 == COMMA))
                    {
                        int LA159_1 = input.LA(2);

                        if (((LA159_1 >= AS && LA159_1 <= STATIC) || LA159_1 == LCURLY || LA159_1 == LPAREN || LA159_1 == LBRACK || LA159_1 == LT || (LA159_1 >= PLUS && LA159_1 <= STAR) || (LA159_1 >= INC && LA159_1 <= DEC) || (LA159_1 >= NOT && LA159_1 <= INV) || (LA159_1 >= XML_AT && LA159_1 <= XML_LS_STD) || (LA159_1 >= SINGLE_QUOTE_LITERAL && LA159_1 <= DOUBLE_QUOTE_LITERAL) || LA159_1 == REGULAR_EXPR_LITERAL || LA159_1 == HEX_NUMBER_LITERAL || LA159_1 == DEC_NUMBER_LITERAL || LA159_1 == IDENTIFIER || (LA159_1 >= XML_COMMENT && LA159_1 <= XML_PI)))
                        {
                            alt159 = 1;
                        }


                    }


                    switch (alt159)
                    {
                        case 1:
                            // AS3_ex.g3:2596:7: C= COMMA assignmentExpression
                            {
                                C = (IToken)Match(input, COMMA, FOLLOW_COMMA_in_elementList13369); if (state.failed) return retval;
                                if (state.backtracking == 0)
                                {
                                    C_tree = (object)adaptor.Create(C);
                                    adaptor.AddChild(root_0, C_tree);
                                }
                                if (state.backtracking == 0)
                                {
                                    pushedIndent = EmitCommaWithSpacingAndCRs(options, (CommonToken)C, pushedIndent);
                                }
                                PushFollow(FOLLOW_assignmentExpression_in_elementList13386);
                                assignmentExpression343 = assignmentExpression();
                                state.followingStackPointer--;
                                if (state.failed) return retval;
                                if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression343.Tree);

                            }
                            break;

                        default:
                            goto loop159;
                    }
                } while (true);

            loop159:
                ;	// Stops C# compiler whining that label 'loop159' has no statements

                // AS3_ex.g3:2599:9: (C= COMMA )?
                int alt160 = 2;
                int LA160_0 = input.LA(1);

                if ((LA160_0 == COMMA))
                {
                    alt160 = 1;
                }
                switch (alt160)
                {
                    case 1:
                        // AS3_ex.g3:2599:10: C= COMMA
                        {
                            C = (IToken)Match(input, COMMA, FOLLOW_COMMA_in_elementList13399); if (state.failed) return retval;
                            if (state.backtracking == 0)
                            {
                                C_tree = (object)adaptor.Create(C);
                                adaptor.AddChild(root_0, C_tree);
                            }
                            if (state.backtracking == 0)
                            {
                                Emit((CommonToken)C);
                            }

                        }
                        break;

                }

                if (state.backtracking == 0)
                {

                    if (pushedIndent)
                        PopIndent();
                    if (pushedFormat)
                        mPrinter.PopFormatMode();

                }

            }

            retval.Stop = input.LT(-1);

            if (state.backtracking == 0)
            {
                retval.Tree = (object)adaptor.RulePostProcessing(root_0);
                adaptor.SetTokenBoundaries(retval.Tree, (IToken)retval.Start, (IToken)retval.Stop);
            }
        }
        catch (RecognitionException re)
        {
            ReportError(re);
            Recover(input, re);
            // Conversion of the second argument necessary, but harmless
            retval.Tree = (object)adaptor.ErrorNode(input, (IToken)retval.Start, input.LT(-1), re);

        }
        finally
        {
            if (state.backtracking > 0)
            {
                Memoize(input, 148, elementList_StartIndex);
            }
        }
        return retval;
    }
    // $ANTLR end "elementList"

    // $ANTLR start "synpred9_AS3_ex"
    public void synpred9_AS3_ex_fragment()
    {
        IToken s = null;
        IToken d = null;
        IToken c = null;
        IToken I2 = null;

        // AS3_ex.g3:1247:95: ({...}? => (s= SUB | d= DOT | c= COLON ) {...}? => (I2= IDENTIFIER | allKeywords ) )
        // AS3_ex.g3:1247:95: {...}? => (s= SUB | d= DOT | c= COLON ) {...}? => (I2= IDENTIFIER | allKeywords )
        {
            if (!((!PromoteWhitespace())))
            {
                if (state.backtracking > 0) { state.failed = true; return; }
                throw new FailedPredicateException(input, "synpred9_AS3_ex", "!PromoteWhitespace()");
            }
            // AS3_ex.g3:1247:121: (s= SUB | d= DOT | c= COLON )
            int alt161 = 3;
            switch (input.LA(1))
            {
                case SUB:
                    {
                        alt161 = 1;
                    }
                    break;
                case DOT:
                    {
                        alt161 = 2;
                    }
                    break;
                case COLON:
                    {
                        alt161 = 3;
                    }
                    break;
                default:
                    if (state.backtracking > 0) { state.failed = true; return; }
                    NoViableAltException nvae_d161s0 =
                        new NoViableAltException("", 161, 0, input);

                    throw nvae_d161s0;
            }

            switch (alt161)
            {
                case 1:
                    // AS3_ex.g3:1247:122: s= SUB
                    {
                        s = (IToken)Match(input, SUB, FOLLOW_SUB_in_synpred9_AS3_ex3793); if (state.failed) return;

                    }
                    break;
                case 2:
                    // AS3_ex.g3:1247:155: d= DOT
                    {
                        d = (IToken)Match(input, DOT, FOLLOW_DOT_in_synpred9_AS3_ex3801); if (state.failed) return;

                    }
                    break;
                case 3:
                    // AS3_ex.g3:1247:188: c= COLON
                    {
                        c = (IToken)Match(input, COLON, FOLLOW_COLON_in_synpred9_AS3_ex3809); if (state.failed) return;

                    }
                    break;

            }

            if (!((!PromoteWhitespace())))
            {
                if (state.backtracking > 0) { state.failed = true; return; }
                throw new FailedPredicateException(input, "synpred9_AS3_ex", "!PromoteWhitespace()");
            }
            // AS3_ex.g3:1247:248: (I2= IDENTIFIER | allKeywords )
            int alt162 = 2;
            int LA162_0 = input.LA(1);

            if ((LA162_0 == IDENTIFIER))
            {
                alt162 = 1;
            }
            else if (((LA162_0 >= AS && LA162_0 <= STATIC)))
            {
                alt162 = 2;
            }
            else
            {
                if (state.backtracking > 0) { state.failed = true; return; }
                NoViableAltException nvae_d162s0 =
                    new NoViableAltException("", 162, 0, input);

                throw nvae_d162s0;
            }
            switch (alt162)
            {
                case 1:
                    // AS3_ex.g3:1247:249: I2= IDENTIFIER
                    {
                        I2 = (IToken)Match(input, IDENTIFIER, FOLLOW_IDENTIFIER_in_synpred9_AS3_ex3820); if (state.failed) return;

                    }
                    break;
                case 2:
                    // AS3_ex.g3:1247:291: allKeywords
                    {
                        PushFollow(FOLLOW_allKeywords_in_synpred9_AS3_ex3826);
                        allKeywords();
                        state.followingStackPointer--;
                        if (state.failed) return;

                    }
                    break;

            }


        }
    }
    // $ANTLR end "synpred9_AS3_ex"

    // $ANTLR start "synpred70_AS3_ex"
    public void synpred70_AS3_ex_fragment()
    {
        IToken x = null;

        // AS3_ex.g3:1345:6: (x= XML_TEXT )
        // AS3_ex.g3:1345:6: x= XML_TEXT
        {
            x = (IToken)Match(input, XML_TEXT, FOLLOW_XML_TEXT_in_synpred70_AS3_ex4890); if (state.failed) return;

        }
    }
    // $ANTLR end "synpred70_AS3_ex"

    // $ANTLR start "synpred71_AS3_ex"
    public void synpred71_AS3_ex_fragment()
    {
        // AS3_ex.g3:1345:44: ( xmlTextElement )
        // AS3_ex.g3:1345:44: xmlTextElement
        {
            PushFollow(FOLLOW_xmlTextElement_in_synpred71_AS3_ex4896);
            xmlTextElement();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred71_AS3_ex"

    // $ANTLR start "synpred75_AS3_ex"
    public void synpred75_AS3_ex_fragment()
    {
        // AS3_ex.g3:1368:11: ( xmlQualifiedIdentifier )
        // AS3_ex.g3:1368:11: xmlQualifiedIdentifier
        {
            PushFollow(FOLLOW_xmlQualifiedIdentifier_in_synpred75_AS3_ex5123);
            xmlQualifiedIdentifier();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred75_AS3_ex"

    // $ANTLR start "synpred76_AS3_ex"
    public void synpred76_AS3_ex_fragment()
    {
        // AS3_ex.g3:1375:12: ( xmlQualifiedIdentifier )
        // AS3_ex.g3:1375:12: xmlQualifiedIdentifier
        {
            PushFollow(FOLLOW_xmlQualifiedIdentifier_in_synpred76_AS3_ex5228);
            xmlQualifiedIdentifier();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred76_AS3_ex"

    // $ANTLR start "synpred77_AS3_ex"
    public void synpred77_AS3_ex_fragment()
    {
        // AS3_ex.g3:1376:14: ( xmlPropertySelector )
        // AS3_ex.g3:1376:14: xmlPropertySelector
        {
            PushFollow(FOLLOW_xmlPropertySelector_in_synpred77_AS3_ex5243);
            xmlPropertySelector();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred77_AS3_ex"

    // $ANTLR start "synpred99_AS3_ex"
    public void synpred99_AS3_ex_fragment()
    {
        // AS3_ex.g3:1524:7: ( propertyDeclaration )
        // AS3_ex.g3:1524:7: propertyDeclaration
        {
            PushFollow(FOLLOW_propertyDeclaration_in_synpred99_AS3_ex6062);
            propertyDeclaration();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred99_AS3_ex"

    // $ANTLR start "synpred100_AS3_ex"
    public void synpred100_AS3_ex_fragment()
    {
        // AS3_ex.g3:1524:29: ( functionDeclaration )
        // AS3_ex.g3:1524:29: functionDeclaration
        {
            PushFollow(FOLLOW_functionDeclaration_in_synpred100_AS3_ex6066);
            functionDeclaration();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred100_AS3_ex"

    // $ANTLR start "synpred101_AS3_ex"
    public void synpred101_AS3_ex_fragment()
    {
        // AS3_ex.g3:1524:51: ( statement )
        // AS3_ex.g3:1524:51: statement
        {
            PushFollow(FOLLOW_statement_in_synpred101_AS3_ex6070);
            statement();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred101_AS3_ex"

    // $ANTLR start "synpred102_AS3_ex"
    public void synpred102_AS3_ex_fragment()
    {
        // AS3_ex.g3:1524:63: ( directive )
        // AS3_ex.g3:1524:63: directive
        {
            PushFollow(FOLLOW_directive_in_synpred102_AS3_ex6074);
            directive();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred102_AS3_ex"

    // $ANTLR start "synpred103_AS3_ex"
    public void synpred103_AS3_ex_fragment()
    {
        // AS3_ex.g3:1524:75: ( interfaceFunctionDeclaration )
        // AS3_ex.g3:1524:75: interfaceFunctionDeclaration
        {
            PushFollow(FOLLOW_interfaceFunctionDeclaration_in_synpred103_AS3_ex6078);
            interfaceFunctionDeclaration();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred103_AS3_ex"

    // $ANTLR start "synpred105_AS3_ex"
    public void synpred105_AS3_ex_fragment()
    {
        // AS3_ex.g3:1528:9: ( classOrInterfaceDecl )
        // AS3_ex.g3:1528:9: classOrInterfaceDecl
        {
            PushFollow(FOLLOW_classOrInterfaceDecl_in_synpred105_AS3_ex6104);
            classOrInterfaceDecl();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred105_AS3_ex"

    // $ANTLR start "synpred106_AS3_ex"
    public void synpred106_AS3_ex_fragment()
    {
        // AS3_ex.g3:1528:32: ( propertyDeclaration )
        // AS3_ex.g3:1528:32: propertyDeclaration
        {
            PushFollow(FOLLOW_propertyDeclaration_in_synpred106_AS3_ex6108);
            propertyDeclaration();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred106_AS3_ex"

    // $ANTLR start "synpred107_AS3_ex"
    public void synpred107_AS3_ex_fragment()
    {
        // AS3_ex.g3:1528:54: ( functionDeclaration )
        // AS3_ex.g3:1528:54: functionDeclaration
        {
            PushFollow(FOLLOW_functionDeclaration_in_synpred107_AS3_ex6112);
            functionDeclaration();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred107_AS3_ex"

    // $ANTLR start "synpred108_AS3_ex"
    public void synpred108_AS3_ex_fragment()
    {
        // AS3_ex.g3:1528:76: ( interfaceFunctionDeclaration )
        // AS3_ex.g3:1528:76: interfaceFunctionDeclaration
        {
            PushFollow(FOLLOW_interfaceFunctionDeclaration_in_synpred108_AS3_ex6116);
            interfaceFunctionDeclaration();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred108_AS3_ex"

    // $ANTLR start "synpred109_AS3_ex"
    public void synpred109_AS3_ex_fragment()
    {
        // AS3_ex.g3:1528:107: ( statement )
        // AS3_ex.g3:1528:107: statement
        {
            PushFollow(FOLLOW_statement_in_synpred109_AS3_ex6120);
            statement();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred109_AS3_ex"

    // $ANTLR start "synpred122_AS3_ex"
    public void synpred122_AS3_ex_fragment()
    {
        IToken s = null;

        // AS3_ex.g3:1582:39: (s= SEMI )
        // AS3_ex.g3:1582:39: s= SEMI
        {
            s = (IToken)Match(input, SEMI, FOLLOW_SEMI_in_synpred122_AS3_ex6479); if (state.failed) return;

        }
    }
    // $ANTLR end "synpred122_AS3_ex"

    // $ANTLR start "synpred131_AS3_ex"
    public void synpred131_AS3_ex_fragment()
    {
        // AS3_ex.g3:1651:9: ( propertyDeclaration )
        // AS3_ex.g3:1651:9: propertyDeclaration
        {
            PushFollow(FOLLOW_propertyDeclaration_in_synpred131_AS3_ex6801);
            propertyDeclaration();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred131_AS3_ex"

    // $ANTLR start "synpred132_AS3_ex"
    public void synpred132_AS3_ex_fragment()
    {
        // AS3_ex.g3:1651:31: ( functionDeclaration )
        // AS3_ex.g3:1651:31: functionDeclaration
        {
            PushFollow(FOLLOW_functionDeclaration_in_synpred132_AS3_ex6805);
            functionDeclaration();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred132_AS3_ex"

    // $ANTLR start "synpred133_AS3_ex"
    public void synpred133_AS3_ex_fragment()
    {
        // AS3_ex.g3:1651:53: ( statement )
        // AS3_ex.g3:1651:53: statement
        {
            PushFollow(FOLLOW_statement_in_synpred133_AS3_ex6809);
            statement();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred133_AS3_ex"

    // $ANTLR start "synpred134_AS3_ex"
    public void synpred134_AS3_ex_fragment()
    {
        // AS3_ex.g3:1655:9: ( propertyDeclaration )
        // AS3_ex.g3:1655:9: propertyDeclaration
        {
            PushFollow(FOLLOW_propertyDeclaration_in_synpred134_AS3_ex6830);
            propertyDeclaration();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred134_AS3_ex"

    // $ANTLR start "synpred135_AS3_ex"
    public void synpred135_AS3_ex_fragment()
    {
        // AS3_ex.g3:1655:31: ( interfaceFunctionDeclaration )
        // AS3_ex.g3:1655:31: interfaceFunctionDeclaration
        {
            PushFollow(FOLLOW_interfaceFunctionDeclaration_in_synpred135_AS3_ex6834);
            interfaceFunctionDeclaration();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred135_AS3_ex"

    // $ANTLR start "synpred136_AS3_ex"
    public void synpred136_AS3_ex_fragment()
    {
        // AS3_ex.g3:1655:62: ( statement )
        // AS3_ex.g3:1655:62: statement
        {
            PushFollow(FOLLOW_statement_in_synpred136_AS3_ex6838);
            statement();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred136_AS3_ex"

    // $ANTLR start "synpred144_AS3_ex"
    public void synpred144_AS3_ex_fragment()
    {
        // AS3_ex.g3:1676:135: ( memberModifiers )
        // AS3_ex.g3:1676:135: memberModifiers
        {
            PushFollow(FOLLOW_memberModifiers_in_synpred144_AS3_ex6975);
            memberModifiers();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred144_AS3_ex"

    // $ANTLR start "synpred159_AS3_ex"
    public void synpred159_AS3_ex_fragment()
    {
        // AS3_ex.g3:1740:8: ( statement )
        // AS3_ex.g3:1740:8: statement
        {
            PushFollow(FOLLOW_statement_in_synpred159_AS3_ex7457);
            statement();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred159_AS3_ex"

    // $ANTLR start "synpred160_AS3_ex"
    public void synpred160_AS3_ex_fragment()
    {
        // AS3_ex.g3:1740:18: ( functionDeclaration )
        // AS3_ex.g3:1740:18: functionDeclaration
        {
            PushFollow(FOLLOW_functionDeclaration_in_synpred160_AS3_ex7459);
            functionDeclaration();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred160_AS3_ex"

    // $ANTLR start "synpred161_AS3_ex"
    public void synpred161_AS3_ex_fragment()
    {
        // AS3_ex.g3:1749:9: ( memberModifier )
        // AS3_ex.g3:1749:9: memberModifier
        {
            PushFollow(FOLLOW_memberModifier_in_synpred161_AS3_ex7501);
            memberModifier();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred161_AS3_ex"

    // $ANTLR start "synpred171_AS3_ex"
    public void synpred171_AS3_ex_fragment()
    {
        // AS3_ex.g3:1780:6: ( blockStatement )
        // AS3_ex.g3:1780:6: blockStatement
        {
            if (state.backtracking == 0)
            {
                SetBlockFlag(true);
            }
            PushFollow(FOLLOW_blockStatement_in_synpred171_AS3_ex7668);
            blockStatement();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred171_AS3_ex"

    // $ANTLR start "synpred172_AS3_ex"
    public void synpred172_AS3_ex_fragment()
    {
        // AS3_ex.g3:1781:9: ( directive )
        // AS3_ex.g3:1781:9: directive
        {
            if (state.backtracking == 0)
            {
                InsertStatementCR();
            }
            PushFollow(FOLLOW_directive_in_synpred172_AS3_ex7679);
            directive();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred172_AS3_ex"

    // $ANTLR start "synpred173_AS3_ex"
    public void synpred173_AS3_ex_fragment()
    {
        // AS3_ex.g3:1782:9: ( namespaceDirective )
        // AS3_ex.g3:1782:9: namespaceDirective
        {
            if (state.backtracking == 0)
            {
                InsertStatementCR();
            }
            PushFollow(FOLLOW_namespaceDirective_in_synpred173_AS3_ex7690);
            namespaceDirective();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred173_AS3_ex"

    // $ANTLR start "synpred174_AS3_ex"
    public void synpred174_AS3_ex_fragment()
    {
        // AS3_ex.g3:1783:9: ( expression semic )
        // AS3_ex.g3:1783:9: expression semic
        {
            if (state.backtracking == 0)
            {
                InsertStatementCR();
            }
            PushFollow(FOLLOW_expression_in_synpred174_AS3_ex7703);
            expression();
            state.followingStackPointer--;
            if (state.failed) return;
            PushFollow(FOLLOW_semic_in_synpred174_AS3_ex7705);
            semic();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred174_AS3_ex"

    // $ANTLR start "synpred175_AS3_ex"
    public void synpred175_AS3_ex_fragment()
    {
        // AS3_ex.g3:1784:9: ( constantVarStatement )
        // AS3_ex.g3:1784:9: constantVarStatement
        {
            if (state.backtracking == 0)
            {
                InsertStatementCR();
            }
            PushFollow(FOLLOW_constantVarStatement_in_synpred175_AS3_ex7720);
            constantVarStatement();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred175_AS3_ex"

    // $ANTLR start "synpred176_AS3_ex"
    public void synpred176_AS3_ex_fragment()
    {
        // AS3_ex.g3:1785:9: ( tryStatement )
        // AS3_ex.g3:1785:9: tryStatement
        {
            if (state.backtracking == 0)
            {
                MarkBlockFlag(); InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
            }
            PushFollow(FOLLOW_tryStatement_in_synpred176_AS3_ex7733);
            tryStatement();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred176_AS3_ex"

    // $ANTLR start "synpred177_AS3_ex"
    public void synpred177_AS3_ex_fragment()
    {
        // AS3_ex.g3:1786:9: ( labelledStatement )
        // AS3_ex.g3:1786:9: labelledStatement
        {
            if (state.backtracking == 0)
            {
                InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
            }
            PushFollow(FOLLOW_labelledStatement_in_synpred177_AS3_ex7745);
            labelledStatement();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred177_AS3_ex"

    // $ANTLR start "synpred178_AS3_ex"
    public void synpred178_AS3_ex_fragment()
    {
        // AS3_ex.g3:1787:9: ( switchStatement )
        // AS3_ex.g3:1787:9: switchStatement
        {
            if (state.backtracking == 0)
            {
                MarkBlockFlag();
            }
            PushFollow(FOLLOW_switchStatement_in_synpred178_AS3_ex7758);
            switchStatement();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred178_AS3_ex"

    // $ANTLR start "synpred179_AS3_ex"
    public void synpred179_AS3_ex_fragment()
    {
        // AS3_ex.g3:1788:9: ( withStatement )
        // AS3_ex.g3:1788:9: withStatement
        {
            if (state.backtracking == 0)
            {
                MarkBlockFlag(); InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
            }
            PushFollow(FOLLOW_withStatement_in_synpred179_AS3_ex7770);
            withStatement();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred179_AS3_ex"

    // $ANTLR start "synpred180_AS3_ex"
    public void synpred180_AS3_ex_fragment()
    {
        // AS3_ex.g3:1789:9: ( returnStatement )
        // AS3_ex.g3:1789:9: returnStatement
        {
            if (state.backtracking == 0)
            {
                InsertStatementCR();
            }
            PushFollow(FOLLOW_returnStatement_in_synpred180_AS3_ex7784);
            returnStatement();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred180_AS3_ex"

    // $ANTLR start "synpred181_AS3_ex"
    public void synpred181_AS3_ex_fragment()
    {
        // AS3_ex.g3:1790:9: ( breakStatement )
        // AS3_ex.g3:1790:9: breakStatement
        {
            if (state.backtracking == 0)
            {
                InsertStatementCR();
            }
            PushFollow(FOLLOW_breakStatement_in_synpred181_AS3_ex7800);
            breakStatement();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred181_AS3_ex"

    // $ANTLR start "synpred182_AS3_ex"
    public void synpred182_AS3_ex_fragment()
    {
        // AS3_ex.g3:1791:9: ( continueStatement )
        // AS3_ex.g3:1791:9: continueStatement
        {
            if (state.backtracking == 0)
            {
                InsertStatementCR();
            }
            PushFollow(FOLLOW_continueStatement_in_synpred182_AS3_ex7816);
            continueStatement();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred182_AS3_ex"

    // $ANTLR start "synpred183_AS3_ex"
    public void synpred183_AS3_ex_fragment()
    {
        // AS3_ex.g3:1792:9: ( forStatement )
        // AS3_ex.g3:1792:9: forStatement
        {
            if (state.backtracking == 0)
            {
                MarkBlockFlag(); InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
            }
            PushFollow(FOLLOW_forStatement_in_synpred183_AS3_ex7830);
            forStatement();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred183_AS3_ex"

    // $ANTLR start "synpred184_AS3_ex"
    public void synpred184_AS3_ex_fragment()
    {
        // AS3_ex.g3:1793:9: ( forInStatement )
        // AS3_ex.g3:1793:9: forInStatement
        {
            if (state.backtracking == 0)
            {
                MarkBlockFlag(); InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
            }
            PushFollow(FOLLOW_forInStatement_in_synpred184_AS3_ex7842);
            forInStatement();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred184_AS3_ex"

    // $ANTLR start "synpred185_AS3_ex"
    public void synpred185_AS3_ex_fragment()
    {
        // AS3_ex.g3:1794:9: ( forEachInStatement )
        // AS3_ex.g3:1794:9: forEachInStatement
        {
            if (state.backtracking == 0)
            {
                MarkBlockFlag(); InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
            }
            PushFollow(FOLLOW_forEachInStatement_in_synpred185_AS3_ex7854);
            forEachInStatement();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred185_AS3_ex"

    // $ANTLR start "synpred186_AS3_ex"
    public void synpred186_AS3_ex_fragment()
    {
        // AS3_ex.g3:1795:9: ( doWhileStatement )
        // AS3_ex.g3:1795:9: doWhileStatement
        {
            if (state.backtracking == 0)
            {
                MarkBlockFlag(); InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
            }
            PushFollow(FOLLOW_doWhileStatement_in_synpred186_AS3_ex7866);
            doWhileStatement();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred186_AS3_ex"

    // $ANTLR start "synpred187_AS3_ex"
    public void synpred187_AS3_ex_fragment()
    {
        // AS3_ex.g3:1796:9: ( whileStatement )
        // AS3_ex.g3:1796:9: whileStatement
        {
            if (state.backtracking == 0)
            {
                MarkBlockFlag(); InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
            }
            PushFollow(FOLLOW_whileStatement_in_synpred187_AS3_ex7878);
            whileStatement();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred187_AS3_ex"

    // $ANTLR start "synpred188_AS3_ex"
    public void synpred188_AS3_ex_fragment()
    {
        // AS3_ex.g3:1797:9: ( ifStatement )
        // AS3_ex.g3:1797:9: ifStatement
        {
            if (state.backtracking == 0)
            {
                InsertLines(mPrinter.GetBlankLinesBeforeControlStatement());
            }
            PushFollow(FOLLOW_ifStatement_in_synpred188_AS3_ex7889);
            ifStatement();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred188_AS3_ex"

    // $ANTLR start "synpred190_AS3_ex"
    public void synpred190_AS3_ex_fragment()
    {
        // AS3_ex.g3:1799:9: ( variableStatement )
        // AS3_ex.g3:1799:9: variableStatement
        {
            if (state.backtracking == 0)
            {
                InsertStatementCR();
            }
            PushFollow(FOLLOW_variableStatement_in_synpred190_AS3_ex7914);
            variableStatement();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred190_AS3_ex"

    // $ANTLR start "synpred193_AS3_ex"
    public void synpred193_AS3_ex_fragment()
    {
        IToken S = null;

        // AS3_ex.g3:1827:68: (S= SEMI )
        // AS3_ex.g3:1827:68: S= SEMI
        {
            S = (IToken)Match(input, SEMI, FOLLOW_SEMI_in_synpred193_AS3_ex8054); if (state.failed) return;

        }
    }
    // $ANTLR end "synpred193_AS3_ex"

    // $ANTLR start "synpred197_AS3_ex"
    public void synpred197_AS3_ex_fragment()
    {
        // AS3_ex.g3:1855:11: ( ( catchClause )+ finallyClause )
        // AS3_ex.g3:1855:11: ( catchClause )+ finallyClause
        {
            // AS3_ex.g3:1855:11: ( catchClause )+
            int cnt171 = 0;
            do
            {
                int alt171 = 2;
                int LA171_0 = input.LA(1);

                if ((LA171_0 == CATCH))
                {
                    alt171 = 1;
                }


                switch (alt171)
                {
                    case 1:
                        // AS3_ex.g3:0:0: catchClause
                        {
                            PushFollow(FOLLOW_catchClause_in_synpred197_AS3_ex8290);
                            catchClause();
                            state.followingStackPointer--;
                            if (state.failed) return;

                        }
                        break;

                    default:
                        if (cnt171 >= 1) goto loop171;
                        if (state.backtracking > 0) { state.failed = true; return; }
                        EarlyExitException eee =
                            new EarlyExitException(171, input);
                        throw eee;
                }
                cnt171++;
            } while (true);

        loop171:
            ;	// Stops C# compiler whinging that label 'loop171' has no statements

            PushFollow(FOLLOW_finallyClause_in_synpred197_AS3_ex8293);
            finallyClause();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred197_AS3_ex"

    // $ANTLR start "synpred199_AS3_ex"
    public void synpred199_AS3_ex_fragment()
    {
        // AS3_ex.g3:1856:11: ( ( catchClause )+ )
        // AS3_ex.g3:1856:11: ( catchClause )+
        {
            // AS3_ex.g3:1856:11: ( catchClause )+
            int cnt172 = 0;
            do
            {
                int alt172 = 2;
                int LA172_0 = input.LA(1);

                if ((LA172_0 == CATCH))
                {
                    alt172 = 1;
                }


                switch (alt172)
                {
                    case 1:
                        // AS3_ex.g3:0:0: catchClause
                        {
                            PushFollow(FOLLOW_catchClause_in_synpred199_AS3_ex8305);
                            catchClause();
                            state.followingStackPointer--;
                            if (state.failed) return;

                        }
                        break;

                    default:
                        if (cnt172 >= 1) goto loop172;
                        if (state.backtracking > 0) { state.failed = true; return; }
                        EarlyExitException eee =
                            new EarlyExitException(172, input);
                        throw eee;
                }
                cnt172++;
            } while (true);

        loop172:
            ;	// Stops C# compiler whinging that label 'loop172' has no statements


        }
    }
    // $ANTLR end "synpred199_AS3_ex"

    // $ANTLR start "synpred201_AS3_ex"
    public void synpred201_AS3_ex_fragment()
    {
        // AS3_ex.g3:1904:61: ( statement )
        // AS3_ex.g3:1904:61: statement
        {
            PushFollow(FOLLOW_statement_in_synpred201_AS3_ex8571);
            statement();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred201_AS3_ex"

    // $ANTLR start "synpred211_AS3_ex"
    public void synpred211_AS3_ex_fragment()
    {
        // AS3_ex.g3:1989:9: ( variableDeclarationNoInList )
        // AS3_ex.g3:1989:9: variableDeclarationNoInList
        {
            PushFollow(FOLLOW_variableDeclarationNoInList_in_synpred211_AS3_ex9126);
            variableDeclarationNoInList();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred211_AS3_ex"

    // $ANTLR start "synpred212_AS3_ex"
    public void synpred212_AS3_ex_fragment()
    {
        IToken S = null;

        // AS3_ex.g3:2003:241: (S= SEMI )
        // AS3_ex.g3:2003:241: S= SEMI
        {
            S = (IToken)Match(input, SEMI, FOLLOW_SEMI_in_synpred212_AS3_ex9207); if (state.failed) return;

        }
    }
    // $ANTLR end "synpred212_AS3_ex"

    // $ANTLR start "synpred213_AS3_ex"
    public void synpred213_AS3_ex_fragment()
    {
        IToken E = null;

        // AS3_ex.g3:2058:26: (E= ELSE statement )
        // AS3_ex.g3:2058:26: E= ELSE statement
        {
            E = (IToken)Match(input, ELSE, FOLLOW_ELSE_in_synpred213_AS3_ex9446); if (state.failed) return;
            PushFollow(FOLLOW_statement_in_synpred213_AS3_ex9487);
            statement();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred213_AS3_ex"

    // $ANTLR start "synpred230_AS3_ex"
    public void synpred230_AS3_ex_fragment()
    {
        // AS3_ex.g3:2193:7: ( leftHandSideExpression assignmentOperator assignmentExpression )
        // AS3_ex.g3:2193:7: leftHandSideExpression assignmentOperator assignmentExpression
        {
            PushFollow(FOLLOW_leftHandSideExpression_in_synpred230_AS3_ex10219);
            leftHandSideExpression();
            state.followingStackPointer--;
            if (state.failed) return;
            PushFollow(FOLLOW_assignmentOperator_in_synpred230_AS3_ex10222);
            assignmentOperator();
            state.followingStackPointer--;
            if (state.failed) return;
            PushFollow(FOLLOW_assignmentExpression_in_synpred230_AS3_ex10225);
            assignmentExpression();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred230_AS3_ex"

    // $ANTLR start "synpred231_AS3_ex"
    public void synpred231_AS3_ex_fragment()
    {
        // AS3_ex.g3:2199:9: ( conditionalExpressionNoIn )
        // AS3_ex.g3:2199:9: conditionalExpressionNoIn
        {
            PushFollow(FOLLOW_conditionalExpressionNoIn_in_synpred231_AS3_ex10253);
            conditionalExpressionNoIn();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred231_AS3_ex"

    // $ANTLR start "synpred274_AS3_ex"
    public void synpred274_AS3_ex_fragment()
    {
        IToken g = null;
        IToken assign = null;
        IToken eq = null;

        // AS3_ex.g3:2308:7: ( (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )
        // AS3_ex.g3:2308:7: (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression
        {
            // AS3_ex.g3:2308:7: (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) )
            int alt175 = 2;
            int LA175_0 = input.LA(1);

            if ((LA175_0 == GT))
            {
                alt175 = 1;
            }
            else if ((LA175_0 == AS || (LA175_0 >= IN && LA175_0 <= INSTANCEOF) || LA175_0 == IS || LA175_0 == LT || LA175_0 == LTE))
            {
                alt175 = 2;
            }
            else
            {
                if (state.backtracking > 0) { state.failed = true; return; }
                NoViableAltException nvae_d175s0 =
                    new NoViableAltException("", 175, 0, input);

                throw nvae_d175s0;
            }
            switch (alt175)
            {
                case 1:
                    // AS3_ex.g3:2308:9: g= GT (assign= ASSIGN )?
                    {
                        g = (IToken)Match(input, GT, FOLLOW_GT_in_synpred274_AS3_ex11147); if (state.failed) return;
                        // AS3_ex.g3:2308:14: (assign= ASSIGN )?
                        int alt174 = 2;
                        int LA174_0 = input.LA(1);

                        if ((LA174_0 == ASSIGN))
                        {
                            alt174 = 1;
                        }
                        switch (alt174)
                        {
                            case 1:
                                // AS3_ex.g3:2308:15: assign= ASSIGN
                                {
                                    assign = (IToken)Match(input, ASSIGN, FOLLOW_ASSIGN_in_synpred274_AS3_ex11152); if (state.failed) return;

                                }
                                break;

                        }


                    }
                    break;
                case 2:
                    // AS3_ex.g3:2316:14: eq= ( IN | LT | LTE | INSTANCEOF | IS | AS )
                    {
                        eq = (IToken)input.LT(1);
                        if (input.LA(1) == AS || (input.LA(1) >= IN && input.LA(1) <= INSTANCEOF) || input.LA(1) == IS || input.LA(1) == LT || input.LA(1) == LTE)
                        {
                            input.Consume();
                            state.errorRecovery = false; state.failed = false;
                        }
                        else
                        {
                            if (state.backtracking > 0) { state.failed = true; return; }
                            MismatchedSetException mse = new MismatchedSetException(null, input);
                            throw mse;
                        }


                    }
                    break;

            }

            PushFollow(FOLLOW_shiftExpression_in_synpred274_AS3_ex11223);
            shiftExpression();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred274_AS3_ex"

    // $ANTLR start "synpred285_AS3_ex"
    public void synpred285_AS3_ex_fragment()
    {
        // AS3_ex.g3:2348:11: ( '>' '>' '>' )
        // AS3_ex.g3:2348:12: '>' '>' '>'
        {
            Match(input, GT, FOLLOW_GT_in_synpred285_AS3_ex11475); if (state.failed) return;
            Match(input, GT, FOLLOW_GT_in_synpred285_AS3_ex11477); if (state.failed) return;
            Match(input, GT, FOLLOW_GT_in_synpred285_AS3_ex11479); if (state.failed) return;

        }
    }
    // $ANTLR end "synpred285_AS3_ex"

    // $ANTLR start "synpred288_AS3_ex"
    public void synpred288_AS3_ex_fragment()
    {
        IToken op = null;

        // AS3_ex.g3:2361:36: (op= ( PLUS | SUB ) multiplicativeExpression )
        // AS3_ex.g3:2361:36: op= ( PLUS | SUB ) multiplicativeExpression
        {
            op = (IToken)input.LT(1);
            if ((input.LA(1) >= PLUS && input.LA(1) <= SUB))
            {
                input.Consume();
                state.errorRecovery = false; state.failed = false;
            }
            else
            {
                if (state.backtracking > 0) { state.failed = true; return; }
                MismatchedSetException mse = new MismatchedSetException(null, input);
                throw mse;
            }

            PushFollow(FOLLOW_multiplicativeExpression_in_synpred288_AS3_ex11584);
            multiplicativeExpression();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred288_AS3_ex"

    // $ANTLR start "synpred291_AS3_ex"
    public void synpred291_AS3_ex_fragment()
    {
        IToken op = null;

        // AS3_ex.g3:2366:27: (op= ( STAR | DIV | MOD ) unaryExpression )
        // AS3_ex.g3:2366:27: op= ( STAR | DIV | MOD ) unaryExpression
        {
            op = (IToken)input.LT(1);
            if ((input.LA(1) >= STAR && input.LA(1) <= MOD))
            {
                input.Consume();
                state.errorRecovery = false; state.failed = false;
            }
            else
            {
                if (state.backtracking > 0) { state.failed = true; return; }
                MismatchedSetException mse = new MismatchedSetException(null, input);
                throw mse;
            }

            PushFollow(FOLLOW_unaryExpression_in_synpred291_AS3_ex11623);
            unaryExpression();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred291_AS3_ex"

    // $ANTLR start "synpred292_AS3_ex"
    public void synpred292_AS3_ex_fragment()
    {
        // AS3_ex.g3:2371:9: ( postfixExpression )
        // AS3_ex.g3:2371:9: postfixExpression
        {
            PushFollow(FOLLOW_postfixExpression_in_synpred292_AS3_ex11647);
            postfixExpression();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred292_AS3_ex"

    // $ANTLR start "synpred294_AS3_ex"
    public void synpred294_AS3_ex_fragment()
    {
        IToken op = null;

        // AS3_ex.g3:2372:8: (op= ( NOT | INV ) unaryExpression )
        // AS3_ex.g3:2372:8: op= ( NOT | INV ) unaryExpression
        {
            op = (IToken)input.LT(1);
            if ((input.LA(1) >= NOT && input.LA(1) <= INV))
            {
                input.Consume();
                state.errorRecovery = false; state.failed = false;
            }
            else
            {
                if (state.backtracking > 0) { state.failed = true; return; }
                MismatchedSetException mse = new MismatchedSetException(null, input);
                throw mse;
            }

            PushFollow(FOLLOW_unaryExpression_in_synpred294_AS3_ex11668);
            unaryExpression();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred294_AS3_ex"

    // $ANTLR start "synpred303_AS3_ex"
    public void synpred303_AS3_ex_fragment()
    {
        // AS3_ex.g3:2385:32: ( postfixOp )
        // AS3_ex.g3:2385:32: postfixOp
        {
            PushFollow(FOLLOW_postfixOp_in_synpred303_AS3_ex11770);
            postfixOp();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred303_AS3_ex"

    // $ANTLR start "synpred307_AS3_ex"
    public void synpred307_AS3_ex_fragment()
    {
        // AS3_ex.g3:2407:7: ( arguments )
        // AS3_ex.g3:2407:7: arguments
        {
            PushFollow(FOLLOW_arguments_in_synpred307_AS3_ex11878);
            arguments();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred307_AS3_ex"

    // $ANTLR start "synpred308_AS3_ex"
    public void synpred308_AS3_ex_fragment()
    {
        IToken L = null;
        IToken R = null;

        // AS3_ex.g3:2408:9: (L= LBRACK expression R= RBRACK )
        // AS3_ex.g3:2408:9: L= LBRACK expression R= RBRACK
        {
            L = (IToken)Match(input, LBRACK, FOLLOW_LBRACK_in_synpred308_AS3_ex11890); if (state.failed) return;
            PushFollow(FOLLOW_expression_in_synpred308_AS3_ex11894);
            expression();
            state.followingStackPointer--;
            if (state.failed) return;
            R = (IToken)Match(input, RBRACK, FOLLOW_RBRACK_in_synpred308_AS3_ex11898); if (state.failed) return;

        }
    }
    // $ANTLR end "synpred308_AS3_ex"

    // $ANTLR start "synpred309_AS3_ex"
    public void synpred309_AS3_ex_fragment()
    {
        IToken op = null;

        // AS3_ex.g3:2410:41: ( eitherIdentifier op= XML_NS_OP )
        // AS3_ex.g3:2410:41: eitherIdentifier op= XML_NS_OP
        {
            PushFollow(FOLLOW_eitherIdentifier_in_synpred309_AS3_ex11918);
            eitherIdentifier();
            state.followingStackPointer--;
            if (state.failed) return;
            op = (IToken)Match(input, XML_NS_OP, FOLLOW_XML_NS_OP_in_synpred309_AS3_ex11922); if (state.failed) return;

        }
    }
    // $ANTLR end "synpred309_AS3_ex"

    // $ANTLR start "synpred310_AS3_ex"
    public void synpred310_AS3_ex_fragment()
    {
        IToken D = null;
        IToken op = null;

        // AS3_ex.g3:2410:9: (D= DOT ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier )
        // AS3_ex.g3:2410:9: D= DOT ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier
        {
            D = (IToken)Match(input, DOT, FOLLOW_DOT_in_synpred310_AS3_ex11913); if (state.failed) return;
            // AS3_ex.g3:2410:40: ( eitherIdentifier op= XML_NS_OP )?
            int alt180 = 2;
            switch (input.LA(1))
            {
                case IDENTIFIER:
                    {
                        int LA180_1 = input.LA(2);

                        if ((synpred309_AS3_ex()))
                        {
                            alt180 = 1;
                        }
                    }
                    break;
                case XML_AT:
                    {
                        int LA180_2 = input.LA(2);

                        if ((synpred309_AS3_ex()))
                        {
                            alt180 = 1;
                        }
                    }
                    break;
                case AS:
                case BREAK:
                case CASE:
                case CATCH:
                case CLASS:
                case CONST:
                case CONTINUE:
                case DEFAULT:
                case DELETE:
                case DO:
                case ELSE:
                case EXTENDS:
                case FALSE:
                case FINALLY:
                case FOR:
                case FUNCTION:
                case IF:
                case IMPLEMENTS:
                case IMPORT:
                case IN:
                case INSTANCEOF:
                case INTERFACE:
                case INTERNAL:
                case IS:
                case NEW:
                case NULL:
                case PACKAGE:
                case PRIVATE:
                case PROTECTED:
                case PUBLIC:
                case RETURN:
                case SUPER:
                case SWITCH:
                case THIS:
                case THROW:
                case TRUE:
                case TRY:
                case TYPEOF:
                case USE:
                case VAR:
                case VOID:
                case WHILE:
                case WITH:
                case INCLUDE:
                    {
                        int LA180_3 = input.LA(2);

                        if ((synpred309_AS3_ex()))
                        {
                            alt180 = 1;
                        }
                    }
                    break;
                case NATIVE:
                case TO:
                case EACH:
                case GET:
                case SET:
                case NAMESPACE:
                case DYNAMIC:
                case FINAL:
                case OVERRIDE:
                case STATIC:
                    {
                        int LA180_4 = input.LA(2);

                        if ((synpred309_AS3_ex()))
                        {
                            alt180 = 1;
                        }
                    }
                    break;
                case STAR:
                    {
                        int LA180_5 = input.LA(2);

                        if ((synpred309_AS3_ex()))
                        {
                            alt180 = 1;
                        }
                    }
                    break;
            }

            switch (alt180)
            {
                case 1:
                    // AS3_ex.g3:2410:41: eitherIdentifier op= XML_NS_OP
                    {
                        PushFollow(FOLLOW_eitherIdentifier_in_synpred310_AS3_ex11918);
                        eitherIdentifier();
                        state.followingStackPointer--;
                        if (state.failed) return;
                        op = (IToken)Match(input, XML_NS_OP, FOLLOW_XML_NS_OP_in_synpred310_AS3_ex11922); if (state.failed) return;

                    }
                    break;

            }

            PushFollow(FOLLOW_eitherIdentifier_in_synpred310_AS3_ex11929);
            eitherIdentifier();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred310_AS3_ex"

    // $ANTLR start "synpred311_AS3_ex"
    public void synpred311_AS3_ex_fragment()
    {
        IToken op = null;

        // AS3_ex.g3:2411:49: ( eitherIdentifier op= XML_NS_OP )
        // AS3_ex.g3:2411:49: eitherIdentifier op= XML_NS_OP
        {
            PushFollow(FOLLOW_eitherIdentifier_in_synpred311_AS3_ex11945);
            eitherIdentifier();
            state.followingStackPointer--;
            if (state.failed) return;
            op = (IToken)Match(input, XML_NS_OP, FOLLOW_XML_NS_OP_in_synpred311_AS3_ex11949); if (state.failed) return;

        }
    }
    // $ANTLR end "synpred311_AS3_ex"

    // $ANTLR start "synpred313_AS3_ex"
    public void synpred313_AS3_ex_fragment()
    {
        IToken D = null;

        // AS3_ex.g3:2412:9: (D= DOT parExpression )
        // AS3_ex.g3:2412:9: D= DOT parExpression
        {
            D = (IToken)Match(input, DOT, FOLLOW_DOT_in_synpred313_AS3_ex11968); if (state.failed) return;
            PushFollow(FOLLOW_parExpression_in_synpred313_AS3_ex11972);
            parExpression();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred313_AS3_ex"

    // $ANTLR start "synpred314_AS3_ex"
    public void synpred314_AS3_ex_fragment()
    {
        // AS3_ex.g3:2413:9: ( typePostfixSyntax )
        // AS3_ex.g3:2413:9: typePostfixSyntax
        {
            PushFollow(FOLLOW_typePostfixSyntax_in_synpred314_AS3_ex11982);
            typePostfixSyntax();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred314_AS3_ex"

    // $ANTLR start "synpred315_AS3_ex"
    public void synpred315_AS3_ex_fragment()
    {
        IToken I = null;

        // AS3_ex.g3:2418:4: (I= IDENTIFIER )
        // AS3_ex.g3:2418:4: I= IDENTIFIER
        {
            I = (IToken)Match(input, IDENTIFIER, FOLLOW_IDENTIFIER_in_synpred315_AS3_ex12012); if (state.failed) return;

        }
    }
    // $ANTLR end "synpred315_AS3_ex"

    // $ANTLR start "synpred316_AS3_ex"
    public void synpred316_AS3_ex_fragment()
    {
        // AS3_ex.g3:2419:5: ( xmlPropertyIdentifier )
        // AS3_ex.g3:2419:5: xmlPropertyIdentifier
        {
            PushFollow(FOLLOW_xmlPropertyIdentifier_in_synpred316_AS3_ex12022);
            xmlPropertyIdentifier();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred316_AS3_ex"

    // $ANTLR start "synpred378_AS3_ex"
    public void synpred378_AS3_ex_fragment()
    {
        IToken T = null;

        // AS3_ex.g3:2544:9: (T= THIS )
        // AS3_ex.g3:2544:9: T= THIS
        {
            T = (IToken)Match(input, THIS, FOLLOW_THIS_in_synpred378_AS3_ex13032); if (state.failed) return;

        }
    }
    // $ANTLR end "synpred378_AS3_ex"

    // $ANTLR start "synpred379_AS3_ex"
    public void synpred379_AS3_ex_fragment()
    {
        IToken S = null;

        // AS3_ex.g3:2545:9: (S= SUPER )
        // AS3_ex.g3:2545:9: S= SUPER
        {
            S = (IToken)Match(input, SUPER, FOLLOW_SUPER_in_synpred379_AS3_ex13046); if (state.failed) return;

        }
    }
    // $ANTLR end "synpred379_AS3_ex"

    // $ANTLR start "synpred380_AS3_ex"
    public void synpred380_AS3_ex_fragment()
    {
        // AS3_ex.g3:2546:9: ( literal )
        // AS3_ex.g3:2546:9: literal
        {
            PushFollow(FOLLOW_literal_in_synpred380_AS3_ex13058);
            literal();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred380_AS3_ex"

    // $ANTLR start "synpred383_AS3_ex"
    public void synpred383_AS3_ex_fragment()
    {
        // AS3_ex.g3:2549:9: ( identifierLiteral )
        // AS3_ex.g3:2549:9: identifierLiteral
        {
            PushFollow(FOLLOW_identifierLiteral_in_synpred383_AS3_ex13093);
            identifierLiteral();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred383_AS3_ex"

    // $ANTLR start "synpred384_AS3_ex"
    public void synpred384_AS3_ex_fragment()
    {
        // AS3_ex.g3:2550:9: ( xmlPrimaryExpression )
        // AS3_ex.g3:2550:9: xmlPrimaryExpression
        {
            PushFollow(FOLLOW_xmlPrimaryExpression_in_synpred384_AS3_ex13104);
            xmlPrimaryExpression();
            state.followingStackPointer--;
            if (state.failed) return;

        }
    }
    // $ANTLR end "synpred384_AS3_ex"

    // Delegated rules

    public bool synpred303_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred303_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred201_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred201_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred384_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred384_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred70_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred70_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred185_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred185_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred144_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred144_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred99_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred99_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred288_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred288_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred134_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred134_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred108_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred108_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred174_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred174_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred175_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred175_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred178_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred178_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred310_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred310_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred76_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred76_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred190_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred190_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred131_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred131_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred183_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred183_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred133_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred133_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred378_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred378_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred9_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred9_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred71_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred71_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred309_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred309_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred292_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred292_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred211_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred211_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred135_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred135_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred379_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred379_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred107_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred107_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred285_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred285_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred77_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred77_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred197_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred197_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred136_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred136_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred101_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred101_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred182_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred182_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred199_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred199_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred308_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred308_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred291_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred291_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred187_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred187_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred231_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred231_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred184_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred184_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred193_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred193_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred171_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred171_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred383_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred383_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred307_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred307_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred274_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred274_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred315_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred315_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred179_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred179_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred180_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred180_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred109_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred109_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred159_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred159_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred105_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred105_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred212_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred212_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred213_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred213_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred176_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred176_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred316_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred316_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred103_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred103_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred161_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred161_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred106_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred106_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred230_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred230_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred100_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred100_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred177_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred177_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred173_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred173_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred181_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred181_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred311_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred311_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred75_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred75_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred132_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred132_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred122_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred122_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred380_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred380_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred313_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred313_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred160_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred160_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred314_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred314_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred186_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred186_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred172_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred172_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred294_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred294_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred102_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred102_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }
    public bool synpred188_AS3_ex()
    {
        state.backtracking++;
        int start = input.Mark();
        try
        {
            synpred188_AS3_ex_fragment(); // can never throw exception
        }
        catch (RecognitionException re)
        {
            Console.Error.WriteLine("impossible: " + re);
        }
        bool success = !state.failed;
        input.Rewind(start);
        state.backtracking--;
        state.failed = false;
        return success;
    }


    protected DFA8 dfa8;
    protected DFA14 dfa14;
    protected DFA34 dfa34;
    protected DFA36 dfa36;
    protected DFA54 dfa54;
    protected DFA55 dfa55;
    protected DFA74 dfa74;
    protected DFA76 dfa76;
    protected DFA86 dfa86;
    protected DFA114 dfa114;
    protected DFA115 dfa115;
    protected DFA116 dfa116;
    protected DFA133 dfa133;
    protected DFA139 dfa139;
    protected DFA140 dfa140;
    protected DFA141 dfa141;
    protected DFA142 dfa142;
    protected DFA146 dfa146;
    protected DFA154 dfa154;
    private void InitializeCyclicDFAs()
    {
        this.dfa8 = new DFA8(this);
        this.dfa14 = new DFA14(this);
        this.dfa34 = new DFA34(this);
        this.dfa36 = new DFA36(this);
        this.dfa54 = new DFA54(this);
        this.dfa55 = new DFA55(this);
        this.dfa74 = new DFA74(this);
        this.dfa76 = new DFA76(this);
        this.dfa86 = new DFA86(this);
        this.dfa114 = new DFA114(this);
        this.dfa115 = new DFA115(this);
        this.dfa116 = new DFA116(this);
        this.dfa133 = new DFA133(this);
        this.dfa139 = new DFA139(this);
        this.dfa140 = new DFA140(this);
        this.dfa141 = new DFA141(this);
        this.dfa142 = new DFA142(this);
        this.dfa146 = new DFA146(this);
        this.dfa154 = new DFA154(this);
        this.dfa8.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA8_SpecialStateTransition);
        this.dfa14.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA14_SpecialStateTransition);
        this.dfa34.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA34_SpecialStateTransition);
        this.dfa36.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA36_SpecialStateTransition);
        this.dfa54.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA54_SpecialStateTransition);
        this.dfa55.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA55_SpecialStateTransition);
        this.dfa74.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA74_SpecialStateTransition);
        this.dfa76.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA76_SpecialStateTransition);
        this.dfa86.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA86_SpecialStateTransition);
        this.dfa114.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA114_SpecialStateTransition);
        this.dfa115.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA115_SpecialStateTransition);

        this.dfa133.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA133_SpecialStateTransition);
        this.dfa139.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA139_SpecialStateTransition);
        this.dfa140.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA140_SpecialStateTransition);
        this.dfa141.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA141_SpecialStateTransition);
        this.dfa142.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA142_SpecialStateTransition);
        this.dfa146.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA146_SpecialStateTransition);
        this.dfa154.specialStateTransitionHandler = new DFA.SpecialStateTransitionHandler(DFA154_SpecialStateTransition);
    }

    const string DFA8_eotS =
        "\x5b\uffff";
    const string DFA8_eofS =
        "\x01\x01\x5a\uffff";
    const string DFA8_minS =
        "\x01\x04\x02\uffff\x01\x00\x11\uffff\x01\x00\x3f\uffff\x01\x00" +
        "\x05\uffff";
    const string DFA8_maxS =
        "\x01\u0092\x02\uffff\x01\x00\x11\uffff\x01\x00\x3f\uffff\x01\x00" +
        "\x05\uffff";
    const string DFA8_acceptS =
        "\x01\uffff\x01\x02\x58\uffff\x01\x01";
    const string DFA8_specialS =
        "\x03\uffff\x01\x00\x11\uffff\x01\x01\x3f\uffff\x01\x02\x05\uffff}>";
    static readonly string[] DFA8_transitionS = {
            "\x3d\x01\x01\x03\x04\x01\x01\uffff\x05\x01\x01\x15\x06\x01"+
            "\x02\uffff\x08\x01\x01\x55\x01\x01\x02\uffff\x05\x01\x02\uffff"+
            "\x05\x01\x01\uffff\x02\x01\x01\uffff\x03\x01\x0c\uffff\x02\x01"+
            "\x02\uffff\x01\x01\x04\uffff\x01\x01\x02\uffff\x01\x01\x01\uffff"+
            "\x01\x01\x01\uffff\x03\x01",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA8_eot = DFA.UnpackEncodedString(DFA8_eotS);
    static readonly short[] DFA8_eof = DFA.UnpackEncodedString(DFA8_eofS);
    static readonly char[] DFA8_min = DFA.UnpackEncodedStringToUnsignedChars(DFA8_minS);
    static readonly char[] DFA8_max = DFA.UnpackEncodedStringToUnsignedChars(DFA8_maxS);
    static readonly short[] DFA8_accept = DFA.UnpackEncodedString(DFA8_acceptS);
    static readonly short[] DFA8_special = DFA.UnpackEncodedString(DFA8_specialS);
    static readonly short[][] DFA8_transition = DFA.UnpackEncodedStringArray(DFA8_transitionS);

    protected class DFA8 : DFA
    {
        public DFA8(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 8;
            this.eot = DFA8_eot;
            this.eof = DFA8_eof;
            this.min = DFA8_min;
            this.max = DFA8_max;
            this.accept = DFA8_accept;
            this.special = DFA8_special;
            this.transition = DFA8_transition;

        }

        override public string Description
        {
            get { return "()* loopback of 1247:93: ({...}? => (s= SUB | d= DOT | c= COLON ) {...}? => (I2= IDENTIFIER | allKeywords ) )*"; }
        }

    }


    protected internal int DFA8_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
        ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch (s)
        {
            case 0:
                int LA8_3 = input.LA(1);


                int index8_3 = input.Index();
                input.Rewind();
                s = -1;
                if (((synpred9_AS3_ex() && (!PromoteWhitespace())))) { s = 90; }

                else if ((true)) { s = 1; }


                input.Seek(index8_3);
                if (s >= 0) return s;
                break;
            case 1:
                int LA8_21 = input.LA(1);


                int index8_21 = input.Index();
                input.Rewind();
                s = -1;
                if (((synpred9_AS3_ex() && (!PromoteWhitespace())))) { s = 90; }

                else if ((true)) { s = 1; }


                input.Seek(index8_21);
                if (s >= 0) return s;
                break;
            case 2:
                int LA8_85 = input.LA(1);


                int index8_85 = input.Index();
                input.Rewind();
                s = -1;
                if (((synpred9_AS3_ex() && (!PromoteWhitespace())))) { s = 90; }

                else if ((true)) { s = 1; }


                input.Seek(index8_85);
                if (s >= 0) return s;
                break;
        }
        if (state.backtracking > 0) { state.failed = true; return -1; }
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 8, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA14_eotS =
        "\x0a\uffff";
    const string DFA14_eofS =
        "\x03\uffff\x02\x05\x05\uffff";
    const string DFA14_minS =
        "\x01\x04\x02\uffff\x02\x04\x01\uffff\x04\x00";
    const string DFA14_maxS =
        "\x01\u008e\x02\uffff\x01\u0092\x01\u008e\x01\uffff\x04\x00";
    const string DFA14_acceptS =
        "\x01\uffff\x01\x01\x01\x02\x02\uffff\x01\x03\x04\uffff";
    const string DFA14_specialS =
        "\x06\uffff\x01\x03\x01\x02\x01\x00\x01\x01}>";
    static readonly string[] DFA14_transitionS = {
            "\x36\x02\x13\uffff\x01\x03\x24\uffff\x01\x01\x1b\uffff\x01"+
            "\x02",
            "",
            "",
            "\x42\x05\x01\uffff\x0c\x05\x02\uffff\x0a\x05\x02\uffff\x05"+
            "\x05\x02\uffff\x05\x05\x01\uffff\x01\x05\x02\uffff\x01\x04\x02"+
            "\x05\x0c\uffff\x02\x05\x02\uffff\x01\x05\x04\uffff\x01\x05\x02"+
            "\uffff\x01\x05\x01\uffff\x01\x05\x01\uffff\x03\x05",
            "\x18\x07\x01\x08\x0b\x07\x01\x08\x08\x07\x04\x08\x01\x07\x04"+
            "\x08\x05\uffff\x01\x02\x0d\uffff\x01\x09\x24\uffff\x01\x05\x1b"+
            "\uffff\x01\x06",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff"
    };

    static readonly short[] DFA14_eot = DFA.UnpackEncodedString(DFA14_eotS);
    static readonly short[] DFA14_eof = DFA.UnpackEncodedString(DFA14_eofS);
    static readonly char[] DFA14_min = DFA.UnpackEncodedStringToUnsignedChars(DFA14_minS);
    static readonly char[] DFA14_max = DFA.UnpackEncodedStringToUnsignedChars(DFA14_maxS);
    static readonly short[] DFA14_accept = DFA.UnpackEncodedString(DFA14_acceptS);
    static readonly short[] DFA14_special = DFA.UnpackEncodedString(DFA14_specialS);
    static readonly short[][] DFA14_transition = DFA.UnpackEncodedStringArray(DFA14_transitionS);

    protected class DFA14 : DFA
    {
        public DFA14(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 14;
            this.eot = DFA14_eot;
            this.eof = DFA14_eof;
            this.min = DFA14_min;
            this.max = DFA14_max;
            this.accept = DFA14_accept;
            this.special = DFA14_special;
            this.transition = DFA14_transition;

        }

        override public string Description
        {
            get { return "1366:1: xmlPropertyIdentifier : ( xmlAttributeIdentifier | xmlQualifiedIdentifier | s= STAR );"; }
        }

    }


    protected internal int DFA14_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
        ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch (s)
        {
            case 0:
                int LA14_8 = input.LA(1);


                int index14_8 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred75_AS3_ex())) { s = 2; }

                else if ((true)) { s = 5; }


                input.Seek(index14_8);
                if (s >= 0) return s;
                break;
            case 1:
                int LA14_9 = input.LA(1);


                int index14_9 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred75_AS3_ex())) { s = 2; }

                else if ((true)) { s = 5; }


                input.Seek(index14_9);
                if (s >= 0) return s;
                break;
            case 2:
                int LA14_7 = input.LA(1);


                int index14_7 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred75_AS3_ex())) { s = 2; }

                else if ((true)) { s = 5; }


                input.Seek(index14_7);
                if (s >= 0) return s;
                break;
            case 3:
                int LA14_6 = input.LA(1);


                int index14_6 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred75_AS3_ex())) { s = 2; }

                else if ((true)) { s = 5; }


                input.Seek(index14_6);
                if (s >= 0) return s;
                break;
        }
        if (state.backtracking > 0) { state.failed = true; return -1; }
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 14, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA34_eotS =
        "\x37\uffff";
    const string DFA34_eofS =
        "\x01\x01\x36\uffff";
    const string DFA34_minS =
        "\x01\x04\x01\uffff\x08\x00\x01\uffff\x05\x00\x27\uffff";
    const string DFA34_maxS =
        "\x01\u0092\x01\uffff\x08\x00\x01\uffff\x05\x00\x27\uffff";
    const string DFA34_acceptS =
        "\x01\uffff\x01\x06\x08\uffff\x01\x03\x28\uffff\x01\x01\x01\x02" +
        "\x01\x05\x01\x04";
    const string DFA34_specialS =
        "\x02\uffff\x01\x00\x01\x01\x01\x02\x01\x03\x01\x04\x01\x05\x01" +
        "\x06\x01\x07\x01\uffff\x01\x08\x01\x09\x01\x0a\x01\x0b\x01\x0c\x27" +
        "\uffff}>";
    static readonly string[] DFA34_transitionS = {
            "\x05\x0a\x01\x07\x01\x0a\x01\x0f\x07\x0a\x01\x09\x02\x0a\x01"+
            "\x0e\x03\x0a\x01\x05\x01\x0a\x01\x03\x03\x0a\x03\x05\x05\x0a"+
            "\x01\x08\x03\x0a\x01\x0d\x01\x06\x03\x0a\x03\x08\x01\x04\x01"+
            "\x0c\x04\x03\x02\x0a\x01\uffff\x01\x0a\x01\uffff\x01\x0b\x03"+
            "\uffff\x01\x0a\x07\uffff\x03\x0a\x02\uffff\x02\x0a\x06\uffff"+
            "\x02\x0a\x18\uffff\x02\x0a\x0c\uffff\x02\x0a\x02\uffff\x01\x0a"+
            "\x04\uffff\x01\x0a\x02\uffff\x01\x0a\x01\uffff\x01\x02\x01\uffff"+
            "\x03\x0a",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA34_eot = DFA.UnpackEncodedString(DFA34_eotS);
    static readonly short[] DFA34_eof = DFA.UnpackEncodedString(DFA34_eofS);
    static readonly char[] DFA34_min = DFA.UnpackEncodedStringToUnsignedChars(DFA34_minS);
    static readonly char[] DFA34_max = DFA.UnpackEncodedStringToUnsignedChars(DFA34_maxS);
    static readonly short[] DFA34_accept = DFA.UnpackEncodedString(DFA34_acceptS);
    static readonly short[] DFA34_special = DFA.UnpackEncodedString(DFA34_specialS);
    static readonly short[][] DFA34_transition = DFA.UnpackEncodedStringArray(DFA34_transitionS);

    protected class DFA34 : DFA
    {
        public DFA34(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 34;
            this.eot = DFA34_eot;
            this.eof = DFA34_eof;
            this.min = DFA34_min;
            this.max = DFA34_max;
            this.accept = DFA34_accept;
            this.special = DFA34_special;
            this.transition = DFA34_transition;

        }

        override public string Description
        {
            get { return "()* loopback of 1524:6: ( propertyDeclaration | functionDeclaration | statement | directive | interfaceFunctionDeclaration )*"; }
        }

    }


    protected internal int DFA34_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
        ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch (s)
        {
            case 0:
                int LA34_2 = input.LA(1);


                int index34_2 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred99_AS3_ex())) { s = 51; }

                else if ((synpred100_AS3_ex())) { s = 52; }

                else if ((synpred101_AS3_ex())) { s = 10; }

                else if ((synpred103_AS3_ex())) { s = 53; }


                input.Seek(index34_2);
                if (s >= 0) return s;
                break;
            case 1:
                int LA34_3 = input.LA(1);


                int index34_3 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred99_AS3_ex())) { s = 51; }

                else if ((synpred100_AS3_ex())) { s = 52; }

                else if ((synpred101_AS3_ex())) { s = 10; }

                else if ((synpred103_AS3_ex())) { s = 53; }


                input.Seek(index34_3);
                if (s >= 0) return s;
                break;
            case 2:
                int LA34_4 = input.LA(1);


                int index34_4 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred99_AS3_ex())) { s = 51; }

                else if ((synpred100_AS3_ex())) { s = 52; }

                else if ((synpred101_AS3_ex())) { s = 10; }

                else if ((synpred103_AS3_ex())) { s = 53; }


                input.Seek(index34_4);
                if (s >= 0) return s;
                break;
            case 3:
                int LA34_5 = input.LA(1);


                int index34_5 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred99_AS3_ex())) { s = 51; }

                else if ((synpred100_AS3_ex())) { s = 52; }

                else if ((synpred101_AS3_ex())) { s = 10; }

                else if ((synpred103_AS3_ex())) { s = 53; }


                input.Seek(index34_5);
                if (s >= 0) return s;
                break;
            case 4:
                int LA34_6 = input.LA(1);


                int index34_6 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred99_AS3_ex())) { s = 51; }

                else if ((synpred101_AS3_ex())) { s = 10; }


                input.Seek(index34_6);
                if (s >= 0) return s;
                break;
            case 5:
                int LA34_7 = input.LA(1);


                int index34_7 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred99_AS3_ex())) { s = 51; }

                else if ((synpred101_AS3_ex())) { s = 10; }


                input.Seek(index34_7);
                if (s >= 0) return s;
                break;
            case 6:
                int LA34_8 = input.LA(1);


                int index34_8 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred99_AS3_ex())) { s = 51; }

                else if ((synpred100_AS3_ex())) { s = 52; }

                else if ((synpred101_AS3_ex())) { s = 10; }

                else if ((synpred103_AS3_ex())) { s = 53; }


                input.Seek(index34_8);
                if (s >= 0) return s;
                break;
            case 7:
                int LA34_9 = input.LA(1);


                int index34_9 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred100_AS3_ex())) { s = 52; }

                else if ((synpred101_AS3_ex())) { s = 10; }

                else if ((synpred103_AS3_ex())) { s = 53; }


                input.Seek(index34_9);
                if (s >= 0) return s;
                break;
            case 8:
                int LA34_11 = input.LA(1);


                int index34_11 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred101_AS3_ex())) { s = 10; }

                else if ((synpred102_AS3_ex())) { s = 54; }


                input.Seek(index34_11);
                if (s >= 0) return s;
                break;
            case 9:
                int LA34_12 = input.LA(1);


                int index34_12 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred101_AS3_ex())) { s = 10; }

                else if ((synpred102_AS3_ex())) { s = 54; }


                input.Seek(index34_12);
                if (s >= 0) return s;
                break;
            case 10:
                int LA34_13 = input.LA(1);


                int index34_13 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred101_AS3_ex())) { s = 10; }

                else if ((synpred102_AS3_ex())) { s = 54; }


                input.Seek(index34_13);
                if (s >= 0) return s;
                break;
            case 11:
                int LA34_14 = input.LA(1);


                int index34_14 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred101_AS3_ex())) { s = 10; }

                else if ((synpred102_AS3_ex())) { s = 54; }


                input.Seek(index34_14);
                if (s >= 0) return s;
                break;
            case 12:
                int LA34_15 = input.LA(1);


                int index34_15 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred101_AS3_ex())) { s = 10; }

                else if ((synpred102_AS3_ex())) { s = 54; }


                input.Seek(index34_15);
                if (s >= 0) return s;
                break;
        }
        if (state.backtracking > 0) { state.failed = true; return -1; }
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 34, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA36_eotS =
        "\x39\uffff";
    const string DFA36_eofS =
        "\x39\uffff";
    const string DFA36_minS =
        "\x01\x04\x0a\x00\x01\uffff\x05\x00\x28\uffff";
    const string DFA36_maxS =
        "\x01\u0092\x0a\x00\x01\uffff\x05\x00\x28\uffff";
    const string DFA36_acceptS =
        "\x0b\uffff\x01\x05\x28\uffff\x01\x01\x01\x02\x01\x03\x01\x04\x01" +
        "\x06";
    const string DFA36_specialS =
        "\x01\uffff\x01\x00\x01\x01\x01\x02\x01\x03\x01\x04\x01\x05\x01" +
        "\x06\x01\x07\x01\x08\x01\x09\x01\uffff\x01\x0a\x01\x0b\x01\x0c\x01" +
        "\x0d\x01\x0e\x28\uffff}>";
    static readonly string[] DFA36_transitionS = {
            "\x04\x0b\x01\x06\x01\x08\x01\x0b\x01\x10\x07\x0b\x01\x0a\x02"+
            "\x0b\x01\x0f\x02\x0b\x01\x05\x01\x04\x01\x0b\x01\x02\x03\x0b"+
            "\x03\x04\x05\x0b\x01\x09\x03\x0b\x01\x0e\x01\x07\x03\x0b\x03"+
            "\x09\x01\x03\x01\x0d\x04\x02\x02\x0b\x01\uffff\x01\x0b\x01\uffff"+
            "\x01\x0c\x03\uffff\x01\x0b\x07\uffff\x03\x0b\x02\uffff\x02\x0b"+
            "\x06\uffff\x02\x0b\x18\uffff\x02\x0b\x0c\uffff\x02\x0b\x02\uffff"+
            "\x01\x0b\x04\uffff\x01\x0b\x02\uffff\x01\x0b\x01\uffff\x01\x01"+
            "\x01\uffff\x03\x0b",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA36_eot = DFA.UnpackEncodedString(DFA36_eotS);
    static readonly short[] DFA36_eof = DFA.UnpackEncodedString(DFA36_eofS);
    static readonly char[] DFA36_min = DFA.UnpackEncodedStringToUnsignedChars(DFA36_minS);
    static readonly char[] DFA36_max = DFA.UnpackEncodedStringToUnsignedChars(DFA36_maxS);
    static readonly short[] DFA36_accept = DFA.UnpackEncodedString(DFA36_acceptS);
    static readonly short[] DFA36_special = DFA.UnpackEncodedString(DFA36_specialS);
    static readonly short[][] DFA36_transition = DFA.UnpackEncodedStringArray(DFA36_transitionS);

    protected class DFA36 : DFA
    {
        public DFA36(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 36;
            this.eot = DFA36_eot;
            this.eof = DFA36_eof;
            this.min = DFA36_min;
            this.max = DFA36_max;
            this.accept = DFA36_accept;
            this.special = DFA36_special;
            this.transition = DFA36_transition;

        }

        override public string Description
        {
            get { return "1527:1: packageElement : ( classOrInterfaceDecl | propertyDeclaration | functionDeclaration | interfaceFunctionDeclaration | statement | directive );"; }
        }

    }


    protected internal int DFA36_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
        ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch (s)
        {
            case 0:
                int LA36_1 = input.LA(1);


                int index36_1 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred105_AS3_ex())) { s = 52; }

                else if ((synpred106_AS3_ex())) { s = 53; }

                else if ((synpred107_AS3_ex())) { s = 54; }

                else if ((synpred108_AS3_ex())) { s = 55; }

                else if ((synpred109_AS3_ex())) { s = 11; }


                input.Seek(index36_1);
                if (s >= 0) return s;
                break;
            case 1:
                int LA36_2 = input.LA(1);


                int index36_2 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred105_AS3_ex())) { s = 52; }

                else if ((synpred106_AS3_ex())) { s = 53; }

                else if ((synpred107_AS3_ex())) { s = 54; }

                else if ((synpred108_AS3_ex())) { s = 55; }

                else if ((synpred109_AS3_ex())) { s = 11; }


                input.Seek(index36_2);
                if (s >= 0) return s;
                break;
            case 2:
                int LA36_3 = input.LA(1);


                int index36_3 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred105_AS3_ex())) { s = 52; }

                else if ((synpred106_AS3_ex())) { s = 53; }

                else if ((synpred107_AS3_ex())) { s = 54; }

                else if ((synpred108_AS3_ex())) { s = 55; }

                else if ((synpred109_AS3_ex())) { s = 11; }


                input.Seek(index36_3);
                if (s >= 0) return s;
                break;
            case 3:
                int LA36_4 = input.LA(1);


                int index36_4 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred105_AS3_ex())) { s = 52; }

                else if ((synpred106_AS3_ex())) { s = 53; }

                else if ((synpred107_AS3_ex())) { s = 54; }

                else if ((synpred108_AS3_ex())) { s = 55; }

                else if ((synpred109_AS3_ex())) { s = 11; }


                input.Seek(index36_4);
                if (s >= 0) return s;
                break;
            case 4:
                int LA36_5 = input.LA(1);


                int index36_5 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred105_AS3_ex())) { s = 52; }

                else if ((synpred109_AS3_ex())) { s = 11; }


                input.Seek(index36_5);
                if (s >= 0) return s;
                break;
            case 5:
                int LA36_6 = input.LA(1);


                int index36_6 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred105_AS3_ex())) { s = 52; }

                else if ((synpred109_AS3_ex())) { s = 11; }


                input.Seek(index36_6);
                if (s >= 0) return s;
                break;
            case 6:
                int LA36_7 = input.LA(1);


                int index36_7 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred106_AS3_ex())) { s = 53; }

                else if ((synpred109_AS3_ex())) { s = 11; }


                input.Seek(index36_7);
                if (s >= 0) return s;
                break;
            case 7:
                int LA36_8 = input.LA(1);


                int index36_8 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred106_AS3_ex())) { s = 53; }

                else if ((synpred109_AS3_ex())) { s = 11; }


                input.Seek(index36_8);
                if (s >= 0) return s;
                break;
            case 8:
                int LA36_9 = input.LA(1);


                int index36_9 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred105_AS3_ex())) { s = 52; }

                else if ((synpred106_AS3_ex())) { s = 53; }

                else if ((synpred107_AS3_ex())) { s = 54; }

                else if ((synpred108_AS3_ex())) { s = 55; }

                else if ((synpred109_AS3_ex())) { s = 11; }


                input.Seek(index36_9);
                if (s >= 0) return s;
                break;
            case 9:
                int LA36_10 = input.LA(1);


                int index36_10 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred107_AS3_ex())) { s = 54; }

                else if ((synpred108_AS3_ex())) { s = 55; }

                else if ((synpred109_AS3_ex())) { s = 11; }


                input.Seek(index36_10);
                if (s >= 0) return s;
                break;
            case 10:
                int LA36_12 = input.LA(1);


                int index36_12 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred109_AS3_ex())) { s = 11; }

                else if ((true)) { s = 56; }


                input.Seek(index36_12);
                if (s >= 0) return s;
                break;
            case 11:
                int LA36_13 = input.LA(1);


                int index36_13 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred109_AS3_ex())) { s = 11; }

                else if ((true)) { s = 56; }


                input.Seek(index36_13);
                if (s >= 0) return s;
                break;
            case 12:
                int LA36_14 = input.LA(1);


                int index36_14 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred109_AS3_ex())) { s = 11; }

                else if ((true)) { s = 56; }


                input.Seek(index36_14);
                if (s >= 0) return s;
                break;
            case 13:
                int LA36_15 = input.LA(1);


                int index36_15 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred109_AS3_ex())) { s = 11; }

                else if ((true)) { s = 56; }


                input.Seek(index36_15);
                if (s >= 0) return s;
                break;
            case 14:
                int LA36_16 = input.LA(1);


                int index36_16 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred109_AS3_ex())) { s = 11; }

                else if ((true)) { s = 56; }


                input.Seek(index36_16);
                if (s >= 0) return s;
                break;
        }
        if (state.backtracking > 0) { state.failed = true; return -1; }
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 36, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA54_eotS =
        "\x35\uffff";
    const string DFA54_eofS =
        "\x35\uffff";
    const string DFA54_minS =
        "\x01\x04\x08\x00\x01\uffff\x05\x00\x26\uffff";
    const string DFA54_maxS =
        "\x01\u0092\x08\x00\x01\uffff\x05\x00\x26\uffff";
    const string DFA54_acceptS =
        "\x09\uffff\x01\x03\x28\uffff\x01\x01\x01\x02\x01\x04";
    const string DFA54_specialS =
        "\x01\uffff\x01\x00\x01\x01\x01\x02\x01\x03\x01\x04\x01\x05\x01" +
        "\x06\x01\x07\x01\uffff\x01\x08\x01\x09\x01\x0a\x01\x0b\x01\x0c\x26" +
        "\uffff}>";
    static readonly string[] DFA54_transitionS = {
            "\x05\x09\x01\x06\x01\x09\x01\x0e\x07\x09\x01\x08\x02\x09\x01"+
            "\x0d\x03\x09\x01\x04\x01\x09\x01\x02\x03\x09\x03\x04\x05\x09"+
            "\x01\x07\x03\x09\x01\x0c\x01\x05\x03\x09\x03\x07\x01\x03\x01"+
            "\x0b\x04\x02\x02\x09\x01\uffff\x01\x09\x01\uffff\x01\x0a\x03"+
            "\uffff\x01\x09\x07\uffff\x03\x09\x02\uffff\x02\x09\x06\uffff"+
            "\x02\x09\x18\uffff\x02\x09\x0c\uffff\x02\x09\x02\uffff\x01\x09"+
            "\x04\uffff\x01\x09\x02\uffff\x01\x09\x01\uffff\x01\x01\x01\uffff"+
            "\x03\x09",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA54_eot = DFA.UnpackEncodedString(DFA54_eotS);
    static readonly short[] DFA54_eof = DFA.UnpackEncodedString(DFA54_eofS);
    static readonly char[] DFA54_min = DFA.UnpackEncodedStringToUnsignedChars(DFA54_minS);
    static readonly char[] DFA54_max = DFA.UnpackEncodedStringToUnsignedChars(DFA54_maxS);
    static readonly short[] DFA54_accept = DFA.UnpackEncodedString(DFA54_acceptS);
    static readonly short[] DFA54_special = DFA.UnpackEncodedString(DFA54_specialS);
    static readonly short[][] DFA54_transition = DFA.UnpackEncodedStringArray(DFA54_transitionS);

    protected class DFA54 : DFA
    {
        public DFA54(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 54;
            this.eot = DFA54_eot;
            this.eof = DFA54_eof;
            this.min = DFA54_min;
            this.max = DFA54_max;
            this.accept = DFA54_accept;
            this.special = DFA54_special;
            this.transition = DFA54_transition;

        }

        override public string Description
        {
            get { return "1650:1: classBodyElement : ( propertyDeclaration | functionDeclaration | statement | directive );"; }
        }

    }


    protected internal int DFA54_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
        ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch (s)
        {
            case 0:
                int LA54_1 = input.LA(1);


                int index54_1 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred131_AS3_ex())) { s = 50; }

                else if ((synpred132_AS3_ex())) { s = 51; }

                else if ((synpred133_AS3_ex())) { s = 9; }


                input.Seek(index54_1);
                if (s >= 0) return s;
                break;
            case 1:
                int LA54_2 = input.LA(1);


                int index54_2 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred131_AS3_ex())) { s = 50; }

                else if ((synpred132_AS3_ex())) { s = 51; }

                else if ((synpred133_AS3_ex())) { s = 9; }


                input.Seek(index54_2);
                if (s >= 0) return s;
                break;
            case 2:
                int LA54_3 = input.LA(1);


                int index54_3 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred131_AS3_ex())) { s = 50; }

                else if ((synpred132_AS3_ex())) { s = 51; }

                else if ((synpred133_AS3_ex())) { s = 9; }


                input.Seek(index54_3);
                if (s >= 0) return s;
                break;
            case 3:
                int LA54_4 = input.LA(1);


                int index54_4 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred131_AS3_ex())) { s = 50; }

                else if ((synpred132_AS3_ex())) { s = 51; }

                else if ((synpred133_AS3_ex())) { s = 9; }


                input.Seek(index54_4);
                if (s >= 0) return s;
                break;
            case 4:
                int LA54_5 = input.LA(1);


                int index54_5 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred131_AS3_ex())) { s = 50; }

                else if ((synpred133_AS3_ex())) { s = 9; }


                input.Seek(index54_5);
                if (s >= 0) return s;
                break;
            case 5:
                int LA54_6 = input.LA(1);


                int index54_6 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred131_AS3_ex())) { s = 50; }

                else if ((synpred133_AS3_ex())) { s = 9; }


                input.Seek(index54_6);
                if (s >= 0) return s;
                break;
            case 6:
                int LA54_7 = input.LA(1);


                int index54_7 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred131_AS3_ex())) { s = 50; }

                else if ((synpred132_AS3_ex())) { s = 51; }

                else if ((synpred133_AS3_ex())) { s = 9; }


                input.Seek(index54_7);
                if (s >= 0) return s;
                break;
            case 7:
                int LA54_8 = input.LA(1);


                int index54_8 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred132_AS3_ex())) { s = 51; }

                else if ((synpred133_AS3_ex())) { s = 9; }


                input.Seek(index54_8);
                if (s >= 0) return s;
                break;
            case 8:
                int LA54_10 = input.LA(1);


                int index54_10 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred133_AS3_ex())) { s = 9; }

                else if ((true)) { s = 52; }


                input.Seek(index54_10);
                if (s >= 0) return s;
                break;
            case 9:
                int LA54_11 = input.LA(1);


                int index54_11 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred133_AS3_ex())) { s = 9; }

                else if ((true)) { s = 52; }


                input.Seek(index54_11);
                if (s >= 0) return s;
                break;
            case 10:
                int LA54_12 = input.LA(1);


                int index54_12 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred133_AS3_ex())) { s = 9; }

                else if ((true)) { s = 52; }


                input.Seek(index54_12);
                if (s >= 0) return s;
                break;
            case 11:
                int LA54_13 = input.LA(1);


                int index54_13 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred133_AS3_ex())) { s = 9; }

                else if ((true)) { s = 52; }


                input.Seek(index54_13);
                if (s >= 0) return s;
                break;
            case 12:
                int LA54_14 = input.LA(1);


                int index54_14 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred133_AS3_ex())) { s = 9; }

                else if ((true)) { s = 52; }


                input.Seek(index54_14);
                if (s >= 0) return s;
                break;
        }
        if (state.backtracking > 0) { state.failed = true; return -1; }
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 54, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA55_eotS =
        "\x35\uffff";
    const string DFA55_eofS =
        "\x35\uffff";
    const string DFA55_minS =
        "\x01\x04\x08\x00\x01\uffff\x05\x00\x26\uffff";
    const string DFA55_maxS =
        "\x01\u0092\x08\x00\x01\uffff\x05\x00\x26\uffff";
    const string DFA55_acceptS =
        "\x09\uffff\x01\x03\x28\uffff\x01\x01\x01\x02\x01\x04";
    const string DFA55_specialS =
        "\x01\uffff\x01\x00\x01\x01\x01\x02\x01\x03\x01\x04\x01\x05\x01" +
        "\x06\x01\x07\x01\uffff\x01\x08\x01\x09\x01\x0a\x01\x0b\x01\x0c\x26" +
        "\uffff}>";
    static readonly string[] DFA55_transitionS = {
            "\x05\x09\x01\x06\x01\x09\x01\x0e\x07\x09\x01\x08\x02\x09\x01"+
            "\x0d\x03\x09\x01\x04\x01\x09\x01\x02\x03\x09\x03\x04\x05\x09"+
            "\x01\x07\x03\x09\x01\x0c\x01\x05\x03\x09\x03\x07\x01\x03\x01"+
            "\x0b\x04\x02\x02\x09\x01\uffff\x01\x09\x01\uffff\x01\x0a\x03"+
            "\uffff\x01\x09\x07\uffff\x03\x09\x02\uffff\x02\x09\x06\uffff"+
            "\x02\x09\x18\uffff\x02\x09\x0c\uffff\x02\x09\x02\uffff\x01\x09"+
            "\x04\uffff\x01\x09\x02\uffff\x01\x09\x01\uffff\x01\x01\x01\uffff"+
            "\x03\x09",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA55_eot = DFA.UnpackEncodedString(DFA55_eotS);
    static readonly short[] DFA55_eof = DFA.UnpackEncodedString(DFA55_eofS);
    static readonly char[] DFA55_min = DFA.UnpackEncodedStringToUnsignedChars(DFA55_minS);
    static readonly char[] DFA55_max = DFA.UnpackEncodedStringToUnsignedChars(DFA55_maxS);
    static readonly short[] DFA55_accept = DFA.UnpackEncodedString(DFA55_acceptS);
    static readonly short[] DFA55_special = DFA.UnpackEncodedString(DFA55_specialS);
    static readonly short[][] DFA55_transition = DFA.UnpackEncodedStringArray(DFA55_transitionS);

    protected class DFA55 : DFA
    {
        public DFA55(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 55;
            this.eot = DFA55_eot;
            this.eof = DFA55_eof;
            this.min = DFA55_min;
            this.max = DFA55_max;
            this.accept = DFA55_accept;
            this.special = DFA55_special;
            this.transition = DFA55_transition;

        }

        override public string Description
        {
            get { return "1654:1: interfaceElement : ( propertyDeclaration | interfaceFunctionDeclaration | statement | directive );"; }
        }

    }


    protected internal int DFA55_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
        ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch (s)
        {
            case 0:
                int LA55_1 = input.LA(1);


                int index55_1 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred134_AS3_ex())) { s = 50; }

                else if ((synpred135_AS3_ex())) { s = 51; }

                else if ((synpred136_AS3_ex())) { s = 9; }


                input.Seek(index55_1);
                if (s >= 0) return s;
                break;
            case 1:
                int LA55_2 = input.LA(1);


                int index55_2 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred134_AS3_ex())) { s = 50; }

                else if ((synpred135_AS3_ex())) { s = 51; }

                else if ((synpred136_AS3_ex())) { s = 9; }


                input.Seek(index55_2);
                if (s >= 0) return s;
                break;
            case 2:
                int LA55_3 = input.LA(1);


                int index55_3 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred134_AS3_ex())) { s = 50; }

                else if ((synpred135_AS3_ex())) { s = 51; }

                else if ((synpred136_AS3_ex())) { s = 9; }


                input.Seek(index55_3);
                if (s >= 0) return s;
                break;
            case 3:
                int LA55_4 = input.LA(1);


                int index55_4 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred134_AS3_ex())) { s = 50; }

                else if ((synpred135_AS3_ex())) { s = 51; }

                else if ((synpred136_AS3_ex())) { s = 9; }


                input.Seek(index55_4);
                if (s >= 0) return s;
                break;
            case 4:
                int LA55_5 = input.LA(1);


                int index55_5 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred134_AS3_ex())) { s = 50; }

                else if ((synpred136_AS3_ex())) { s = 9; }


                input.Seek(index55_5);
                if (s >= 0) return s;
                break;
            case 5:
                int LA55_6 = input.LA(1);


                int index55_6 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred134_AS3_ex())) { s = 50; }

                else if ((synpred136_AS3_ex())) { s = 9; }


                input.Seek(index55_6);
                if (s >= 0) return s;
                break;
            case 6:
                int LA55_7 = input.LA(1);


                int index55_7 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred134_AS3_ex())) { s = 50; }

                else if ((synpred135_AS3_ex())) { s = 51; }

                else if ((synpred136_AS3_ex())) { s = 9; }


                input.Seek(index55_7);
                if (s >= 0) return s;
                break;
            case 7:
                int LA55_8 = input.LA(1);


                int index55_8 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred135_AS3_ex())) { s = 51; }

                else if ((synpred136_AS3_ex())) { s = 9; }


                input.Seek(index55_8);
                if (s >= 0) return s;
                break;
            case 8:
                int LA55_10 = input.LA(1);


                int index55_10 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred136_AS3_ex())) { s = 9; }

                else if ((true)) { s = 52; }


                input.Seek(index55_10);
                if (s >= 0) return s;
                break;
            case 9:
                int LA55_11 = input.LA(1);


                int index55_11 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred136_AS3_ex())) { s = 9; }

                else if ((true)) { s = 52; }


                input.Seek(index55_11);
                if (s >= 0) return s;
                break;
            case 10:
                int LA55_12 = input.LA(1);


                int index55_12 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred136_AS3_ex())) { s = 9; }

                else if ((true)) { s = 52; }


                input.Seek(index55_12);
                if (s >= 0) return s;
                break;
            case 11:
                int LA55_13 = input.LA(1);


                int index55_13 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred136_AS3_ex())) { s = 9; }

                else if ((true)) { s = 52; }


                input.Seek(index55_13);
                if (s >= 0) return s;
                break;
            case 12:
                int LA55_14 = input.LA(1);


                int index55_14 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred136_AS3_ex())) { s = 9; }

                else if ((true)) { s = 52; }


                input.Seek(index55_14);
                if (s >= 0) return s;
                break;
        }
        if (state.backtracking > 0) { state.failed = true; return -1; }
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 55, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA74_eotS =
        "\x34\uffff";
    const string DFA74_eofS =
        "\x34\uffff";
    const string DFA74_minS =
        "\x01\x04\x01\uffff\x02\x00\x06\uffff\x01\x00\x0b\uffff\x01\x00" +
        "\x19\uffff\x02\x00\x02\uffff";
    const string DFA74_maxS =
        "\x01\u0092\x01\uffff\x02\x00\x06\uffff\x01\x00\x0b\uffff\x01\x00" +
        "\x19\uffff\x02\x00\x02\uffff";
    const string DFA74_acceptS =
        "\x01\uffff\x01\x03\x02\uffff\x01\x01\x2e\uffff\x01\x02";
    const string DFA74_specialS =
        "\x02\uffff\x01\x00\x01\x01\x06\uffff\x01\x02\x0b\uffff\x01\x03" +
        "\x19\uffff\x01\x04\x01\x05\x02\uffff}>";
    static readonly string[] DFA74_transitionS = {
            "\x0f\x04\x01\x16\x06\x04\x01\x30\x01\x04\x01\x0a\x03\x04\x03"+
            "\x30\x05\x04\x01\x31\x08\x04\x03\x31\x01\x03\x01\x04\x04\x0a"+
            "\x02\x04\x01\x01\x01\x04\x01\uffff\x01\x04\x03\uffff\x01\x04"+
            "\x07\uffff\x03\x04\x02\uffff\x02\x04\x06\uffff\x02\x04\x18\uffff"+
            "\x02\x04\x0c\uffff\x02\x04\x02\uffff\x01\x04\x04\uffff\x01\x04"+
            "\x02\uffff\x01\x04\x01\uffff\x01\x02\x01\uffff\x03\x04",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "",
            ""
    };

    static readonly short[] DFA74_eot = DFA.UnpackEncodedString(DFA74_eotS);
    static readonly short[] DFA74_eof = DFA.UnpackEncodedString(DFA74_eofS);
    static readonly char[] DFA74_min = DFA.UnpackEncodedStringToUnsignedChars(DFA74_minS);
    static readonly char[] DFA74_max = DFA.UnpackEncodedStringToUnsignedChars(DFA74_maxS);
    static readonly short[] DFA74_accept = DFA.UnpackEncodedString(DFA74_acceptS);
    static readonly short[] DFA74_special = DFA.UnpackEncodedString(DFA74_specialS);
    static readonly short[][] DFA74_transition = DFA.UnpackEncodedStringArray(DFA74_transitionS);

    protected class DFA74 : DFA
    {
        public DFA74(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 74;
            this.eot = DFA74_eot;
            this.eof = DFA74_eof;
            this.min = DFA74_min;
            this.max = DFA74_max;
            this.accept = DFA74_accept;
            this.special = DFA74_special;
            this.transition = DFA74_transition;

        }

        override public string Description
        {
            get { return "()* loopback of 1740:7: ( statement | functionDeclaration )*"; }
        }

    }


    protected internal int DFA74_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
        ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch (s)
        {
            case 0:
                int LA74_2 = input.LA(1);


                int index74_2 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred159_AS3_ex())) { s = 4; }

                else if ((synpred160_AS3_ex())) { s = 51; }


                input.Seek(index74_2);
                if (s >= 0) return s;
                break;
            case 1:
                int LA74_3 = input.LA(1);


                int index74_3 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred159_AS3_ex())) { s = 4; }

                else if ((synpred160_AS3_ex())) { s = 51; }


                input.Seek(index74_3);
                if (s >= 0) return s;
                break;
            case 2:
                int LA74_10 = input.LA(1);


                int index74_10 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred159_AS3_ex())) { s = 4; }

                else if ((synpred160_AS3_ex())) { s = 51; }


                input.Seek(index74_10);
                if (s >= 0) return s;
                break;
            case 3:
                int LA74_22 = input.LA(1);


                int index74_22 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred159_AS3_ex())) { s = 4; }

                else if ((synpred160_AS3_ex())) { s = 51; }


                input.Seek(index74_22);
                if (s >= 0) return s;
                break;
            case 4:
                int LA74_48 = input.LA(1);


                int index74_48 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred159_AS3_ex())) { s = 4; }

                else if ((synpred160_AS3_ex())) { s = 51; }


                input.Seek(index74_48);
                if (s >= 0) return s;
                break;
            case 5:
                int LA74_49 = input.LA(1);


                int index74_49 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred159_AS3_ex())) { s = 4; }

                else if ((synpred160_AS3_ex())) { s = 51; }


                input.Seek(index74_49);
                if (s >= 0) return s;
                break;
        }
        if (state.backtracking > 0) { state.failed = true; return -1; }
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 74, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA76_eotS =
        "\x43\uffff";
    const string DFA76_eofS =
        "\x43\uffff";
    const string DFA76_minS =
        "\x01\x04\x09\x00\x16\uffff\x01\x00\x01\uffff\x0b\x00\x01\uffff" +
        "\x01\x00\x14\uffff";
    const string DFA76_maxS =
        "\x01\u0092\x09\x00\x16\uffff\x01\x00\x01\uffff\x0b\x00\x01\uffff" +
        "\x01\x00\x14\uffff";
    const string DFA76_acceptS =
        "\x0a\uffff\x01\x04\x22\uffff\x01\x13\x02\uffff\x01\x01\x01\x07" +
        "\x01\x14\x01\x03\x01\x02\x01\x05\x01\x06\x01\x08\x01\x09\x01\x0a" +
        "\x01\x0b\x01\x0c\x01\x0d\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12" +
        "\x01\x15";
    const string DFA76_specialS =
        "\x01\uffff\x01\x00\x01\x01\x01\x02\x01\x03\x01\x04\x01\x05\x01" +
        "\x06\x01\x07\x01\x08\x16\uffff\x01\x09\x01\uffff\x01\x0a\x01\x0b" +
        "\x01\x0c\x01\x0d\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13" +
        "\x01\x14\x01\uffff\x01\x15\x14\uffff}>";
    static readonly string[] DFA76_transitionS = {
            "\x01\x0a\x01\x26\x03\x0a\x01\x20\x01\x27\x01\x08\x01\x0a\x01"+
            "\x29\x04\x0a\x01\x28\x01\x0a\x01\x2b\x01\x0a\x01\x07\x05\x0a"+
            "\x01\x09\x06\x0a\x01\x25\x01\x0a\x01\x23\x01\x0a\x01\x2e\x01"+
            "\x09\x01\x0a\x01\x22\x01\x0a\x01\x06\x01\x2c\x01\x0a\x01\x2a"+
            "\x01\x24\x03\x09\x01\x02\x01\x05\x04\x09\x01\x2d\x01\x03\x01"+
            "\uffff\x01\x0a\x01\uffff\x01\x04\x03\uffff\x01\x0a\x07\uffff"+
            "\x03\x0a\x02\uffff\x02\x0a\x06\uffff\x02\x0a\x18\uffff\x02\x0a"+
            "\x0c\uffff\x02\x0a\x02\uffff\x01\x0a\x04\uffff\x01\x0a\x02\uffff"+
            "\x01\x0a\x01\uffff\x01\x01\x01\uffff\x03\x0a",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA76_eot = DFA.UnpackEncodedString(DFA76_eotS);
    static readonly short[] DFA76_eof = DFA.UnpackEncodedString(DFA76_eofS);
    static readonly char[] DFA76_min = DFA.UnpackEncodedStringToUnsignedChars(DFA76_minS);
    static readonly char[] DFA76_max = DFA.UnpackEncodedStringToUnsignedChars(DFA76_maxS);
    static readonly short[] DFA76_accept = DFA.UnpackEncodedString(DFA76_acceptS);
    static readonly short[] DFA76_special = DFA.UnpackEncodedString(DFA76_specialS);
    static readonly short[][] DFA76_transition = DFA.UnpackEncodedStringArray(DFA76_transitionS);

    protected class DFA76 : DFA
    {
        public DFA76(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 76;
            this.eot = DFA76_eot;
            this.eof = DFA76_eof;
            this.min = DFA76_min;
            this.max = DFA76_max;
            this.accept = DFA76_accept;
            this.special = DFA76_special;
            this.transition = DFA76_transition;

        }

        override public string Description
        {
            get { return "1778:1: statement : ( blockStatement | directive | namespaceDirective | expression semic | constantVarStatement | tryStatement | labelledStatement | switchStatement | withStatement | returnStatement | breakStatement | continueStatement | forStatement | forInStatement | forEachInStatement | doWhileStatement | whileStatement | ifStatement | emptyStatement | variableStatement | throwStatement );"; }
        }

    }


    protected internal int DFA76_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
        ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch (s)
        {
            case 0:
                int LA76_1 = input.LA(1);


                int index76_1 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred171_AS3_ex())) { s = 48; }

                else if ((synpred174_AS3_ex())) { s = 10; }

                else if ((synpred177_AS3_ex())) { s = 49; }

                else if ((synpred190_AS3_ex())) { s = 50; }


                input.Seek(index76_1);
                if (s >= 0) return s;
                break;
            case 1:
                int LA76_2 = input.LA(1);


                int index76_2 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred171_AS3_ex())) { s = 48; }

                else if ((synpred173_AS3_ex())) { s = 51; }

                else if ((synpred174_AS3_ex())) { s = 10; }


                input.Seek(index76_2);
                if (s >= 0) return s;
                break;
            case 2:
                int LA76_3 = input.LA(1);


                int index76_3 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred171_AS3_ex())) { s = 48; }

                else if ((synpred174_AS3_ex())) { s = 10; }


                input.Seek(index76_3);
                if (s >= 0) return s;
                break;
            case 3:
                int LA76_4 = input.LA(1);


                int index76_4 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred172_AS3_ex())) { s = 52; }

                else if ((synpred174_AS3_ex())) { s = 10; }


                input.Seek(index76_4);
                if (s >= 0) return s;
                break;
            case 4:
                int LA76_5 = input.LA(1);


                int index76_5 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred172_AS3_ex())) { s = 52; }

                else if ((synpred174_AS3_ex())) { s = 10; }


                input.Seek(index76_5);
                if (s >= 0) return s;
                break;
            case 5:
                int LA76_6 = input.LA(1);


                int index76_6 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred172_AS3_ex())) { s = 52; }

                else if ((synpred174_AS3_ex())) { s = 10; }


                input.Seek(index76_6);
                if (s >= 0) return s;
                break;
            case 6:
                int LA76_7 = input.LA(1);


                int index76_7 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred172_AS3_ex())) { s = 52; }

                else if ((synpred174_AS3_ex())) { s = 10; }


                input.Seek(index76_7);
                if (s >= 0) return s;
                break;
            case 7:
                int LA76_8 = input.LA(1);


                int index76_8 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred172_AS3_ex())) { s = 52; }

                else if ((synpred174_AS3_ex())) { s = 10; }


                input.Seek(index76_8);
                if (s >= 0) return s;
                break;
            case 8:
                int LA76_9 = input.LA(1);


                int index76_9 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred171_AS3_ex())) { s = 48; }

                else if ((synpred174_AS3_ex())) { s = 10; }


                input.Seek(index76_9);
                if (s >= 0) return s;
                break;
            case 9:
                int LA76_32 = input.LA(1);


                int index76_32 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred174_AS3_ex())) { s = 10; }

                else if ((synpred175_AS3_ex())) { s = 53; }


                input.Seek(index76_32);
                if (s >= 0) return s;
                break;
            case 10:
                int LA76_34 = input.LA(1);


                int index76_34 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred174_AS3_ex())) { s = 10; }

                else if ((synpred176_AS3_ex())) { s = 54; }


                input.Seek(index76_34);
                if (s >= 0) return s;
                break;
            case 11:
                int LA76_35 = input.LA(1);


                int index76_35 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred174_AS3_ex())) { s = 10; }

                else if ((synpred178_AS3_ex())) { s = 55; }


                input.Seek(index76_35);
                if (s >= 0) return s;
                break;
            case 12:
                int LA76_36 = input.LA(1);


                int index76_36 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred174_AS3_ex())) { s = 10; }

                else if ((synpred179_AS3_ex())) { s = 56; }


                input.Seek(index76_36);
                if (s >= 0) return s;
                break;
            case 13:
                int LA76_37 = input.LA(1);


                int index76_37 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred174_AS3_ex())) { s = 10; }

                else if ((synpred180_AS3_ex())) { s = 57; }


                input.Seek(index76_37);
                if (s >= 0) return s;
                break;
            case 14:
                int LA76_38 = input.LA(1);


                int index76_38 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred174_AS3_ex())) { s = 10; }

                else if ((synpred181_AS3_ex())) { s = 58; }


                input.Seek(index76_38);
                if (s >= 0) return s;
                break;
            case 15:
                int LA76_39 = input.LA(1);


                int index76_39 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred174_AS3_ex())) { s = 10; }

                else if ((synpred182_AS3_ex())) { s = 59; }


                input.Seek(index76_39);
                if (s >= 0) return s;
                break;
            case 16:
                int LA76_40 = input.LA(1);


                int index76_40 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred174_AS3_ex())) { s = 10; }

                else if ((synpred183_AS3_ex())) { s = 60; }

                else if ((synpred184_AS3_ex())) { s = 61; }

                else if ((synpred185_AS3_ex())) { s = 62; }


                input.Seek(index76_40);
                if (s >= 0) return s;
                break;
            case 17:
                int LA76_41 = input.LA(1);


                int index76_41 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred174_AS3_ex())) { s = 10; }

                else if ((synpred186_AS3_ex())) { s = 63; }


                input.Seek(index76_41);
                if (s >= 0) return s;
                break;
            case 18:
                int LA76_42 = input.LA(1);


                int index76_42 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred174_AS3_ex())) { s = 10; }

                else if ((synpred187_AS3_ex())) { s = 64; }


                input.Seek(index76_42);
                if (s >= 0) return s;
                break;
            case 19:
                int LA76_43 = input.LA(1);


                int index76_43 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred174_AS3_ex())) { s = 10; }

                else if ((synpred188_AS3_ex())) { s = 65; }


                input.Seek(index76_43);
                if (s >= 0) return s;
                break;
            case 20:
                int LA76_44 = input.LA(1);


                int index76_44 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred174_AS3_ex())) { s = 10; }

                else if ((synpred190_AS3_ex())) { s = 50; }


                input.Seek(index76_44);
                if (s >= 0) return s;
                break;
            case 21:
                int LA76_46 = input.LA(1);


                int index76_46 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred174_AS3_ex())) { s = 10; }

                else if ((true)) { s = 66; }


                input.Seek(index76_46);
                if (s >= 0) return s;
                break;
        }
        if (state.backtracking > 0) { state.failed = true; return -1; }
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 76, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA86_eotS =
        "\x33\uffff";
    const string DFA86_eofS =
        "\x01\x02\x32\uffff";
    const string DFA86_minS =
        "\x01\x04\x01\x00\x01\uffff\x02\x00\x2e\uffff";
    const string DFA86_maxS =
        "\x01\u0092\x01\x00\x01\uffff\x02\x00\x2e\uffff";
    const string DFA86_acceptS =
        "\x02\uffff\x01\x02\x03\uffff\x01\x01\x2c\uffff";
    const string DFA86_specialS =
        "\x01\uffff\x01\x00\x01\uffff\x01\x01\x01\x02\x2e\uffff}>";
    static readonly string[] DFA86_transitionS = {
            "\x01\x06\x01\x01\x01\x03\x04\x06\x01\x04\x30\x06\x01\x02\x01"+
            "\x06\x01\uffff\x01\x06\x03\uffff\x01\x06\x07\uffff\x03\x06\x02"+
            "\uffff\x02\x06\x06\uffff\x02\x06\x18\uffff\x02\x06\x0c\uffff"+
            "\x02\x06\x02\uffff\x01\x06\x04\uffff\x01\x06\x02\uffff\x01\x06"+
            "\x01\uffff\x01\x06\x01\uffff\x03\x06",
            "\x01\uffff",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA86_eot = DFA.UnpackEncodedString(DFA86_eotS);
    static readonly short[] DFA86_eof = DFA.UnpackEncodedString(DFA86_eofS);
    static readonly char[] DFA86_min = DFA.UnpackEncodedStringToUnsignedChars(DFA86_minS);
    static readonly char[] DFA86_max = DFA.UnpackEncodedStringToUnsignedChars(DFA86_maxS);
    static readonly short[] DFA86_accept = DFA.UnpackEncodedString(DFA86_acceptS);
    static readonly short[] DFA86_special = DFA.UnpackEncodedString(DFA86_specialS);
    static readonly short[][] DFA86_transition = DFA.UnpackEncodedStringArray(DFA86_transitionS);

    protected class DFA86 : DFA
    {
        public DFA86(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 86;
            this.eot = DFA86_eot;
            this.eof = DFA86_eof;
            this.min = DFA86_min;
            this.max = DFA86_max;
            this.accept = DFA86_accept;
            this.special = DFA86_special;
            this.transition = DFA86_transition;

        }

        override public string Description
        {
            get { return "()* loopback of 1904:61: ( statement )*"; }
        }

    }


    protected internal int DFA86_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
        ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch (s)
        {
            case 0:
                int LA86_1 = input.LA(1);


                int index86_1 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred201_AS3_ex())) { s = 6; }

                else if ((true)) { s = 2; }


                input.Seek(index86_1);
                if (s >= 0) return s;
                break;
            case 1:
                int LA86_3 = input.LA(1);


                int index86_3 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred201_AS3_ex())) { s = 6; }

                else if ((true)) { s = 2; }


                input.Seek(index86_3);
                if (s >= 0) return s;
                break;
            case 2:
                int LA86_4 = input.LA(1);


                int index86_4 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred201_AS3_ex())) { s = 6; }

                else if ((true)) { s = 2; }


                input.Seek(index86_4);
                if (s >= 0) return s;
                break;
        }
        if (state.backtracking > 0) { state.failed = true; return -1; }
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 86, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA114_eotS =
        "\x1e\uffff";
    const string DFA114_eofS =
        "\x1e\uffff";
    const string DFA114_minS =
        "\x01\x04\x19\x00\x01\uffff\x01\x00\x02\uffff";
    const string DFA114_maxS =
        "\x01\u0092\x19\x00\x01\uffff\x01\x00\x02\uffff";
    const string DFA114_acceptS =
        "\x1a\uffff\x01\x02\x02\uffff\x01\x01";
    const string DFA114_specialS =
        "\x01\uffff\x01\x00\x01\x01\x01\x02\x01\x03\x01\x04\x01\x05\x01" +
        "\x06\x01\x07\x01\x08\x01\x09\x01\x0a\x01\x0b\x01\x0c\x01\x0d\x01" +
        "\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01" +
        "\x16\x01\x17\x01\x18\x01\uffff\x01\x19\x02\uffff}>";
    static readonly string[] DFA114_transitionS = {
            "\x08\x1b\x01\x19\x03\x1b\x01\x05\x02\x1b\x01\x10\x08\x1b\x01"+
            "\x0e\x01\x18\x01\x03\x05\x1b\x01\x02\x01\x1b\x01\x01\x01\x1b"+
            "\x01\x0e\x01\x04\x01\x1b\x01\x19\x02\x1b\x01\x19\x02\x1b\x04"+
            "\x0e\x01\x1b\x04\x0e\x01\uffff\x01\x0c\x01\uffff\x01\x17\x01"+
            "\uffff\x01\x0b\x03\uffff\x01\x15\x07\uffff\x02\x1a\x01\x11\x02"+
            "\uffff\x02\x1a\x06\uffff\x02\x1a\x18\uffff\x01\x0f\x01\x16\x0c"+
            "\uffff\x01\x08\x01\x09\x02\uffff\x01\x0a\x04\uffff\x01\x07\x02"+
            "\uffff\x01\x06\x01\uffff\x01\x0d\x01\uffff\x01\x12\x01\x13\x01"+
            "\x14",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "\x01\uffff",
            "",
            ""
    };

    static readonly short[] DFA114_eot = DFA.UnpackEncodedString(DFA114_eotS);
    static readonly short[] DFA114_eof = DFA.UnpackEncodedString(DFA114_eofS);
    static readonly char[] DFA114_min = DFA.UnpackEncodedStringToUnsignedChars(DFA114_minS);
    static readonly char[] DFA114_max = DFA.UnpackEncodedStringToUnsignedChars(DFA114_maxS);
    static readonly short[] DFA114_accept = DFA.UnpackEncodedString(DFA114_acceptS);
    static readonly short[] DFA114_special = DFA.UnpackEncodedString(DFA114_specialS);
    static readonly short[][] DFA114_transition = DFA.UnpackEncodedStringArray(DFA114_transitionS);

    protected class DFA114 : DFA
    {
        public DFA114(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 114;
            this.eot = DFA114_eot;
            this.eof = DFA114_eof;
            this.min = DFA114_min;
            this.max = DFA114_max;
            this.accept = DFA114_accept;
            this.special = DFA114_special;
            this.transition = DFA114_transition;

        }

        override public string Description
        {
            get { return "2191:1: assignmentExpression : ( leftHandSideExpression assignmentOperator assignmentExpression | conditionalExpression );"; }
        }

    }


    protected internal int DFA114_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
        ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch (s)
        {
            case 0:
                int LA114_1 = input.LA(1);


                int index114_1 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_1);
                if (s >= 0) return s;
                break;
            case 1:
                int LA114_2 = input.LA(1);


                int index114_2 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_2);
                if (s >= 0) return s;
                break;
            case 2:
                int LA114_3 = input.LA(1);


                int index114_3 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_3);
                if (s >= 0) return s;
                break;
            case 3:
                int LA114_4 = input.LA(1);


                int index114_4 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_4);
                if (s >= 0) return s;
                break;
            case 4:
                int LA114_5 = input.LA(1);


                int index114_5 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_5);
                if (s >= 0) return s;
                break;
            case 5:
                int LA114_6 = input.LA(1);


                int index114_6 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_6);
                if (s >= 0) return s;
                break;
            case 6:
                int LA114_7 = input.LA(1);


                int index114_7 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_7);
                if (s >= 0) return s;
                break;
            case 7:
                int LA114_8 = input.LA(1);


                int index114_8 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_8);
                if (s >= 0) return s;
                break;
            case 8:
                int LA114_9 = input.LA(1);


                int index114_9 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_9);
                if (s >= 0) return s;
                break;
            case 9:
                int LA114_10 = input.LA(1);


                int index114_10 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_10);
                if (s >= 0) return s;
                break;
            case 10:
                int LA114_11 = input.LA(1);


                int index114_11 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_11);
                if (s >= 0) return s;
                break;
            case 11:
                int LA114_12 = input.LA(1);


                int index114_12 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_12);
                if (s >= 0) return s;
                break;
            case 12:
                int LA114_13 = input.LA(1);


                int index114_13 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_13);
                if (s >= 0) return s;
                break;
            case 13:
                int LA114_14 = input.LA(1);


                int index114_14 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_14);
                if (s >= 0) return s;
                break;
            case 14:
                int LA114_15 = input.LA(1);


                int index114_15 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_15);
                if (s >= 0) return s;
                break;
            case 15:
                int LA114_16 = input.LA(1);


                int index114_16 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_16);
                if (s >= 0) return s;
                break;
            case 16:
                int LA114_17 = input.LA(1);


                int index114_17 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_17);
                if (s >= 0) return s;
                break;
            case 17:
                int LA114_18 = input.LA(1);


                int index114_18 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_18);
                if (s >= 0) return s;
                break;
            case 18:
                int LA114_19 = input.LA(1);


                int index114_19 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_19);
                if (s >= 0) return s;
                break;
            case 19:
                int LA114_20 = input.LA(1);


                int index114_20 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_20);
                if (s >= 0) return s;
                break;
            case 20:
                int LA114_21 = input.LA(1);


                int index114_21 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_21);
                if (s >= 0) return s;
                break;
            case 21:
                int LA114_22 = input.LA(1);


                int index114_22 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_22);
                if (s >= 0) return s;
                break;
            case 22:
                int LA114_23 = input.LA(1);


                int index114_23 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_23);
                if (s >= 0) return s;
                break;
            case 23:
                int LA114_24 = input.LA(1);


                int index114_24 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_24);
                if (s >= 0) return s;
                break;
            case 24:
                int LA114_25 = input.LA(1);


                int index114_25 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_25);
                if (s >= 0) return s;
                break;
            case 25:
                int LA114_27 = input.LA(1);


                int index114_27 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred230_AS3_ex())) { s = 29; }

                else if ((true)) { s = 26; }


                input.Seek(index114_27);
                if (s >= 0) return s;
                break;
        }
        if (state.backtracking > 0) { state.failed = true; return -1; }
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 114, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA115_eotS =
        "\x1e\uffff";
    const string DFA115_eofS =
        "\x1e\uffff";
    const string DFA115_minS =
        "\x01\x04\x19\x00\x01\uffff\x01\x00\x02\uffff";
    const string DFA115_maxS =
        "\x01\u0092\x19\x00\x01\uffff\x01\x00\x02\uffff";
    const string DFA115_acceptS =
        "\x1a\uffff\x01\x01\x02\uffff\x01\x02";
    const string DFA115_specialS =
        "\x01\uffff\x01\x00\x01\x01\x01\x02\x01\x03\x01\x04\x01\x05\x01" +
        "\x06\x01\x07\x01\x08\x01\x09\x01\x0a\x01\x0b\x01\x0c\x01\x0d\x01" +
        "\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01" +
        "\x16\x01\x17\x01\x18\x01\uffff\x01\x19\x02\uffff}>";
    static readonly string[] DFA115_transitionS = {
            "\x08\x1b\x01\x19\x03\x1b\x01\x05\x02\x1b\x01\x10\x08\x1b\x01"+
            "\x0e\x01\x18\x01\x03\x05\x1b\x01\x02\x01\x1b\x01\x01\x01\x1b"+
            "\x01\x0e\x01\x04\x01\x1b\x01\x19\x02\x1b\x01\x19\x02\x1b\x04"+
            "\x0e\x01\x1b\x04\x0e\x01\uffff\x01\x0c\x01\uffff\x01\x17\x01"+
            "\uffff\x01\x0b\x03\uffff\x01\x15\x07\uffff\x02\x1a\x01\x11\x02"+
            "\uffff\x02\x1a\x06\uffff\x02\x1a\x18\uffff\x01\x0f\x01\x16\x0c"+
            "\uffff\x01\x08\x01\x09\x02\uffff\x01\x0a\x04\uffff\x01\x07\x02"+
            "\uffff\x01\x06\x01\uffff\x01\x0d\x01\uffff\x01\x12\x01\x13\x01"+
            "\x14",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "\x01\uffff",
            "",
            ""
    };

    static readonly short[] DFA115_eot = DFA.UnpackEncodedString(DFA115_eotS);
    static readonly short[] DFA115_eof = DFA.UnpackEncodedString(DFA115_eofS);
    static readonly char[] DFA115_min = DFA.UnpackEncodedStringToUnsignedChars(DFA115_minS);
    static readonly char[] DFA115_max = DFA.UnpackEncodedStringToUnsignedChars(DFA115_maxS);
    static readonly short[] DFA115_accept = DFA.UnpackEncodedString(DFA115_acceptS);
    static readonly short[] DFA115_special = DFA.UnpackEncodedString(DFA115_specialS);
    static readonly short[][] DFA115_transition = DFA.UnpackEncodedStringArray(DFA115_transitionS);

    protected class DFA115 : DFA
    {
        public DFA115(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 115;
            this.eot = DFA115_eot;
            this.eof = DFA115_eof;
            this.min = DFA115_min;
            this.max = DFA115_max;
            this.accept = DFA115_accept;
            this.special = DFA115_special;
            this.transition = DFA115_transition;

        }

        override public string Description
        {
            get { return "2198:1: assignmentExpressionNoIn : ( conditionalExpressionNoIn | leftHandSideExpression assignmentOperator assignmentExpressionNoIn );"; }
        }

    }


    protected internal int DFA115_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
        ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch (s)
        {
            case 0:
                int LA115_1 = input.LA(1);


                int index115_1 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_1);
                if (s >= 0) return s;
                break;
            case 1:
                int LA115_2 = input.LA(1);


                int index115_2 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_2);
                if (s >= 0) return s;
                break;
            case 2:
                int LA115_3 = input.LA(1);


                int index115_3 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_3);
                if (s >= 0) return s;
                break;
            case 3:
                int LA115_4 = input.LA(1);


                int index115_4 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_4);
                if (s >= 0) return s;
                break;
            case 4:
                int LA115_5 = input.LA(1);


                int index115_5 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_5);
                if (s >= 0) return s;
                break;
            case 5:
                int LA115_6 = input.LA(1);


                int index115_6 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_6);
                if (s >= 0) return s;
                break;
            case 6:
                int LA115_7 = input.LA(1);


                int index115_7 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_7);
                if (s >= 0) return s;
                break;
            case 7:
                int LA115_8 = input.LA(1);


                int index115_8 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_8);
                if (s >= 0) return s;
                break;
            case 8:
                int LA115_9 = input.LA(1);


                int index115_9 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_9);
                if (s >= 0) return s;
                break;
            case 9:
                int LA115_10 = input.LA(1);


                int index115_10 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_10);
                if (s >= 0) return s;
                break;
            case 10:
                int LA115_11 = input.LA(1);


                int index115_11 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_11);
                if (s >= 0) return s;
                break;
            case 11:
                int LA115_12 = input.LA(1);


                int index115_12 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_12);
                if (s >= 0) return s;
                break;
            case 12:
                int LA115_13 = input.LA(1);


                int index115_13 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_13);
                if (s >= 0) return s;
                break;
            case 13:
                int LA115_14 = input.LA(1);


                int index115_14 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_14);
                if (s >= 0) return s;
                break;
            case 14:
                int LA115_15 = input.LA(1);


                int index115_15 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_15);
                if (s >= 0) return s;
                break;
            case 15:
                int LA115_16 = input.LA(1);


                int index115_16 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_16);
                if (s >= 0) return s;
                break;
            case 16:
                int LA115_17 = input.LA(1);


                int index115_17 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_17);
                if (s >= 0) return s;
                break;
            case 17:
                int LA115_18 = input.LA(1);


                int index115_18 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_18);
                if (s >= 0) return s;
                break;
            case 18:
                int LA115_19 = input.LA(1);


                int index115_19 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_19);
                if (s >= 0) return s;
                break;
            case 19:
                int LA115_20 = input.LA(1);


                int index115_20 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_20);
                if (s >= 0) return s;
                break;
            case 20:
                int LA115_21 = input.LA(1);


                int index115_21 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_21);
                if (s >= 0) return s;
                break;
            case 21:
                int LA115_22 = input.LA(1);


                int index115_22 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_22);
                if (s >= 0) return s;
                break;
            case 22:
                int LA115_23 = input.LA(1);


                int index115_23 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_23);
                if (s >= 0) return s;
                break;
            case 23:
                int LA115_24 = input.LA(1);


                int index115_24 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_24);
                if (s >= 0) return s;
                break;
            case 24:
                int LA115_25 = input.LA(1);


                int index115_25 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_25);
                if (s >= 0) return s;
                break;
            case 25:
                int LA115_27 = input.LA(1);


                int index115_27 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred231_AS3_ex())) { s = 26; }

                else if ((true)) { s = 29; }


                input.Seek(index115_27);
                if (s >= 0) return s;
                break;
        }
        if (state.backtracking > 0) { state.failed = true; return -1; }
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 115, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA116_eotS =
        "\x11\uffff";
    const string DFA116_eofS =
        "\x11\uffff";
    const string DFA116_minS =
        "\x01\x44\x07\uffff\x01\x44\x05\uffff\x01\x44\x02\uffff";
    const string DFA116_maxS =
        "\x01\x6c\x07\uffff\x01\x44\x05\uffff\x01\x5e\x02\uffff";
    const string DFA116_acceptS =
        "\x01\uffff\x01\x01\x01\x02\x01\x03\x01\x04\x01\x05\x01\x06\x01" +
        "\x07\x01\uffff\x01\x0a\x01\x0b\x01\x0c\x01\x0d\x01\x0e\x01\uffff" +
        "\x01\x08\x01\x09";
    const string DFA116_specialS =
        "\x11\uffff}>";
    static readonly string[] DFA116_transitionS = {
            "\x01\x08\x08\uffff\x01\x02\x10\uffff\x01\x01\x02\uffff\x01"+
            "\x03\x01\x04\x01\x05\x01\x06\x01\x07\x02\uffff\x01\x0d\x01\x0c"+
            "\x01\x09\x01\x0a\x01\x0b",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\x0e",
            "",
            "",
            "",
            "",
            "",
            "\x01\x10\x19\uffff\x01\x0f",
            "",
            ""
    };

    static readonly short[] DFA116_eot = DFA.UnpackEncodedString(DFA116_eotS);
    static readonly short[] DFA116_eof = DFA.UnpackEncodedString(DFA116_eofS);
    static readonly char[] DFA116_min = DFA.UnpackEncodedStringToUnsignedChars(DFA116_minS);
    static readonly char[] DFA116_max = DFA.UnpackEncodedStringToUnsignedChars(DFA116_maxS);
    static readonly short[] DFA116_accept = DFA.UnpackEncodedString(DFA116_acceptS);
    static readonly short[] DFA116_special = DFA.UnpackEncodedString(DFA116_specialS);
    static readonly short[][] DFA116_transition = DFA.UnpackEncodedStringArray(DFA116_transitionS);

    protected class DFA116 : DFA
    {
        public DFA116(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 116;
            this.eot = DFA116_eot;
            this.eof = DFA116_eof;
            this.min = DFA116_min;
            this.max = DFA116_max;
            this.accept = DFA116_accept;
            this.special = DFA116_special;
            this.transition = DFA116_transition;

        }

        override public string Description
        {
            get { return "2211:1: assignmentOperator_int : ( ASSIGN | s= STAR a= ASSIGN | DIV_ASSIGN | MOD_ASSIGN | ADD_ASSIGN | SUB_ASSIGN | SHL_ASSIGN | ( ( '>' '>' '=' )=>t1= '>' t2= '>' t3= '=' {...}? -> SHR_ASSIGN ) | ( ( '>' '>' '>' '=' )=>t1= '>' t2= '>' t3= '>' t4= '=' {...}? -> SHU_ASSIGN ) | AND_ASSIGN | XOR_ASSIGN | OR_ASSIGN | LOR_ASSIGN | LAND_ASSIGN );"; }
        }

    }

    const string DFA133_eotS =
        "\x47\uffff";
    const string DFA133_eofS =
        "\x01\x01\x46\uffff";
    const string DFA133_minS =
        "\x01\x04\x2a\uffff\x01\x00\x14\uffff\x01\x00\x02\uffff\x01\x00" +
        "\x03\uffff";
    const string DFA133_maxS =
        "\x01\u0092\x2a\uffff\x01\x00\x14\uffff\x01\x00\x02\uffff\x01\x00" +
        "\x03\uffff";
    const string DFA133_acceptS =
        "\x01\uffff\x01\x02\x42\uffff\x01\x01\x02\uffff";
    const string DFA133_specialS =
        "\x2b\uffff\x01\x00\x14\uffff\x01\x01\x02\uffff\x01\x02\x03\uffff}>";
    static readonly string[] DFA133_transitionS = {
            "\x01\x43\x12\x01\x01\x40\x01\x43\x02\x01\x01\x43\x25\x01\x01"+
            "\uffff\x01\x01\x01\x2b\x02\x44\x01\uffff\x07\x01\x02\uffff\x02"+
            "\x01\x03\uffff\x09\x01\x14\uffff\x02\x01\x0c\uffff\x02\x01\x02"+
            "\uffff\x01\x01\x04\uffff\x01\x01\x02\uffff\x01\x01\x01\uffff"+
            "\x01\x01\x01\uffff\x03\x01",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            ""
    };

    static readonly short[] DFA133_eot = DFA.UnpackEncodedString(DFA133_eotS);
    static readonly short[] DFA133_eof = DFA.UnpackEncodedString(DFA133_eofS);
    static readonly char[] DFA133_min = DFA.UnpackEncodedStringToUnsignedChars(DFA133_minS);
    static readonly char[] DFA133_max = DFA.UnpackEncodedStringToUnsignedChars(DFA133_maxS);
    static readonly short[] DFA133_accept = DFA.UnpackEncodedString(DFA133_acceptS);
    static readonly short[] DFA133_special = DFA.UnpackEncodedString(DFA133_specialS);
    static readonly short[][] DFA133_transition = DFA.UnpackEncodedStringArray(DFA133_transitionS);

    protected class DFA133 : DFA
    {
        public DFA133(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 133;
            this.eot = DFA133_eot;
            this.eof = DFA133_eof;
            this.min = DFA133_min;
            this.max = DFA133_max;
            this.accept = DFA133_accept;
            this.special = DFA133_special;
            this.transition = DFA133_transition;

        }

        override public string Description
        {
            get { return "()* loopback of 2307:6: ( (g= GT (assign= ASSIGN )? | eq= ( IN | LT | LTE | INSTANCEOF | IS | AS ) ) shiftExpression )*"; }
        }

    }


    protected internal int DFA133_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
        ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch (s)
        {
            case 0:
                int LA133_43 = input.LA(1);


                int index133_43 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred274_AS3_ex())) { s = 68; }

                else if ((true)) { s = 1; }


                input.Seek(index133_43);
                if (s >= 0) return s;
                break;
            case 1:
                int LA133_64 = input.LA(1);


                int index133_64 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred274_AS3_ex())) { s = 68; }

                else if ((true)) { s = 1; }


                input.Seek(index133_64);
                if (s >= 0) return s;
                break;
            case 2:
                int LA133_67 = input.LA(1);


                int index133_67 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred274_AS3_ex())) { s = 68; }

                else if ((true)) { s = 1; }


                input.Seek(index133_67);
                if (s >= 0) return s;
                break;
        }
        if (state.backtracking > 0) { state.failed = true; return -1; }
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 133, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA139_eotS =
        "\x4a\uffff";
    const string DFA139_eofS =
        "\x01\x01\x49\uffff";
    const string DFA139_minS =
        "\x01\x04\x34\uffff\x01\x00\x14\uffff";
    const string DFA139_maxS =
        "\x01\u0092\x34\uffff\x01\x00\x14\uffff";
    const string DFA139_acceptS =
        "\x01\uffff\x01\x02\x47\uffff\x01\x01";
    const string DFA139_specialS =
        "\x35\uffff\x01\x00\x14\uffff}>";
    static readonly string[] DFA139_transitionS = {
            "\x3d\x01\x01\uffff\x04\x01\x01\uffff\x04\x01\x02\x35\x01\x01"+
            "\x02\uffff\x03\x01\x02\uffff\x09\x01\x14\uffff\x02\x01\x0c\uffff"+
            "\x02\x01\x02\uffff\x01\x01\x04\uffff\x01\x01\x02\uffff\x01\x01"+
            "\x01\uffff\x01\x01\x01\uffff\x03\x01",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA139_eot = DFA.UnpackEncodedString(DFA139_eotS);
    static readonly short[] DFA139_eof = DFA.UnpackEncodedString(DFA139_eofS);
    static readonly char[] DFA139_min = DFA.UnpackEncodedStringToUnsignedChars(DFA139_minS);
    static readonly char[] DFA139_max = DFA.UnpackEncodedStringToUnsignedChars(DFA139_maxS);
    static readonly short[] DFA139_accept = DFA.UnpackEncodedString(DFA139_acceptS);
    static readonly short[] DFA139_special = DFA.UnpackEncodedString(DFA139_specialS);
    static readonly short[][] DFA139_transition = DFA.UnpackEncodedStringArray(DFA139_transitionS);

    protected class DFA139 : DFA
    {
        public DFA139(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 139;
            this.eot = DFA139_eot;
            this.eof = DFA139_eof;
            this.min = DFA139_min;
            this.max = DFA139_max;
            this.accept = DFA139_accept;
            this.special = DFA139_special;
            this.transition = DFA139_transition;

        }

        override public string Description
        {
            get { return "()* loopback of 2361:34: (op= ( PLUS | SUB ) multiplicativeExpression )*"; }
        }

    }


    protected internal int DFA139_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
        ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch (s)
        {
            case 0:
                int LA139_53 = input.LA(1);


                int index139_53 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred288_AS3_ex())) { s = 73; }

                else if ((true)) { s = 1; }


                input.Seek(index139_53);
                if (s >= 0) return s;
                break;
        }
        if (state.backtracking > 0) { state.failed = true; return -1; }
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 139, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA140_eotS =
        "\x4a\uffff";
    const string DFA140_eofS =
        "\x01\x01\x49\uffff";
    const string DFA140_minS =
        "\x01\x04\x2b\uffff\x01\x00\x1d\uffff";
    const string DFA140_maxS =
        "\x01\u0092\x2b\uffff\x01\x00\x1d\uffff";
    const string DFA140_acceptS =
        "\x01\uffff\x01\x02\x47\uffff\x01\x01";
    const string DFA140_specialS =
        "\x2c\uffff\x01\x00\x1d\uffff}>";
    static readonly string[] DFA140_transitionS = {
            "\x3d\x01\x01\uffff\x04\x01\x01\uffff\x06\x01\x01\x2c\x02\x49"+
            "\x03\x01\x02\uffff\x09\x01\x14\uffff\x02\x01\x0c\uffff\x02\x01"+
            "\x02\uffff\x01\x01\x04\uffff\x01\x01\x02\uffff\x01\x01\x01\uffff"+
            "\x01\x01\x01\uffff\x03\x01",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA140_eot = DFA.UnpackEncodedString(DFA140_eotS);
    static readonly short[] DFA140_eof = DFA.UnpackEncodedString(DFA140_eofS);
    static readonly char[] DFA140_min = DFA.UnpackEncodedStringToUnsignedChars(DFA140_minS);
    static readonly char[] DFA140_max = DFA.UnpackEncodedStringToUnsignedChars(DFA140_maxS);
    static readonly short[] DFA140_accept = DFA.UnpackEncodedString(DFA140_acceptS);
    static readonly short[] DFA140_special = DFA.UnpackEncodedString(DFA140_specialS);
    static readonly short[][] DFA140_transition = DFA.UnpackEncodedStringArray(DFA140_transitionS);

    protected class DFA140 : DFA
    {
        public DFA140(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 140;
            this.eot = DFA140_eot;
            this.eof = DFA140_eof;
            this.min = DFA140_min;
            this.max = DFA140_max;
            this.accept = DFA140_accept;
            this.special = DFA140_special;
            this.transition = DFA140_transition;

        }

        override public string Description
        {
            get { return "()* loopback of 2366:25: (op= ( STAR | DIV | MOD ) unaryExpression )*"; }
        }

    }


    protected internal int DFA140_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
        ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch (s)
        {
            case 0:
                int LA140_44 = input.LA(1);


                int index140_44 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred291_AS3_ex())) { s = 73; }

                else if ((true)) { s = 1; }


                input.Seek(index140_44);
                if (s >= 0) return s;
                break;
        }
        if (state.backtracking > 0) { state.failed = true; return -1; }
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 140, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA141_eotS =
        "\x1e\uffff";
    const string DFA141_eofS =
        "\x1e\uffff";
    const string DFA141_minS =
        "\x01\x04\x18\uffff\x02\x00\x03\uffff";
    const string DFA141_maxS =
        "\x01\u0092\x18\uffff\x02\x00\x03\uffff";
    const string DFA141_acceptS =
        "\x01\uffff\x01\x01\x1a\uffff\x01\x03\x01\x02";
    const string DFA141_specialS =
        "\x19\uffff\x01\x00\x01\x01\x03\uffff}>";
    static readonly string[] DFA141_transitionS = {
            "\x08\x01\x01\x19\x1e\x01\x01\x19\x02\x01\x01\x19\x0b\x01\x01"+
            "\uffff\x01\x01\x01\uffff\x01\x01\x01\uffff\x01\x01\x03\uffff"+
            "\x01\x01\x07\uffff\x02\x1c\x01\x01\x02\uffff\x02\x1c\x06\uffff"+
            "\x02\x1a\x18\uffff\x02\x01\x0c\uffff\x02\x01\x02\uffff\x01\x01"+
            "\x04\uffff\x01\x01\x02\uffff\x01\x01\x01\uffff\x01\x01\x01\uffff"+
            "\x03\x01",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            ""
    };

    static readonly short[] DFA141_eot = DFA.UnpackEncodedString(DFA141_eotS);
    static readonly short[] DFA141_eof = DFA.UnpackEncodedString(DFA141_eofS);
    static readonly char[] DFA141_min = DFA.UnpackEncodedStringToUnsignedChars(DFA141_minS);
    static readonly char[] DFA141_max = DFA.UnpackEncodedStringToUnsignedChars(DFA141_maxS);
    static readonly short[] DFA141_accept = DFA.UnpackEncodedString(DFA141_acceptS);
    static readonly short[] DFA141_special = DFA.UnpackEncodedString(DFA141_specialS);
    static readonly short[][] DFA141_transition = DFA.UnpackEncodedStringArray(DFA141_transitionS);

    protected class DFA141 : DFA
    {
        public DFA141(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 141;
            this.eot = DFA141_eot;
            this.eof = DFA141_eof;
            this.min = DFA141_min;
            this.max = DFA141_max;
            this.accept = DFA141_accept;
            this.special = DFA141_special;
            this.transition = DFA141_transition;

        }

        override public string Description
        {
            get { return "2370:1: unaryExpression : ( postfixExpression | op= ( NOT | INV ) unaryExpression | unaryOp postfixExpression );"; }
        }

    }


    protected internal int DFA141_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
        ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch (s)
        {
            case 0:
                int LA141_25 = input.LA(1);


                int index141_25 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred292_AS3_ex())) { s = 1; }

                else if ((true)) { s = 28; }


                input.Seek(index141_25);
                if (s >= 0) return s;
                break;
            case 1:
                int LA141_26 = input.LA(1);


                int index141_26 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred294_AS3_ex())) { s = 29; }

                else if ((true)) { s = 28; }


                input.Seek(index141_26);
                if (s >= 0) return s;
                break;
        }
        if (state.backtracking > 0) { state.failed = true; return -1; }
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 141, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA142_eotS =
        "\x4b\uffff";
    const string DFA142_eofS =
        "\x01\x02\x4a\uffff";
    const string DFA142_minS =
        "\x01\x04\x01\x00\x49\uffff";
    const string DFA142_maxS =
        "\x01\u0092\x01\x00\x49\uffff";
    const string DFA142_acceptS =
        "\x02\uffff\x01\x02\x47\uffff\x01\x01";
    const string DFA142_specialS =
        "\x01\uffff\x01\x00\x49\uffff}>";
    static readonly string[] DFA142_transitionS = {
            "\x3d\x02\x01\uffff\x04\x02\x01\uffff\x09\x02\x02\x01\x01\x02"+
            "\x02\uffff\x09\x02\x14\uffff\x02\x02\x0c\uffff\x02\x02\x02\uffff"+
            "\x01\x02\x04\uffff\x01\x02\x02\uffff\x01\x02\x01\uffff\x01\x02"+
            "\x01\uffff\x03\x02",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA142_eot = DFA.UnpackEncodedString(DFA142_eotS);
    static readonly short[] DFA142_eof = DFA.UnpackEncodedString(DFA142_eofS);
    static readonly char[] DFA142_min = DFA.UnpackEncodedStringToUnsignedChars(DFA142_minS);
    static readonly char[] DFA142_max = DFA.UnpackEncodedStringToUnsignedChars(DFA142_maxS);
    static readonly short[] DFA142_accept = DFA.UnpackEncodedString(DFA142_acceptS);
    static readonly short[] DFA142_special = DFA.UnpackEncodedString(DFA142_specialS);
    static readonly short[][] DFA142_transition = DFA.UnpackEncodedStringArray(DFA142_transitionS);

    protected class DFA142 : DFA
    {
        public DFA142(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 142;
            this.eot = DFA142_eot;
            this.eof = DFA142_eof;
            this.min = DFA142_min;
            this.max = DFA142_max;
            this.accept = DFA142_accept;
            this.special = DFA142_special;
            this.transition = DFA142_transition;

        }

        override public string Description
        {
            get { return "2385:32: ( postfixOp )?"; }
        }

    }


    protected internal int DFA142_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
        ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch (s)
        {
            case 0:
                int LA142_1 = input.LA(1);


                int index142_1 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred303_AS3_ex())) { s = 74; }

                else if ((true)) { s = 2; }


                input.Seek(index142_1);
                if (s >= 0) return s;
                break;
        }
        if (state.backtracking > 0) { state.failed = true; return -1; }
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 142, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA146_eotS =
        "\x5c\uffff";
    const string DFA146_eofS =
        "\x01\x01\x5b\uffff";
    const string DFA146_minS =
        "\x01\x04\x28\uffff\x01\x00\x16\uffff\x01\x00\x14\uffff\x01\x00" +
        "\x06\uffff";
    const string DFA146_maxS =
        "\x01\u0092\x28\uffff\x01\x00\x16\uffff\x01\x00\x14\uffff\x01\x00" +
        "\x06\uffff";
    const string DFA146_acceptS =
        "\x01\uffff\x01\x07\x54\uffff\x01\x04\x01\x02\x01\x01\x01\x03\x01" +
        "\x05\x01\x06";
    const string DFA146_specialS =
        "\x29\uffff\x01\x00\x16\uffff\x01\x01\x14\uffff\x01\x02\x06\uffff}>";
    static readonly string[] DFA146_transitionS = {
            "\x39\x01\x01\x40\x01\x01\x01\x29\x01\x01\x01\x55\x04\x01\x01"+
            "\uffff\x0c\x01\x02\uffff\x0a\x01\x02\uffff\x05\x01\x02\uffff"+
            "\x05\x01\x01\uffff\x01\x56\x03\uffff\x02\x01\x0c\uffff\x02\x01"+
            "\x02\uffff\x01\x01\x04\uffff\x01\x01\x02\uffff\x01\x01\x01\uffff"+
            "\x01\x01\x01\uffff\x03\x01",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA146_eot = DFA.UnpackEncodedString(DFA146_eotS);
    static readonly short[] DFA146_eof = DFA.UnpackEncodedString(DFA146_eofS);
    static readonly char[] DFA146_min = DFA.UnpackEncodedStringToUnsignedChars(DFA146_minS);
    static readonly char[] DFA146_max = DFA.UnpackEncodedStringToUnsignedChars(DFA146_maxS);
    static readonly short[] DFA146_accept = DFA.UnpackEncodedString(DFA146_acceptS);
    static readonly short[] DFA146_special = DFA.UnpackEncodedString(DFA146_specialS);
    static readonly short[][] DFA146_transition = DFA.UnpackEncodedStringArray(DFA146_transitionS);

    protected class DFA146 : DFA
    {
        public DFA146(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 146;
            this.eot = DFA146_eot;
            this.eof = DFA146_eof;
            this.min = DFA146_min;
            this.max = DFA146_max;
            this.accept = DFA146_accept;
            this.special = DFA146_special;
            this.transition = DFA146_transition;

        }

        override public string Description
        {
            get { return "()* loopback of 2406:5: ( arguments | L= LBRACK expression R= RBRACK | D= DOT ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier | E= XML_ELLIPSIS ( eitherIdentifier op= XML_NS_OP )? eitherIdentifier | D= DOT parExpression | typePostfixSyntax )*"; }
        }

    }


    protected internal int DFA146_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
        ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch (s)
        {
            case 0:
                int LA146_41 = input.LA(1);


                int index146_41 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred308_AS3_ex())) { s = 87; }

                else if ((true)) { s = 1; }


                input.Seek(index146_41);
                if (s >= 0) return s;
                break;
            case 1:
                int LA146_64 = input.LA(1);


                int index146_64 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred307_AS3_ex())) { s = 88; }

                else if ((true)) { s = 1; }


                input.Seek(index146_64);
                if (s >= 0) return s;
                break;
            case 2:
                int LA146_85 = input.LA(1);


                int index146_85 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred310_AS3_ex())) { s = 89; }

                else if ((synpred313_AS3_ex())) { s = 90; }

                else if ((synpred314_AS3_ex())) { s = 91; }


                input.Seek(index146_85);
                if (s >= 0) return s;
                break;
        }
        if (state.backtracking > 0) { state.failed = true; return -1; }
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 146, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }
    const string DFA154_eotS =
        "\x1c\uffff";
    const string DFA154_eofS =
        "\x1c\uffff";
    const string DFA154_minS =
        "\x01\x04\x05\x00\x07\uffff\x02\x00\x0d\uffff";
    const string DFA154_maxS =
        "\x01\u0092\x05\x00\x07\uffff\x02\x00\x0d\uffff";
    const string DFA154_acceptS =
        "\x06\uffff\x01\x03\x04\uffff\x01\x04\x01\x05\x02\uffff\x01\x07" +
        "\x07\uffff\x01\x08\x01\x01\x01\x02\x01\x06\x01\x09";
    const string DFA154_specialS =
        "\x01\uffff\x01\x00\x01\x01\x01\x02\x01\x03\x01\x04\x07\uffff\x01" +
        "\x05\x01\x06\x0d\uffff}>";
    static readonly string[] DFA154_transitionS = {
            "\x0c\x0f\x01\x05\x0b\x0f\x01\x0e\x01\x0f\x01\x03\x05\x0f\x01"+
            "\x02\x01\x0f\x01\x01\x01\x0f\x01\x0e\x01\x04\x07\x0f\x04\x0e"+
            "\x01\x0f\x04\x0e\x01\uffff\x01\x0c\x01\uffff\x01\x17\x01\uffff"+
            "\x01\x0b\x03\uffff\x01\x0f\x09\uffff\x01\x0f\x24\uffff\x02\x0f"+
            "\x0c\uffff\x02\x06\x02\uffff\x01\x06\x04\uffff\x01\x06\x02\uffff"+
            "\x01\x06\x01\uffff\x01\x0d\x01\uffff\x03\x0f",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\x01\uffff",
            "\x01\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    };

    static readonly short[] DFA154_eot = DFA.UnpackEncodedString(DFA154_eotS);
    static readonly short[] DFA154_eof = DFA.UnpackEncodedString(DFA154_eofS);
    static readonly char[] DFA154_min = DFA.UnpackEncodedStringToUnsignedChars(DFA154_minS);
    static readonly char[] DFA154_max = DFA.UnpackEncodedStringToUnsignedChars(DFA154_maxS);
    static readonly short[] DFA154_accept = DFA.UnpackEncodedString(DFA154_acceptS);
    static readonly short[] DFA154_special = DFA.UnpackEncodedString(DFA154_specialS);
    static readonly short[][] DFA154_transition = DFA.UnpackEncodedStringArray(DFA154_transitionS);

    protected class DFA154 : DFA
    {
        public DFA154(BaseRecognizer recognizer)
        {
            this.recognizer = recognizer;
            this.decisionNumber = 154;
            this.eot = DFA154_eot;
            this.eof = DFA154_eof;
            this.min = DFA154_min;
            this.max = DFA154_max;
            this.accept = DFA154_accept;
            this.special = DFA154_special;
            this.transition = DFA154_transition;

        }

        override public string Description
        {
            get { return "2543:1: primaryExpressionHelper : (T= THIS | S= SUPER | literal | arrayLiteral | objectLiteral | identifierLiteral | xmlPrimaryExpression | parExpression | conditionalCompilerOption );"; }
        }

    }


    protected internal int DFA154_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException
    {
        ITokenStream input = (ITokenStream)_input;
        int _s = s;
        switch (s)
        {
            case 0:
                int LA154_1 = input.LA(1);


                int index154_1 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred378_AS3_ex())) { s = 24; }

                else if ((synpred384_AS3_ex())) { s = 15; }


                input.Seek(index154_1);
                if (s >= 0) return s;
                break;
            case 1:
                int LA154_2 = input.LA(1);


                int index154_2 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred379_AS3_ex())) { s = 25; }

                else if ((synpred384_AS3_ex())) { s = 15; }


                input.Seek(index154_2);
                if (s >= 0) return s;
                break;
            case 2:
                int LA154_3 = input.LA(1);


                int index154_3 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred380_AS3_ex())) { s = 6; }

                else if ((synpred384_AS3_ex())) { s = 15; }


                input.Seek(index154_3);
                if (s >= 0) return s;
                break;
            case 3:
                int LA154_4 = input.LA(1);


                int index154_4 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred380_AS3_ex())) { s = 6; }

                else if ((synpred384_AS3_ex())) { s = 15; }


                input.Seek(index154_4);
                if (s >= 0) return s;
                break;
            case 4:
                int LA154_5 = input.LA(1);


                int index154_5 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred380_AS3_ex())) { s = 6; }

                else if ((synpred384_AS3_ex())) { s = 15; }


                input.Seek(index154_5);
                if (s >= 0) return s;
                break;
            case 5:
                int LA154_13 = input.LA(1);


                int index154_13 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred383_AS3_ex())) { s = 26; }

                else if ((synpred384_AS3_ex())) { s = 15; }

                else if ((true)) { s = 27; }


                input.Seek(index154_13);
                if (s >= 0) return s;
                break;
            case 6:
                int LA154_14 = input.LA(1);


                int index154_14 = input.Index();
                input.Rewind();
                s = -1;
                if ((synpred383_AS3_ex())) { s = 26; }

                else if ((synpred384_AS3_ex())) { s = 15; }

                else if ((true)) { s = 27; }


                input.Seek(index154_14);
                if (s >= 0) return s;
                break;
        }
        if (state.backtracking > 0) { state.failed = true; return -1; }
        NoViableAltException nvae =
            new NoViableAltException(dfa.Description, 154, _s, input);
        dfa.Error(nvae);
        throw nvae;
    }


    public static readonly BitSet FOLLOW_TRUE_in_booleanLiteral3587 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_FALSE_in_booleanLiteral3595 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_DEC_NUMBER_LITERAL_in_numericLiteral3629 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_HEX_NUMBER_LITERAL_in_numericLiteral3637 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_SINGLE_QUOTE_LITERAL_in_stringLiteral3672 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_DOUBLE_QUOTE_LITERAL_in_stringLiteral3679 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_REGULAR_EXPR_LITERAL_in_regularExpresionLiteral3704 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_IDENTIFIER_in_identifierLiteral3737 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_notQuiteReservedWord_in_identifierLiteral3742 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_IDENTIFIER_in_xmlNameLiteral3777 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000020001002UL });
    public static readonly BitSet FOLLOW_allKeywords_in_xmlNameLiteral3782 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000020001002UL });
    public static readonly BitSet FOLLOW_SUB_in_xmlNameLiteral3793 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_DOT_in_xmlNameLiteral3801 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_COLON_in_xmlNameLiteral3809 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_IDENTIFIER_in_xmlNameLiteral3820 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000020001002UL });
    public static readonly BitSet FOLLOW_allKeywords_in_xmlNameLiteral3826 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000020001002UL });
    public static readonly BitSet FOLLOW_NULL_in_literal3879 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_booleanLiteral_in_literal3885 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_numericLiteral_in_literal3889 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_stringLiteral_in_literal3893 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_regularExpresionLiteral_in_literal3897 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlComment_in_xmlMarkup3933 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlCDATA_in_xmlMarkup3937 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlPI_in_xmlMarkup3941 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_XML_COMMENT_in_xmlComment3976 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_XML_CDATA_in_xmlCDATA4018 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_XML_PI_in_xmlPI4061 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_LCURLY_in_xmlExprEval4099 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_expression_in_xmlExprEval4103 = new BitSet(new ulong[] { 0x1000000000000000UL });
    public static readonly BitSet FOLLOW_RCURLY_in_xmlExprEval4107 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_allKeywords_in_xmlTextElement4125 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_set_in_xmlTextElement4138 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_XML_TEXT_in_xmlText4890 = new BitSet(new ulong[] { 0xF7FFFFFFFFFFFFF2UL, 0x00067F3FFFE7FFB7UL, 0x0000000000085203UL });
    public static readonly BitSet FOLLOW_xmlTextElement_in_xmlText4896 = new BitSet(new ulong[] { 0xF7FFFFFFFFFFFFF2UL, 0x00067F3FFFE7FFB7UL, 0x0000000000085203UL });
    public static readonly BitSet FOLLOW_xmlPropertyIdentifier_in_xmlPrimaryExpression4998 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlInitialiser_in_xmlPrimaryExpression5008 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlListInitialiser_in_xmlPrimaryExpression5018 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlAttributeIdentifier_in_xmlPropertyIdentifier5111 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlQualifiedIdentifier_in_xmlPropertyIdentifier5123 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_STAR_in_xmlPropertyIdentifier5137 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_XML_AT_in_xmlAttributeIdentifier5202 = new BitSet(new ulong[] { 0x83FFFFFFFFFFFFF0UL, 0x0000000000002000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_xmlQualifiedIdentifier_in_xmlAttributeIdentifier5228 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlPropertySelector_in_xmlAttributeIdentifier5243 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_indexSuffix_in_xmlAttributeIdentifier5258 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlNameLiteral_in_xmlPropertySelector5348 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_STAR_in_xmlPropertySelector5361 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlPropertySelector_in_xmlQualifiedIdentifier5382 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0002000000000000UL });
    public static readonly BitSet FOLLOW_XML_NS_OP_in_xmlQualifiedIdentifier5387 = new BitSet(new ulong[] { 0x83FFFFFFFFFFFFF0UL, 0x0000000000002000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_xmlPropertySelector_in_xmlQualifiedIdentifier5422 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_indexSuffix_in_xmlQualifiedIdentifier5434 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlMarkup_in_xmlInitialiser5459 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlElement_in_xmlInitialiser5469 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_LT_in_xmlElement5513 = new BitSet(new ulong[] { 0x0BFFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_xmlTagName_in_xmlElement5518 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000800000000010UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_xmlAttributes_in_xmlElement5520 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000800000000010UL });
    public static readonly BitSet FOLLOW_XML_TEND_in_xmlElement5540 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_GT_in_xmlElement5585 = new BitSet(new ulong[] { 0xFFFFFFFFFFFFFFF0UL, 0x00077F3FFFE7FFBFUL, 0x00000000000F5203UL });
    public static readonly BitSet FOLLOW_xmlElementContent_in_xmlElement5589 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0001000000000000UL });
    public static readonly BitSet FOLLOW_XML_E_TEND_in_xmlElement5603 = new BitSet(new ulong[] { 0x0BFFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_xmlTagName_in_xmlElement5617 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000010UL });
    public static readonly BitSet FOLLOW_GT_in_xmlElement5621 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlAttribute_in_xmlAttributes5660 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF2UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_xmlExprEval_in_xmlTagName5690 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlNameLiteral_in_xmlTagName5695 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlNameLiteral_in_xmlAttribute5718 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000040000000UL });
    public static readonly BitSet FOLLOW_ASSIGN_in_xmlAttribute5722 = new BitSet(new ulong[] { 0x0800000000000000UL, 0x0000000000000000UL, 0x0000000000000003UL });
    public static readonly BitSet FOLLOW_xmlExprEval_in_xmlAttribute5741 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_stringLiteral_in_xmlAttribute5753 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlElementContentHelper_in_xmlElementContent5784 = new BitSet(new ulong[] { 0xFFFFFFFFFFFFFFF2UL, 0x00067F3FFFE7FFBFUL, 0x00000000000F5203UL });
    public static readonly BitSet FOLLOW_xmlExprEval_in_xmlElementContentHelper5802 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlMarkup_in_xmlElementContentHelper5811 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlElement_in_xmlElementContentHelper5820 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlText_in_xmlElementContentHelper5830 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_XML_LS_STD_in_xmlListInitialiser5851 = new BitSet(new ulong[] { 0xFFFFFFFFFFFFFFF0UL, 0x00167F3FFFE7FFBFUL, 0x00000000000F5203UL });
    public static readonly BitSet FOLLOW_xmlElementContent_in_xmlListInitialiser5866 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0010000000000000UL });
    public static readonly BitSet FOLLOW_XML_LS_END_in_xmlListInitialiser5878 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_SEMI_in_semic5909 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_EOF_in_semic5923 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_RCURLY_in_semic5937 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_packageDeclaration_in_fileContents5957 = new BitSet(new ulong[] { 0xAFFFFFFFFFFFFFF2UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_packageElement_in_fileContents5960 = new BitSet(new ulong[] { 0xAFFFFFFFFFFFFFF2UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_EOF_in_fileContents5966 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_PACKAGE_in_packageDeclaration5983 = new BitSet(new ulong[] { 0x0BFFFFFFFFFFFFF0UL, 0x0000000000002000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_type_in_packageDeclaration5988 = new BitSet(new ulong[] { 0x0800000000000000UL });
    public static readonly BitSet FOLLOW_LCURLY_in_packageDeclaration6002 = new BitSet(new ulong[] { 0xBFFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_packageElement_in_packageDeclaration6018 = new BitSet(new ulong[] { 0xBFFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_RCURLY_in_packageDeclaration6037 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_propertyDeclaration_in_mxmlEmbedded6062 = new BitSet(new ulong[] { 0xAFFFFFFFFFFFFFF2UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_functionDeclaration_in_mxmlEmbedded6066 = new BitSet(new ulong[] { 0xAFFFFFFFFFFFFFF2UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_statement_in_mxmlEmbedded6070 = new BitSet(new ulong[] { 0xAFFFFFFFFFFFFFF2UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_directive_in_mxmlEmbedded6074 = new BitSet(new ulong[] { 0xAFFFFFFFFFFFFFF2UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_interfaceFunctionDeclaration_in_mxmlEmbedded6078 = new BitSet(new ulong[] { 0xAFFFFFFFFFFFFFF2UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_EOF_in_mxmlEmbedded6084 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_classOrInterfaceDecl_in_packageElement6104 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_propertyDeclaration_in_packageElement6108 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_functionDeclaration_in_packageElement6112 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_interfaceFunctionDeclaration_in_packageElement6116 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_statement_in_packageElement6120 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_directive_in_packageElement6124 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_IMPORT_in_importDeclaration6144 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000002000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_type_in_importDeclaration6148 = new BitSet(new ulong[] { 0x1400000000000000UL, 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_DOT_in_importDeclaration6153 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000002000UL });
    public static readonly BitSet FOLLOW_STAR_in_importDeclaration6159 = new BitSet(new ulong[] { 0x1400000000000000UL, 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_semic_in_importDeclaration6165 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_conditionalDirAndBindingDecls_in_classOrInterfaceDecl6180 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000000002008UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_memberModifiers_in_classOrInterfaceDecl6188 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000000002008UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_interfaceDeclaration_in_classOrInterfaceDecl6192 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_classDeclaration_in_classOrInterfaceDecl6196 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_bindingDecl_in_directive6212 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_includeDirective_in_directive6216 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_useNamespaceDirective_in_directive6220 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_importDeclaration_in_directive6224 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_defaultXMLNamespaceDirective_in_directive6230 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_conditionalCompilerOption_in_conditionalDirAndBindingDecls6256 = new BitSet(new ulong[] { 0x8000000000000002UL });
    public static readonly BitSet FOLLOW_bindingDecl_in_conditionalDirAndBindingDecls6273 = new BitSet(new ulong[] { 0x8000000000000002UL });
    public static readonly BitSet FOLLOW_IDENTIFIER_in_xmlKeyword6291 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_identifierLiteral_in_conditionalCompilerOption6307 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0002000000000000UL });
    public static readonly BitSet FOLLOW_XML_NS_OP_in_conditionalCompilerOption6311 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_identifierLiteral_in_conditionalCompilerOption6315 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_DEFAULT_in_defaultXMLNamespaceDirective6329 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_xmlKeyword_in_defaultXMLNamespaceDirective6333 = new BitSet(new ulong[] { 0x0010000000000000UL });
    public static readonly BitSet FOLLOW_NAMESPACE_in_defaultXMLNamespaceDirective6341 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000040000000UL });
    public static readonly BitSet FOLLOW_ASSIGN_in_defaultXMLNamespaceDirective6349 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_IDENTIFIER_in_defaultXMLNamespaceDirective6355 = new BitSet(new ulong[] { 0x1400000000000000UL, 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_semic_in_defaultXMLNamespaceDirective6359 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_LBRACK_in_bindingDecl6379 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_IDENTIFIER_in_bindingDecl6389 = new BitSet(new ulong[] { 0x2000000000000000UL, 0x0000000000000001UL });
    public static readonly BitSet FOLLOW_LPAREN_in_bindingDecl6415 = new BitSet(new ulong[] { 0x43FFFFFFFFFFFFF0UL, 0x0004000000002000UL, 0x0000000000005203UL });
    public static readonly BitSet FOLLOW_bindingDeclArg_in_bindingDecl6428 = new BitSet(new ulong[] { 0x4000000000000000UL, 0x0000000000000004UL });
    public static readonly BitSet FOLLOW_COMMA_in_bindingDecl6433 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0004000000002000UL, 0x0000000000005203UL });
    public static readonly BitSet FOLLOW_bindingDeclArg_in_bindingDecl6437 = new BitSet(new ulong[] { 0x4000000000000000UL, 0x0000000000000004UL });
    public static readonly BitSet FOLLOW_RPAREN_in_bindingDecl6451 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000001UL });
    public static readonly BitSet FOLLOW_RBRACK_in_bindingDecl6473 = new BitSet(new ulong[] { 0x0400000000000002UL });
    public static readonly BitSet FOLLOW_SEMI_in_bindingDecl6479 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_INCLUDE_in_includeDirective6504 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000000UL, 0x0000000000000003UL });
    public static readonly BitSet FOLLOW_stringLiteral_in_includeDirective6507 = new BitSet(new ulong[] { 0x1400000000000000UL, 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_semic_in_includeDirective6509 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_IDENTIFIER_in_bindingDeclArg6540 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000040000000UL });
    public static readonly BitSet FOLLOW_ASSIGN_in_bindingDeclArg6546 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0004000000002000UL, 0x0000000000005203UL });
    public static readonly BitSet FOLLOW_stringLiteral_in_bindingDeclArg6559 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_numericLiteral_in_bindingDeclArg6563 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_eitherIdentifier_in_bindingDeclArg6567 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_INTERFACE_in_interfaceDeclaration6589 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000002000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_type_in_interfaceDeclaration6593 = new BitSet(new ulong[] { 0x0800000000008000UL });
    public static readonly BitSet FOLLOW_EXTENDS_in_interfaceDeclaration6598 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000002000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_typeList_in_interfaceDeclaration6602 = new BitSet(new ulong[] { 0x0800000000008000UL });
    public static readonly BitSet FOLLOW_interfaceBody_in_interfaceDeclaration6616 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_LCURLY_in_interfaceBody6632 = new BitSet(new ulong[] { 0xBFFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_interfaceElement_in_interfaceBody6648 = new BitSet(new ulong[] { 0xBFFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_RCURLY_in_interfaceBody6667 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_CLASS_in_classDeclaration6685 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000002000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_type_in_classDeclaration6689 = new BitSet(new ulong[] { 0x0800000000208000UL });
    public static readonly BitSet FOLLOW_EXTENDS_in_classDeclaration6695 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000002000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_type_in_classDeclaration6699 = new BitSet(new ulong[] { 0x0800000000208000UL });
    public static readonly BitSet FOLLOW_IMPLEMENTS_in_classDeclaration6707 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000002000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_typeList_in_classDeclaration6711 = new BitSet(new ulong[] { 0x0800000000208000UL });
    public static readonly BitSet FOLLOW_classBody_in_classDeclaration6725 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_LCURLY_in_classBody6754 = new BitSet(new ulong[] { 0xBFFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_classBodyElement_in_classBody6764 = new BitSet(new ulong[] { 0xBFFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_RCURLY_in_classBody6777 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_propertyDeclaration_in_classBodyElement6801 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_functionDeclaration_in_classBodyElement6805 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_statement_in_classBodyElement6809 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_directive_in_classBodyElement6813 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_propertyDeclaration_in_interfaceElement6830 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_interfaceFunctionDeclaration_in_interfaceElement6834 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_statement_in_interfaceElement6838 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_directive_in_interfaceElement6841 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_conditionalDirAndBindingDecls_in_interfaceFunctionDeclaration6871 = new BitSet(new ulong[] { 0x03C0000714080000UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_memberModifiers_in_interfaceFunctionDeclaration6877 = new BitSet(new ulong[] { 0x0000000000080000UL });
    public static readonly BitSet FOLLOW_FUNCTION_in_interfaceFunctionDeclaration6882 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_SET_in_interfaceFunctionDeclaration6901 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_GET_in_interfaceFunctionDeclaration6908 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_IDENTIFIER_in_interfaceFunctionDeclaration6922 = new BitSet(new ulong[] { 0x2000000000000000UL });
    public static readonly BitSet FOLLOW_notQuiteReservedWord_in_interfaceFunctionDeclaration6928 = new BitSet(new ulong[] { 0x2000000000000000UL });
    public static readonly BitSet FOLLOW_formalParameterList_in_interfaceFunctionDeclaration6931 = new BitSet(new ulong[] { 0x1400000000000000UL, 0x0000000020000002UL });
    public static readonly BitSet FOLLOW_COLON_in_interfaceFunctionDeclaration6936 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000002000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_type_in_interfaceFunctionDeclaration6940 = new BitSet(new ulong[] { 0x1400000000000000UL, 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_semic_in_interfaceFunctionDeclaration6944 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_conditionalDirAndBindingDecls_in_propertyDeclaration6968 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000000002008UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_memberModifiers_in_propertyDeclaration6975 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000000002008UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_variableStatement_in_propertyDeclaration6979 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_constantVarStatement_in_propertyDeclaration6983 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_namespaceDirective_in_propertyDeclaration6987 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_conditionalDirAndBindingDecls_in_functionDeclaration7012 = new BitSet(new ulong[] { 0x03C0000714080000UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_memberModifiers_in_functionDeclaration7019 = new BitSet(new ulong[] { 0x0000000000080000UL });
    public static readonly BitSet FOLLOW_FUNCTION_in_functionDeclaration7024 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_set_in_functionDeclaration7036 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_IDENTIFIER_in_functionDeclaration7053 = new BitSet(new ulong[] { 0x2000000000000000UL });
    public static readonly BitSet FOLLOW_notQuiteReservedWord_in_functionDeclaration7059 = new BitSet(new ulong[] { 0x2000000000000000UL });
    public static readonly BitSet FOLLOW_formalParameterList_in_functionDeclaration7062 = new BitSet(new ulong[] { 0x0800000000000000UL, 0x0000000020000000UL });
    public static readonly BitSet FOLLOW_COLON_in_functionDeclaration7067 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000002000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_type_in_functionDeclaration7071 = new BitSet(new ulong[] { 0x0800000000000000UL, 0x0000000020000000UL });
    public static readonly BitSet FOLLOW_functionBody_in_functionDeclaration7077 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_FUNCTION_in_functionExpression7105 = new BitSet(new ulong[] { 0x2000000000000000UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_IDENTIFIER_in_functionExpression7112 = new BitSet(new ulong[] { 0x2000000000000000UL });
    public static readonly BitSet FOLLOW_formalParameterList_in_functionExpression7117 = new BitSet(new ulong[] { 0x0800000000000000UL, 0x0000000020000000UL });
    public static readonly BitSet FOLLOW_COLON_in_functionExpression7122 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000002000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_type_in_functionExpression7126 = new BitSet(new ulong[] { 0x0800000000000000UL, 0x0000000020000000UL });
    public static readonly BitSet FOLLOW_functionBody_in_functionExpression7132 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_LPAREN_in_formalParameterList7175 = new BitSet(new ulong[] { 0x43FFFFFFFFFFFFF0UL, 0x0000200000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_variableDeclaration_in_formalParameterList7194 = new BitSet(new ulong[] { 0x4000000000000000UL, 0x0000000000000004UL });
    public static readonly BitSet FOLLOW_COMMA_in_formalParameterList7229 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_variableDeclaration_in_formalParameterList7264 = new BitSet(new ulong[] { 0x4000000000000000UL, 0x0000000000000004UL });
    public static readonly BitSet FOLLOW_COMMA_in_formalParameterList7301 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000200000000000UL });
    public static readonly BitSet FOLLOW_formalEllipsisParameter_in_formalParameterList7307 = new BitSet(new ulong[] { 0x4000000000000000UL });
    public static readonly BitSet FOLLOW_formalEllipsisParameter_in_formalParameterList7339 = new BitSet(new ulong[] { 0x4000000000000000UL });
    public static readonly BitSet FOLLOW_RPAREN_in_formalParameterList7363 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_ELLIPSIS_in_formalEllipsisParameter7410 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_variableIdentifierDecl_in_formalEllipsisParameter7415 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_LCURLY_in_functionBody7439 = new BitSet(new ulong[] { 0xBFFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_statement_in_functionBody7457 = new BitSet(new ulong[] { 0xBFFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_functionDeclaration_in_functionBody7459 = new BitSet(new ulong[] { 0xBFFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_RCURLY_in_functionBody7473 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_memberModifier_in_memberModifiers7501 = new BitSet(new ulong[] { 0x03C0000714000002UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_set_in_memberModifier7528 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_blockStatement_in_statement7668 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_directive_in_statement7679 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_namespaceDirective_in_statement7690 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_expression_in_statement7703 = new BitSet(new ulong[] { 0x1400000000000000UL, 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_semic_in_statement7705 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_constantVarStatement_in_statement7720 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_tryStatement_in_statement7733 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_labelledStatement_in_statement7745 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_switchStatement_in_statement7758 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_withStatement_in_statement7770 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_returnStatement_in_statement7784 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_breakStatement_in_statement7800 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_continueStatement_in_statement7816 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_forStatement_in_statement7830 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_forInStatement_in_statement7842 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_forEachInStatement_in_statement7854 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_doWhileStatement_in_statement7866 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_whileStatement_in_statement7878 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_ifStatement_in_statement7889 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_emptyStatement_in_statement7900 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_variableStatement_in_statement7914 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_throwStatement_in_statement7930 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_conditionalCompilerOption_in_blockStatement7961 = new BitSet(new ulong[] { 0x0800000000000000UL });
    public static readonly BitSet FOLLOW_LCURLY_in_blockStatement7967 = new BitSet(new ulong[] { 0xBFFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_statement_in_blockStatement7984 = new BitSet(new ulong[] { 0xBFFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_RCURLY_in_blockStatement7997 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_THROW_in_throwStatement8018 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_expression_in_throwStatement8022 = new BitSet(new ulong[] { 0x1400000000000000UL, 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_semic_in_throwStatement8024 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_CONST_in_constantVarStatement8044 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_variableDeclarationList_in_constantVarStatement8049 = new BitSet(new ulong[] { 0x0400000000000002UL });
    public static readonly BitSet FOLLOW_SEMI_in_constantVarStatement8054 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_USE_in_useNamespaceDirective8156 = new BitSet(new ulong[] { 0x0010000000000000UL });
    public static readonly BitSet FOLLOW_NAMESPACE_in_useNamespaceDirective8165 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_qualifiedIdentifier_in_useNamespaceDirective8172 = new BitSet(new ulong[] { 0x1400000000000000UL, 0x0000000000000006UL });
    public static readonly BitSet FOLLOW_COMMA_in_useNamespaceDirective8177 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_qualifiedIdentifier_in_useNamespaceDirective8181 = new BitSet(new ulong[] { 0x1400000000000000UL, 0x0000000000000006UL });
    public static readonly BitSet FOLLOW_semic_in_useNamespaceDirective8185 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_NAMESPACE_in_namespaceDirective8215 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_qualifiedIdentifier_in_namespaceDirective8226 = new BitSet(new ulong[] { 0x1400000000000000UL, 0x0000000040000002UL });
    public static readonly BitSet FOLLOW_ASSIGN_in_namespaceDirective8232 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000000UL, 0x0000000000000003UL });
    public static readonly BitSet FOLLOW_stringLiteral_in_namespaceDirective8237 = new BitSet(new ulong[] { 0x1400000000000000UL, 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_semic_in_namespaceDirective8242 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_TRY_in_tryStatement8270 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000000002008UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_blockStatement_in_tryStatement8276 = new BitSet(new ulong[] { 0x0000000000020080UL });
    public static readonly BitSet FOLLOW_catchClause_in_tryStatement8290 = new BitSet(new ulong[] { 0x0000000000020080UL });
    public static readonly BitSet FOLLOW_finallyClause_in_tryStatement8293 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_catchClause_in_tryStatement8305 = new BitSet(new ulong[] { 0x0000000000000082UL });
    public static readonly BitSet FOLLOW_finallyClause_in_tryStatement8318 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_CATCH_in_catchClause8350 = new BitSet(new ulong[] { 0x2000000000000000UL });
    public static readonly BitSet FOLLOW_LPAREN_in_catchClause8357 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_variableIdentifierDecl_in_catchClause8361 = new BitSet(new ulong[] { 0x4000000000000000UL });
    public static readonly BitSet FOLLOW_RPAREN_in_catchClause8365 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000000002008UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_blockStatement_in_catchClause8369 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_FINALLY_in_finallyClause8393 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000000002008UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_blockStatement_in_finallyClause8398 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_IDENTIFIER_in_labelledStatement8424 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000020000000UL });
    public static readonly BitSet FOLLOW_COLON_in_labelledStatement8437 = new BitSet(new ulong[] { 0xAFFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_statement_in_labelledStatement8453 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_SWITCH_in_switchStatement8488 = new BitSet(new ulong[] { 0x2000000000000000UL });
    public static readonly BitSet FOLLOW_parExpression_in_switchStatement8493 = new BitSet(new ulong[] { 0x0800000000000000UL });
    public static readonly BitSet FOLLOW_LCURLY_in_switchStatement8505 = new BitSet(new ulong[] { 0x1000000000000840UL });
    public static readonly BitSet FOLLOW_switchBlockStatementGroup_in_switchStatement8521 = new BitSet(new ulong[] { 0x1000000000000840UL });
    public static readonly BitSet FOLLOW_RCURLY_in_switchStatement8534 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_switchLabel_in_switchBlockStatementGroup8567 = new BitSet(new ulong[] { 0xAFFFFFFFFFFFFFF2UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_statement_in_switchBlockStatementGroup8571 = new BitSet(new ulong[] { 0xAFFFFFFFFFFFFFF2UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_breakStatement_in_switchBlockStatementGroup8577 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_CASE_in_switchLabel8603 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_expression_in_switchLabel8607 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000020000000UL });
    public static readonly BitSet FOLLOW_COLON_in_switchLabel8611 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_DEFAULT_in_switchLabel8632 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000020000000UL });
    public static readonly BitSet FOLLOW_COLON_in_switchLabel8638 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_WITH_in_withStatement8672 = new BitSet(new ulong[] { 0x2000000000000000UL });
    public static readonly BitSet FOLLOW_LPAREN_in_withStatement8680 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_expression_in_withStatement8685 = new BitSet(new ulong[] { 0x4000000000000000UL });
    public static readonly BitSet FOLLOW_RPAREN_in_withStatement8690 = new BitSet(new ulong[] { 0xAFFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_statement_in_withStatement8698 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_RETURN_in_returnStatement8725 = new BitSet(new ulong[] { 0xBFFFFFFFFFFFFFF0UL, 0x000C00000303380AUL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_expression_in_returnStatement8733 = new BitSet(new ulong[] { 0x1400000000000000UL, 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_semic_in_returnStatement8737 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_BREAK_in_breakStatement8764 = new BitSet(new ulong[] { 0x1400000000000000UL, 0x0000000000000002UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_IDENTIFIER_in_breakStatement8774 = new BitSet(new ulong[] { 0x1400000000000000UL, 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_semic_in_breakStatement8779 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_CONTINUE_in_continueStatement8805 = new BitSet(new ulong[] { 0x1400000000000000UL, 0x0000000000000002UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_IDENTIFIER_in_continueStatement8812 = new BitSet(new ulong[] { 0x1400000000000000UL, 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_semic_in_continueStatement8817 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_FOR_in_forStatement8843 = new BitSet(new ulong[] { 0x2000000000000000UL });
    public static readonly BitSet FOLLOW_LPAREN_in_forStatement8851 = new BitSet(new ulong[] { 0xBFFFFFFFFFFFFFF0UL, 0x000C00000303380AUL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_forControl_in_forStatement8855 = new BitSet(new ulong[] { 0x4000000000000000UL });
    public static readonly BitSet FOLLOW_RPAREN_in_forStatement8859 = new BitSet(new ulong[] { 0xAFFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_statement_in_forStatement8865 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_FOR_in_forInStatement8892 = new BitSet(new ulong[] { 0x2000000000000000UL });
    public static readonly BitSet FOLLOW_LPAREN_in_forInStatement8900 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000000002008UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_forInControl_in_forInStatement8904 = new BitSet(new ulong[] { 0x4000000000000000UL });
    public static readonly BitSet FOLLOW_RPAREN_in_forInStatement8908 = new BitSet(new ulong[] { 0xAFFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_statement_in_forInStatement8916 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_FOR_in_forEachInStatement8945 = new BitSet(new ulong[] { 0x0002000000000000UL });
    public static readonly BitSet FOLLOW_EACH_in_forEachInStatement8963 = new BitSet(new ulong[] { 0x2000000000000000UL });
    public static readonly BitSet FOLLOW_LPAREN_in_forEachInStatement8974 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000000002008UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_forInControl_in_forEachInStatement8978 = new BitSet(new ulong[] { 0x4000000000000000UL });
    public static readonly BitSet FOLLOW_RPAREN_in_forEachInStatement8982 = new BitSet(new ulong[] { 0xAFFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_statement_in_forEachInStatement8988 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_forInit_in_forControl9018 = new BitSet(new ulong[] { 0x1400000000000000UL, 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_semic_in_forControl9023 = new BitSet(new ulong[] { 0xBFFFFFFFFFFFFFF0UL, 0x000C00000303380AUL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_expression_in_forControl9028 = new BitSet(new ulong[] { 0x1400000000000000UL, 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_semic_in_forControl9032 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF2UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_forUpdate_in_forControl9036 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_forInDecl_in_forInControl9064 = new BitSet(new ulong[] { 0x0000000000800000UL });
    public static readonly BitSet FOLLOW_IN_in_forInControl9068 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_expression_in_forInControl9072 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_leftHandSideExpression_in_forInDecl9091 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_VAR_in_forInDecl9103 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_variableDeclarationNoIn_in_forInDecl9107 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_variableDeclarationNoInList_in_forInit9126 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_expressionNoIn_in_forInit9136 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_expression_in_forUpdate9155 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_DO_in_doWhileStatement9181 = new BitSet(new ulong[] { 0xAFFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_statement_in_doWhileStatement9187 = new BitSet(new ulong[] { 0x0000800000000000UL });
    public static readonly BitSet FOLLOW_WHILE_in_doWhileStatement9196 = new BitSet(new ulong[] { 0x2000000000000000UL });
    public static readonly BitSet FOLLOW_parExpression_in_doWhileStatement9200 = new BitSet(new ulong[] { 0x1400000000000000UL, 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_semic_in_doWhileStatement9202 = new BitSet(new ulong[] { 0x0400000000000002UL });
    public static readonly BitSet FOLLOW_SEMI_in_doWhileStatement9207 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_WHILE_in_whileStatement9237 = new BitSet(new ulong[] { 0x2000000000000000UL });
    public static readonly BitSet FOLLOW_parExpression_in_whileStatement9242 = new BitSet(new ulong[] { 0xAFFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_statement_in_whileStatement9248 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_IF_in_ifStatement9311 = new BitSet(new ulong[] { 0x2000000000000000UL });
    public static readonly BitSet FOLLOW_parExpression_in_ifStatement9346 = new BitSet(new ulong[] { 0xAFFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_statement_in_ifStatement9391 = new BitSet(new ulong[] { 0x0000000000004002UL });
    public static readonly BitSet FOLLOW_ELSE_in_ifStatement9446 = new BitSet(new ulong[] { 0xAFFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_statement_in_ifStatement9487 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_SEMI_in_emptyStatement9545 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_IDENTIFIER_in_variableStatement9592 = new BitSet(new ulong[] { 0x0000200000000000UL });
    public static readonly BitSet FOLLOW_VAR_in_variableStatement9600 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_variableDeclaration_in_variableStatement9604 = new BitSet(new ulong[] { 0x1400000000000000UL, 0x0000000000000006UL });
    public static readonly BitSet FOLLOW_COMMA_in_variableStatement9611 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_variableDeclaration_in_variableStatement9616 = new BitSet(new ulong[] { 0x1400000000000000UL, 0x0000000000000006UL });
    public static readonly BitSet FOLLOW_semic_in_variableStatement9621 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_variableDeclaration_in_variableDeclarationList9663 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000004UL });
    public static readonly BitSet FOLLOW_COMMA_in_variableDeclarationList9671 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_variableDeclaration_in_variableDeclarationList9676 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000004UL });
    public static readonly BitSet FOLLOW_VAR_in_variableDeclarationNoInList9705 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_variableDeclarationNoIn_in_variableDeclarationNoInList9711 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000004UL });
    public static readonly BitSet FOLLOW_COMMA_in_variableDeclarationNoInList9719 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_variableDeclarationNoIn_in_variableDeclarationNoInList9724 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000004UL });
    public static readonly BitSet FOLLOW_variableIdentifierDecl_in_variableDeclaration9749 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000040000000UL });
    public static readonly BitSet FOLLOW_ASSIGN_in_variableDeclaration9755 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_assignmentExpression_in_variableDeclaration9771 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_variableIdentifierDecl_in_variableDeclarationNoIn9794 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000040000000UL });
    public static readonly BitSet FOLLOW_ASSIGN_in_variableDeclarationNoIn9800 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_assignmentExpressionNoIn_in_variableDeclarationNoIn9824 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_identifierLiteral_in_variableIdentifierDecl9851 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000020000000UL });
    public static readonly BitSet FOLLOW_COLON_in_variableIdentifierDecl9857 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000002000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_type_in_variableIdentifierDecl9861 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_qualifiedName_in_type9885 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_STAR_in_type9891 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_VOID_in_type9899 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_type_in_typeList9916 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000004UL });
    public static readonly BitSet FOLLOW_COMMA_in_typeList9922 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000002000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_type_in_typeList9927 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000004UL });
    public static readonly BitSet FOLLOW_typeSpecifier_in_standardQualifiedName9951 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_DOT_in_standardQualifiedName9956 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_typeSpecifier_in_standardQualifiedName9960 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_standardQualifiedName_in_qualifiedName9988 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_typePostfixSyntax_in_qualifiedName9991 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_DOT_in_typePostfixSyntax10013 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000008UL });
    public static readonly BitSet FOLLOW_LT_in_typePostfixSyntax10019 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_standardQualifiedName_in_typePostfixSyntax10023 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000012UL });
    public static readonly BitSet FOLLOW_typePostfixSyntax_in_typePostfixSyntax10026 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000010UL });
    public static readonly BitSet FOLLOW_GT_in_typePostfixSyntax10032 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_IDENTIFIER_in_qualifiedIdentifier10056 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_LPAREN_in_parExpression10081 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_expression_in_parExpression10088 = new BitSet(new ulong[] { 0x4000000000000000UL });
    public static readonly BitSet FOLLOW_RPAREN_in_parExpression10093 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_assignmentExpression_in_expression10134 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000004UL });
    public static readonly BitSet FOLLOW_COMMA_in_expression10142 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_assignmentExpression_in_expression10148 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000004UL });
    public static readonly BitSet FOLLOW_assignmentExpressionNoIn_in_expressionNoIn10176 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000004UL });
    public static readonly BitSet FOLLOW_COMMA_in_expressionNoIn10184 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_assignmentExpressionNoIn_in_expressionNoIn10190 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000004UL });
    public static readonly BitSet FOLLOW_leftHandSideExpression_in_assignmentExpression10219 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x00001F3E40002010UL });
    public static readonly BitSet FOLLOW_assignmentOperator_in_assignmentExpression10222 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_assignmentExpression_in_assignmentExpression10225 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_conditionalExpression_in_assignmentExpression10233 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_conditionalExpressionNoIn_in_assignmentExpressionNoIn10253 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_leftHandSideExpression_in_assignmentExpressionNoIn10263 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x00001F3E40002010UL });
    public static readonly BitSet FOLLOW_assignmentOperator_in_assignmentExpressionNoIn10266 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_assignmentExpressionNoIn_in_assignmentExpressionNoIn10269 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_assignmentOperator_int_in_assignmentOperator10285 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_ASSIGN_in_assignmentOperator_int10311 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_STAR_in_assignmentOperator_int10320 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000040000000UL });
    public static readonly BitSet FOLLOW_ASSIGN_in_assignmentOperator_int10324 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_DIV_ASSIGN_in_assignmentOperator_int10335 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_MOD_ASSIGN_in_assignmentOperator_int10344 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_ADD_ASSIGN_in_assignmentOperator_int10353 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_SUB_ASSIGN_in_assignmentOperator_int10362 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_SHL_ASSIGN_in_assignmentOperator_int10370 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_GT_in_assignmentOperator_int10394 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000010UL });
    public static readonly BitSet FOLLOW_GT_in_assignmentOperator_int10398 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000040000000UL });
    public static readonly BitSet FOLLOW_ASSIGN_in_assignmentOperator_int10402 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_GT_in_assignmentOperator_int10448 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000010UL });
    public static readonly BitSet FOLLOW_GT_in_assignmentOperator_int10452 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000010UL });
    public static readonly BitSet FOLLOW_GT_in_assignmentOperator_int10456 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000040000000UL });
    public static readonly BitSet FOLLOW_ASSIGN_in_assignmentOperator_int10460 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_AND_ASSIGN_in_assignmentOperator_int10491 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_XOR_ASSIGN_in_assignmentOperator_int10500 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_OR_ASSIGN_in_assignmentOperator_int10509 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_LOR_ASSIGN_in_assignmentOperator_int10517 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_LAND_ASSIGN_in_assignmentOperator_int10525 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_logicalORExpression_in_conditionalExpression10545 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000010000000UL });
    public static readonly BitSet FOLLOW_QUE_in_conditionalExpression10551 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_assignmentExpression_in_conditionalExpression10556 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000020000000UL });
    public static readonly BitSet FOLLOW_COLON_in_conditionalExpression10563 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_assignmentExpression_in_conditionalExpression10568 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_logicalORExpressionNoIn_in_conditionalExpressionNoIn10595 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000010000000UL });
    public static readonly BitSet FOLLOW_QUE_in_conditionalExpressionNoIn10601 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_assignmentExpression_in_conditionalExpressionNoIn10605 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000020000000UL });
    public static readonly BitSet FOLLOW_COLON_in_conditionalExpressionNoIn10612 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_assignmentExpression_in_conditionalExpressionNoIn10617 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_logicalANDExpression_in_logicalORExpression10649 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000008000000UL });
    public static readonly BitSet FOLLOW_LOR_in_logicalORExpression10655 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_logicalANDExpression_in_logicalORExpression10659 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000008000000UL });
    public static readonly BitSet FOLLOW_logicalANDExpressionNoIn_in_logicalORExpressionNoIn10687 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000008000000UL });
    public static readonly BitSet FOLLOW_LOR_in_logicalORExpressionNoIn10693 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_logicalANDExpressionNoIn_in_logicalORExpressionNoIn10697 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000008000000UL });
    public static readonly BitSet FOLLOW_bitwiseORExpression_in_logicalANDExpression10729 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000004000000UL });
    public static readonly BitSet FOLLOW_LAND_in_logicalANDExpression10735 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_bitwiseORExpression_in_logicalANDExpression10739 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000004000000UL });
    public static readonly BitSet FOLLOW_bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn10766 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000004000000UL });
    public static readonly BitSet FOLLOW_LAND_in_logicalANDExpressionNoIn10772 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn10776 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000004000000UL });
    public static readonly BitSet FOLLOW_bitwiseXORExpression_in_bitwiseORExpression10808 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000400000UL });
    public static readonly BitSet FOLLOW_OR_in_bitwiseORExpression10814 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_bitwiseXORExpression_in_bitwiseORExpression10818 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000400000UL });
    public static readonly BitSet FOLLOW_bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn10845 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000400000UL });
    public static readonly BitSet FOLLOW_OR_in_bitwiseORExpressionNoIn10851 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn10855 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000400000UL });
    public static readonly BitSet FOLLOW_bitwiseANDExpression_in_bitwiseXORExpression10886 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000800000UL });
    public static readonly BitSet FOLLOW_XOR_in_bitwiseXORExpression10892 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_bitwiseANDExpression_in_bitwiseXORExpression10896 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000800000UL });
    public static readonly BitSet FOLLOW_bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn10923 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000800000UL });
    public static readonly BitSet FOLLOW_XOR_in_bitwiseXORExpressionNoIn10929 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn10933 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000800000UL });
    public static readonly BitSet FOLLOW_equalityExpression_in_bitwiseANDExpression10960 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000200000UL });
    public static readonly BitSet FOLLOW_AND_in_bitwiseANDExpression10966 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_equalityExpression_in_bitwiseANDExpression10970 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000200000UL });
    public static readonly BitSet FOLLOW_equalityExpressionNoIn_in_bitwiseANDExpressionNoIn10997 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000200000UL });
    public static readonly BitSet FOLLOW_AND_in_bitwiseANDExpressionNoIn11003 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_equalityExpressionNoIn_in_bitwiseANDExpressionNoIn11007 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000200000UL });
    public static readonly BitSet FOLLOW_relationalExpression_in_equalityExpression11035 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000780UL });
    public static readonly BitSet FOLLOW_set_in_equalityExpression11041 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_relationalExpression_in_equalityExpression11053 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000780UL });
    public static readonly BitSet FOLLOW_relationalExpressionNoIn_in_equalityExpressionNoIn11080 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000780UL });
    public static readonly BitSet FOLLOW_set_in_equalityExpressionNoIn11086 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_relationalExpressionNoIn_in_equalityExpressionNoIn11099 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000780UL });
    public static readonly BitSet FOLLOW_shiftExpression_in_relationalExpression11127 = new BitSet(new ulong[] { 0x0000000009800012UL, 0x0000000000000038UL });
    public static readonly BitSet FOLLOW_GT_in_relationalExpression11147 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000043033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_ASSIGN_in_relationalExpression11152 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_set_in_relationalExpression11185 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_shiftExpression_in_relationalExpression11223 = new BitSet(new ulong[] { 0x0000000009800012UL, 0x0000000000000038UL });
    public static readonly BitSet FOLLOW_shiftExpression_in_relationalExpressionNoIn11259 = new BitSet(new ulong[] { 0x0000000009000012UL, 0x0000000000000038UL });
    public static readonly BitSet FOLLOW_GT_in_relationalExpressionNoIn11279 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000043033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_ASSIGN_in_relationalExpressionNoIn11284 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_set_in_relationalExpressionNoIn11317 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_shiftExpression_in_relationalExpressionNoIn11353 = new BitSet(new ulong[] { 0x0000000009000012UL, 0x0000000000000038UL });
    public static readonly BitSet FOLLOW_additiveExpression_in_shiftExpression11386 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000040010UL });
    public static readonly BitSet FOLLOW_SHL_in_shiftExpression11408 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_GT_in_shiftExpression11430 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000010UL });
    public static readonly BitSet FOLLOW_GT_in_shiftExpression11434 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_GT_in_shiftExpression11485 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000010UL });
    public static readonly BitSet FOLLOW_GT_in_shiftExpression11489 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000010UL });
    public static readonly BitSet FOLLOW_GT_in_shiftExpression11493 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_additiveExpression_in_shiftExpression11540 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000040010UL });
    public static readonly BitSet FOLLOW_multiplicativeExpression_in_additiveExpression11570 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000001800UL });
    public static readonly BitSet FOLLOW_set_in_additiveExpression11576 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_multiplicativeExpression_in_additiveExpression11584 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000001800UL });
    public static readonly BitSet FOLLOW_unaryExpression_in_multiplicativeExpression11608 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x000000000000E000UL });
    public static readonly BitSet FOLLOW_set_in_multiplicativeExpression11614 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_unaryExpression_in_multiplicativeExpression11623 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x000000000000E000UL });
    public static readonly BitSet FOLLOW_postfixExpression_in_unaryExpression11647 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_set_in_unaryExpression11658 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_unaryExpression_in_unaryExpression11668 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_unaryOp_in_unaryExpression11678 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000000002008UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_postfixExpression_in_unaryExpression11680 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_set_in_unaryOp11711 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_leftHandSideExpression_in_postfixExpression11768 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000030000UL });
    public static readonly BitSet FOLLOW_postfixOp_in_postfixExpression11770 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_set_in_postfixOp11796 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_primaryExpression_in_memberExpression11818 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_functionExpression_in_memberExpression11823 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_newExpression_in_memberExpression11828 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_NEW_in_newExpression11841 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000000002008UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_primaryExpression_in_newExpression11846 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_memberExpression_in_leftHandSideExpression11863 = new BitSet(new ulong[] { 0xA000000000000002UL, 0x0000400000000002UL });
    public static readonly BitSet FOLLOW_arguments_in_leftHandSideExpression11878 = new BitSet(new ulong[] { 0xA000000000000002UL, 0x0000400000000002UL });
    public static readonly BitSet FOLLOW_LBRACK_in_leftHandSideExpression11890 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_expression_in_leftHandSideExpression11894 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000001UL });
    public static readonly BitSet FOLLOW_RBRACK_in_leftHandSideExpression11898 = new BitSet(new ulong[] { 0xA000000000000002UL, 0x0000400000000002UL });
    public static readonly BitSet FOLLOW_DOT_in_leftHandSideExpression11913 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0004000000002000UL, 0x0000000000005203UL });
    public static readonly BitSet FOLLOW_eitherIdentifier_in_leftHandSideExpression11918 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0002000000000000UL });
    public static readonly BitSet FOLLOW_XML_NS_OP_in_leftHandSideExpression11922 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0004000000002000UL, 0x0000000000005203UL });
    public static readonly BitSet FOLLOW_eitherIdentifier_in_leftHandSideExpression11929 = new BitSet(new ulong[] { 0xA000000000000002UL, 0x0000400000000002UL });
    public static readonly BitSet FOLLOW_XML_ELLIPSIS_in_leftHandSideExpression11941 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0004000000002000UL, 0x0000000000005203UL });
    public static readonly BitSet FOLLOW_eitherIdentifier_in_leftHandSideExpression11945 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0002000000000000UL });
    public static readonly BitSet FOLLOW_XML_NS_OP_in_leftHandSideExpression11949 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0004000000002000UL, 0x0000000000005203UL });
    public static readonly BitSet FOLLOW_eitherIdentifier_in_leftHandSideExpression11956 = new BitSet(new ulong[] { 0xA000000000000002UL, 0x0000400000000002UL });
    public static readonly BitSet FOLLOW_DOT_in_leftHandSideExpression11968 = new BitSet(new ulong[] { 0x2000000000000000UL });
    public static readonly BitSet FOLLOW_parExpression_in_leftHandSideExpression11972 = new BitSet(new ulong[] { 0xA000000000000002UL, 0x0000400000000002UL });
    public static readonly BitSet FOLLOW_typePostfixSyntax_in_leftHandSideExpression11982 = new BitSet(new ulong[] { 0xA000000000000002UL, 0x0000400000000002UL });
    public static readonly BitSet FOLLOW_IDENTIFIER_in_eitherIdentifier12012 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlPropertyIdentifier_in_eitherIdentifier12022 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_allKeywords_in_eitherIdentifier12028 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_IDENTIFIER_in_typeSpecifier12041 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_notQuiteReservedWord_in_typeSpecifier12047 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_INTERNAL_in_typeSpecifier12053 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_DEFAULT_in_typeSpecifier12061 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_set_in_notQuiteReservedWord12079 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_reservedWord_in_allKeywords12132 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_notQuiteReservedWord_in_allKeywords12136 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_set_in_reservedWord12153 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_LPAREN_in_arguments12717 = new BitSet(new ulong[] { 0xEBFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_assignmentExpression_in_arguments12729 = new BitSet(new ulong[] { 0x4000000000000000UL, 0x0000000000000004UL });
    public static readonly BitSet FOLLOW_COMMA_in_arguments12757 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_assignmentExpression_in_arguments12782 = new BitSet(new ulong[] { 0x4000000000000000UL, 0x0000000000000004UL });
    public static readonly BitSet FOLLOW_RPAREN_in_arguments12810 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_indexSuffix_in_suffix12849 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_propertyReferenceSuffix_in_suffix12853 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_LBRACK_in_indexSuffix12894 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_expression_in_indexSuffix12899 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000001UL });
    public static readonly BitSet FOLLOW_RBRACK_in_indexSuffix12904 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_DOT_in_propertyReferenceSuffix12932 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_IDENTIFIER_in_propertyReferenceSuffix12939 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_DOT_in_propertyReferenceSuffix12954 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0004000000002000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_xmlPropertyIdentifier_in_propertyReferenceSuffix12959 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_DOT_in_propertyReferenceSuffix12972 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_primaryExpressionHelper_in_primaryExpression13005 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_THIS_in_primaryExpressionHelper13032 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_SUPER_in_primaryExpressionHelper13046 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_literal_in_primaryExpressionHelper13058 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_arrayLiteral_in_primaryExpressionHelper13070 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_objectLiteral_in_primaryExpressionHelper13081 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_identifierLiteral_in_primaryExpressionHelper13093 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlPrimaryExpression_in_primaryExpressionHelper13104 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_parExpression_in_primaryExpressionHelper13114 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_conditionalCompilerOption_in_primaryExpressionHelper13125 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_LCURLY_in_objectLiteral13147 = new BitSet(new ulong[] { 0x13FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000005203UL });
    public static readonly BitSet FOLLOW_propertyNameAndValueList_in_objectLiteral13151 = new BitSet(new ulong[] { 0x1000000000000000UL });
    public static readonly BitSet FOLLOW_RCURLY_in_objectLiteral13156 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_propertyNameAndValue_in_propertyNameAndValueList13178 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000004UL });
    public static readonly BitSet FOLLOW_COMMA_in_propertyNameAndValueList13184 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000005203UL });
    public static readonly BitSet FOLLOW_propertyNameAndValue_in_propertyNameAndValueList13189 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000004UL });
    public static readonly BitSet FOLLOW_propertyName_in_propertyNameAndValue13210 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000020000000UL });
    public static readonly BitSet FOLLOW_COLON_in_propertyNameAndValue13214 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_assignmentExpression_in_propertyNameAndValue13232 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_identifierLiteral_in_propertyName13251 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_stringLiteral_in_propertyName13262 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_numericLiteral_in_propertyName13273 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_LBRACK_in_arrayLiteral13296 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033809UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_elementList_in_arrayLiteral13300 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000001UL });
    public static readonly BitSet FOLLOW_RBRACK_in_arrayLiteral13305 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_assignmentExpression_in_elementList13351 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000004UL });
    public static readonly BitSet FOLLOW_COMMA_in_elementList13369 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_assignmentExpression_in_elementList13386 = new BitSet(new ulong[] { 0x0000000000000002UL, 0x0000000000000004UL });
    public static readonly BitSet FOLLOW_COMMA_in_elementList13399 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_SUB_in_synpred9_AS3_ex3793 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_DOT_in_synpred9_AS3_ex3801 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_COLON_in_synpred9_AS3_ex3809 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0000000000000000UL, 0x0000000000004000UL });
    public static readonly BitSet FOLLOW_IDENTIFIER_in_synpred9_AS3_ex3820 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_allKeywords_in_synpred9_AS3_ex3826 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_XML_TEXT_in_synpred70_AS3_ex4890 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlTextElement_in_synpred71_AS3_ex4896 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlQualifiedIdentifier_in_synpred75_AS3_ex5123 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlQualifiedIdentifier_in_synpred76_AS3_ex5228 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlPropertySelector_in_synpred77_AS3_ex5243 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_propertyDeclaration_in_synpred99_AS3_ex6062 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_functionDeclaration_in_synpred100_AS3_ex6066 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_statement_in_synpred101_AS3_ex6070 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_directive_in_synpred102_AS3_ex6074 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_interfaceFunctionDeclaration_in_synpred103_AS3_ex6078 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_classOrInterfaceDecl_in_synpred105_AS3_ex6104 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_propertyDeclaration_in_synpred106_AS3_ex6108 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_functionDeclaration_in_synpred107_AS3_ex6112 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_interfaceFunctionDeclaration_in_synpred108_AS3_ex6116 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_statement_in_synpred109_AS3_ex6120 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_SEMI_in_synpred122_AS3_ex6479 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_propertyDeclaration_in_synpred131_AS3_ex6801 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_functionDeclaration_in_synpred132_AS3_ex6805 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_statement_in_synpred133_AS3_ex6809 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_propertyDeclaration_in_synpred134_AS3_ex6830 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_interfaceFunctionDeclaration_in_synpred135_AS3_ex6834 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_statement_in_synpred136_AS3_ex6838 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_memberModifiers_in_synpred144_AS3_ex6975 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_statement_in_synpred159_AS3_ex7457 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_functionDeclaration_in_synpred160_AS3_ex7459 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_memberModifier_in_synpred161_AS3_ex7501 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_blockStatement_in_synpred171_AS3_ex7668 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_directive_in_synpred172_AS3_ex7679 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_namespaceDirective_in_synpred173_AS3_ex7690 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_expression_in_synpred174_AS3_ex7703 = new BitSet(new ulong[] { 0x1400000000000000UL, 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_semic_in_synpred174_AS3_ex7705 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_constantVarStatement_in_synpred175_AS3_ex7720 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_tryStatement_in_synpred176_AS3_ex7733 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_labelledStatement_in_synpred177_AS3_ex7745 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_switchStatement_in_synpred178_AS3_ex7758 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_withStatement_in_synpred179_AS3_ex7770 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_returnStatement_in_synpred180_AS3_ex7784 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_breakStatement_in_synpred181_AS3_ex7800 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_continueStatement_in_synpred182_AS3_ex7816 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_forStatement_in_synpred183_AS3_ex7830 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_forInStatement_in_synpred184_AS3_ex7842 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_forEachInStatement_in_synpred185_AS3_ex7854 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_doWhileStatement_in_synpred186_AS3_ex7866 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_whileStatement_in_synpred187_AS3_ex7878 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_ifStatement_in_synpred188_AS3_ex7889 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_variableStatement_in_synpred190_AS3_ex7914 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_SEMI_in_synpred193_AS3_ex8054 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_catchClause_in_synpred197_AS3_ex8290 = new BitSet(new ulong[] { 0x0000000000020080UL });
    public static readonly BitSet FOLLOW_finallyClause_in_synpred197_AS3_ex8293 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_catchClause_in_synpred199_AS3_ex8305 = new BitSet(new ulong[] { 0x0000000000000082UL });
    public static readonly BitSet FOLLOW_statement_in_synpred201_AS3_ex8571 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_variableDeclarationNoInList_in_synpred211_AS3_ex9126 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_SEMI_in_synpred212_AS3_ex9207 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_ELSE_in_synpred213_AS3_ex9446 = new BitSet(new ulong[] { 0xAFFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_statement_in_synpred213_AS3_ex9487 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_leftHandSideExpression_in_synpred230_AS3_ex10219 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x00001F3E40002010UL });
    public static readonly BitSet FOLLOW_assignmentOperator_in_synpred230_AS3_ex10222 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_assignmentExpression_in_synpred230_AS3_ex10225 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_conditionalExpressionNoIn_in_synpred231_AS3_ex10253 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_GT_in_synpred274_AS3_ex11147 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000043033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_ASSIGN_in_synpred274_AS3_ex11152 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_set_in_synpred274_AS3_ex11185 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_shiftExpression_in_synpred274_AS3_ex11223 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_GT_in_synpred285_AS3_ex11475 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000010UL });
    public static readonly BitSet FOLLOW_GT_in_synpred285_AS3_ex11477 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000010UL });
    public static readonly BitSet FOLLOW_GT_in_synpred285_AS3_ex11479 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_set_in_synpred288_AS3_ex11576 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_multiplicativeExpression_in_synpred288_AS3_ex11584 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_set_in_synpred291_AS3_ex11614 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_unaryExpression_in_synpred291_AS3_ex11623 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_postfixExpression_in_synpred292_AS3_ex11647 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_set_in_synpred294_AS3_ex11658 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_unaryExpression_in_synpred294_AS3_ex11668 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_postfixOp_in_synpred303_AS3_ex11770 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_arguments_in_synpred307_AS3_ex11878 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_LBRACK_in_synpred308_AS3_ex11890 = new BitSet(new ulong[] { 0xABFFFFFFFFFFFFF0UL, 0x000C000003033808UL, 0x0000000000075213UL });
    public static readonly BitSet FOLLOW_expression_in_synpred308_AS3_ex11894 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0000000000000001UL });
    public static readonly BitSet FOLLOW_RBRACK_in_synpred308_AS3_ex11898 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_eitherIdentifier_in_synpred309_AS3_ex11918 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0002000000000000UL });
    public static readonly BitSet FOLLOW_XML_NS_OP_in_synpred309_AS3_ex11922 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_DOT_in_synpred310_AS3_ex11913 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0004000000002000UL, 0x0000000000005203UL });
    public static readonly BitSet FOLLOW_eitherIdentifier_in_synpred310_AS3_ex11918 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0002000000000000UL });
    public static readonly BitSet FOLLOW_XML_NS_OP_in_synpred310_AS3_ex11922 = new BitSet(new ulong[] { 0x03FFFFFFFFFFFFF0UL, 0x0004000000002000UL, 0x0000000000005203UL });
    public static readonly BitSet FOLLOW_eitherIdentifier_in_synpred310_AS3_ex11929 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_eitherIdentifier_in_synpred311_AS3_ex11945 = new BitSet(new ulong[] { 0x0000000000000000UL, 0x0002000000000000UL });
    public static readonly BitSet FOLLOW_XML_NS_OP_in_synpred311_AS3_ex11949 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_DOT_in_synpred313_AS3_ex11968 = new BitSet(new ulong[] { 0x2000000000000000UL });
    public static readonly BitSet FOLLOW_parExpression_in_synpred313_AS3_ex11972 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_typePostfixSyntax_in_synpred314_AS3_ex11982 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_IDENTIFIER_in_synpred315_AS3_ex12012 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlPropertyIdentifier_in_synpred316_AS3_ex12022 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_THIS_in_synpred378_AS3_ex13032 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_SUPER_in_synpred379_AS3_ex13046 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_literal_in_synpred380_AS3_ex13058 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_identifierLiteral_in_synpred383_AS3_ex13093 = new BitSet(new ulong[] { 0x0000000000000002UL });
    public static readonly BitSet FOLLOW_xmlPrimaryExpression_in_synpred384_AS3_ex13104 = new BitSet(new ulong[] { 0x0000000000000002UL });

}
